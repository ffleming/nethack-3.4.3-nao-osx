diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/README.gray nethack-3.4.3-nao-osx/README.gray
--- nethack-3.4.3/README.gray	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/README.gray	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,42 @@
+This copy of the nethack source includes a patch to allow black objects
+(orcish daggers, ravens, pits, etc.) to be represented using a dark shade
+of gray on some terminals.  Normally, nethack shows them as blue to avoid
+printing unreadable black-on-black text, but this confuses them with with
+objects that are actually blue (cornuthaums, sapphires, soldier ants,
+etc.).
+
+The patch works by specifying "black foreground" and "boldface" at the
+same time.  On terminals that simulate bold with brighter colors, this
+produces a distinct color.  Terminal emulators based on PC CGA/EGA/VGA
+textmode generally have this property.
+
+However, on terminals that implement actual bolding -- thickening the
+font without changing the color, it will result in invisible text.  So,
+the feature is not enabled by default.  It must be activated with the new
+option "use_darkgray".
+
+Notes:
+ * This patch is only effective in when TERMINFO is defined in unixconf.h
+
+ * Highlights added by the existing "use_inverse" and/or "hilite_pet"
+options will probably not be visible when applied to black objects.
+
+ * nethack doesn't properly follow the rules for using the tputs()
+function of termcap/curses.  The first argument is supposed to be a string
+obtained from the termcap/terminfo functions.  Nethack assumes it can
+provide a null pointer to do nothing, and can string-concatenate two codes
+(boldface and a color select) and use them as one.
+   My code does not fix this -- although it uses "" instead of a null
+pointer, which is less likely to crash on a less permissive
+termcap/terminfo implementation.
+
+ * I'm aware of a seperate patch to add darkgray support -- but it was
+unconditional at runtime, and had to change the color numbers in
+includes/color.h to work.  My patch makes the TTY code independent of the
+actual value of the CLR_* defines.
+
+ * I personally believe the correct spelling of the color involved is
+"grey", however I have adopted the popular misspelling "gray" throughout
+to be consistent with the rest of nethack. :)
+
+---- Michael Deutschmann <michael@talamasca.ocis.net>
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/README.md nethack-3.4.3-nao-osx/README.md
--- nethack-3.4.3/README.md	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/README.md	2014-12-24 13:48:42.000000000 -0800
@@ -0,0 +1,153 @@
+NetHack 3.4.3, NAO version, for OSX
+===
+
+This repository contains a fork of the [nethack.alt.org](http://nethack.alt.org) repository altered for OSX installation.
+
+Automated installation
+---
+The purpose of this repository is to allow a more playable (i.e. heavily patched, but not in a play-altering way) version of Nethack to be easily installed via the Homebrew package manager.  If my (forthcoming) PR is accepted, installation will be as simple as
+```
+% brew install nethack
+```
+Until then, however...
+
+Manual installation
+---
+1. Clone the repo
+    ```
+    % git clone git@github.com:ffleming/nethack-3.4.3-nao-osx.git
+    ```
+2. Enter the repo
+   ```
+   % cd nethack-3.4.3-nao-osx
+   ```
+3. Setup (no autoconf here!)
+   ```
+   % sh sys/unux/setup.sh l
+   ```
+4. Build
+   ```
+   % make
+   ```
+5. Install
+   ```
+   % sudo make install
+   ```
+
+New changes
+---
+* Necessary alterations for compiling on OSX
+* Install to `/opt/nethack`
+* Define SHELL to allow use of `!` to drop to a shell
+* A [patch](https://raw.githubusercontent.com/ffleming/nethack-3.4.3-nao-osx/master/nethack-3.4.3-nao-osx.patch) against vanilla nethack 3.4.3 for use by [Homebrew](http://brew.sh/) via `brew install nethack`
+
+The patch
+---
+Created with `diff --exclude=.git* --exclude=*.diff --exclude=*.patch --exclude=Makefile -rupN "$VANILLA_DIR/" "$PATCHED_DIR/" > "$PATCH_FILENAME"`
+
+Changes implemented by NAO
+---
+* Fixed several bugs:
+     * C343-19 Dipping acid in a fountain may not destroy the acid. (Patric Mueller)
+     * C343-52 Worn or wielded objects destroyed by dipping into lit potions of oil are not handled properly (Patric Mueller)
+     * C343-74 Entering a long running, uninterruptible command after stoning starts will kill you. (Patric Mueller)
+     * C343-98 Reset stored ID of quest leader when undead-turned, allowing #chat to work properly. (Steve Melenchuk)
+     * C343-100 Game may crash if thrown potion hits bars before a monster. (Patric Mueller)
+     * C343-171 Silver weapon damage message is sometimes missing when hero is polymorphed (Patric Mueller)
+     * C343-172 Crash could occur when monster uses potion or food to cure stoning or confusion. (Ray Chason)
+     * C343-179 If a monster is killed or tamed while over water (or by a drawbridge) while carrying a potion of acid, the game may panic. (Patric Mueller)
+     * C343-189 Temple donations and protection lost to gremlin attack interact incorrectly. (Patric Mueller)
+     * C343-198 Playing in a 20 or 21 line window can cause the game to crash.
+     * C343-218 Applying a wielded cream pie can crash the game.
+     * C343-231 Time is distorted while sinking into lava. (Patric Mueller)
+     * C343-235 Casting spell of protection gives incorrect message if hero is swallowed or in rock. (Patric Mueller)
+     * C343-268 Used up potion of acid may end up in bones file. (Patric Mueller)
+     * C343-275 If a lit, wielded, candle or potion of oil burns out, the game may crash.
+     * C343-276 If a figurine auto-transforms while wielded or worn, the game may crash.
+     * C343-317 Bones data can contain odd characters from player's dogname, catname, or fruit options; this can cause odd terminal-dependent behavior.
+     * C343-320 Reading a scroll of mail breaks illiterate conduct.
+     * C343-324 Cutting a long worm in two will crash the game if the cut takes the worm to 1 HP or if long worms had become extinct. (Patric Mueller)
+     * C343-349 An identify scroll is wasted if space is typed and steps off the end of the inventory list. (Steve Melenchuk)
+     * C343-439 Running NetHack in a terminal window with more than 255 rows or columns produces display errors. (Patric Mueller)
+     * SC343-11 It's possible to easily find the identity of a high priest on the Astral plane.
+     * SC343-12 Hero using telepathy can abuse Call on the Astral Plane. 
+     * SC343-20 Hangup save while picking up gold in a shop may duplicate the gold. (Patric Mueller)
+* Added the [Curses windowport](http://nethackwiki.com/wiki/Curses_interface), with a fix for monster detection not waiting for --more--.
+* Added boolean option [quiver_fired](http://bilious.alt.org/?287) (Patch by Jukka Lahtinen)
+* [Sortloot](http://bilious.alt.org/?42) (by Jukka Lahtinen), with more sorting types from UnNetHack (by Patric Mueller)
+* Pressing cmd key at direction prompt selects previously selected direction. (Patric Mueller, unnethack r844)
+* The impossible-warning tells to save, not quit.
+* Livelog reporting (for IRC, etc)
+* Whereis-file user tracking, from SporkHack, with minor changes.
+* Random player statues takes names from top1000, not top10
+* Several new T-shirt messages, random epitaphs and engravings, hallucinatory monsters
+* Changed 'C' to present a menu, and added old_C_behaviour boolean option to restore vanilla 3.4.3 monster christening behaviour
+* [Dungeon colors](http://bilious.alt.org/?17) -patch (Pasi Kallinen)
+* Changed 'X' to toggle twoweapon instead of trying to enter explore mode
+* [Extinct and Showborn](http://bilious.alt.org/?43) -patch (Jukka Lahtinen)
+* [Paranoid Quit](http://bilious.alt.org/?44) -patch
+* [Window edge](http://bilious.alt.org/?14) -patch (Pasi Kallinen)
+* [Dumplog](http://bilious.alt.org/?40) -patch (Jukka Lahtinen), with some minor changes
+* [Menucolors](http://bilious.alt.org/?11) -patch (Pasi Kallinen)
+* <s>[HitPoint Monitor](http://bilious.alt.org/?45) -patch (Ralph Churchill)</s> (removed)
+* Simple Mail -patch, from [dgamelaunch](http://nethackwiki.com/wiki/Dgamelaunch)
+* [Extended Logfile](http://bilious.alt.org/?289) -patch (Aardvark Joe), with some small changes
+* A boolean option 'bones' to disable bone-file loading.
+* [Messagetype-option](http://bilious.alt.org/?397) -patch (Pasi Kallinen)
+* A patch to allow server admin to notify players.
+* A patch to allow NetHack output special escape codes (vt_tiledata -boolean option)
+* [fcntl locking](http://bilious.alt.org/?412) -patch
+* [use_darkgray](http://bilious.alt.org/?205) -patch (Michael Deutschmann)
+* [Show BUC](http://bilious.alt.org/?198) -patch (Pasi Kallinen)
+* [Show Sym](http://bilious.alt.org/?15) -patch (Pasi Kallinen)
+* [While Helpless](http://bilious.alt.org/?12) -patch (Pasi Kallinen)
+* A patch to make RNG prediction harder
+* Make NetHack assume the clearscreen escape code is always available, instead of complaining.
+* Fix 100% CPU usage when terminal closed at a --more--- prompt. (tty windowport)
+* Make cursor keys not escape out of a text entry prompt (tty windowport)
+* Added [Pickup thrown](http://bilious.alt.org/?98) -patch (Roderick Schertler)
+* Added a modified version of [key rebinding](http://bilious.alt.org/?148) -patch (Jason Dorje Short)
+* Added a generic item use menu (from AceHack, via UnNetHack)
+* Added [monster targeting](http://bilious.alt.org/?415) -patch (Pasi Kallinen)
+* Force a screen redraw every 2k turns after the previous screen redraw.
+* Fixed farlooking at food items in curses windowport.
+* Prevent the Book of the Dead from being destroyed when falling into (or walking over) lava without fire resistance. (Steve Melenchuk)
+* Added `botl_updates` option to prevent status line updates, and extended command `#updatestatus` to force an update.
+* Added `hp_notify` option to turn on HP change notifications in the message lines, and `hp_notify_fmt` to configure the notification format.
+* Changed TTY msghistory maximum to 400.
+* Added [Statuscolors](http://bilious.alt.org/?142) -patch. (From UnNetHack)
+* Added hitpointbar (from UnNetHack)
+* Added boolean option msgtype_regex, if true, MSGTYPE-lines use regular expressions instead of globbing.
+* Added boolean option apexception_regex, if true, AUTOPICKUP_EXCEPTION-lines use regular expressions insteaed of globbing.
+* Show shop prices when walking over the items in the shop. Turn off with show_shop_prices option. (from UnNetHack)
+* Added item_use_menu boolean option, to turn off the generic item use menu used via inventory.
+* Added msg_wall_hits boolean option. If true, mentions in the message area whenever you walk against a wall. Useful for blind players.
+* Added item glyphs (colored symbols) to tty menus. (from UnNetHack) Boolean option menu_glyphs to turn them on and off.
+* Fixed option parsing causing buffer overflow. (Found by Matthew Daley)
+* Write extra info file for dgamelaunch use.
+* Prevent [artifact naming](http://nethackwiki.com/wiki/Artifact_naming).
+* Fix several crashes in case makemon() returns null. (From UnNetHack r1067)
+* Record HUP exploits into a file.
+* Fix some crashes related to displaying ball/chain and beam glyphs.
+* Fix a crash with hitpointbar. (From UnNetHack)
+* New boolean option "hilite_hidden_stairs", will try to show item with red background, if stairs are underneath it.
+* New boolean option "hilite_obj_piles", will try to show item piles with blue background.
+* Bugfix: prevent dangling pointer when applying a container that might have been destroyed (Patric Mueller)
+* Added "View discoveries" -option to the #call menu
+* Added MONSTERCOLOR config option (From UnNetHack)
+* Made STATUSCOLOR support exact numbers, eg. `STATUSCOLOR=hp.1:red&inverse,hp<8:red,hp>50:grey`
+* Fix TTY crashing when a location has more than 32k item stacks
+* Fix impossible() giving out faulty values (Pat Rankin)
+* Curses: Fix 100% CPU usage when terminal was lost at DYWYPI prompt
+* Curses: Fix selecting parts of multiple stacks (Alexander Gabriel)
+* Prevent perm -file lock from staying around when terminal is closed at "Destroy old game" -prompt.
+* Fix a crash when restoring a game when riding and detecting monsters. (Patric Mueller)
+* Fix segfault when teleporting onto a sink while equipping levitation boots. (found by Alex Smith)
+* Fix a crash when picking up an unpaid object from a location shared between two shops. (Patric Mueller)
+* Fix scroll of charging not working when used via item_use_menu.
+* Experimental support for UTF8 graphics. (Patric Mueller)
+* Implement menu_search for windowtype:tty
+* Curses: Actually show the "Destroy old game" -prompt
+* Fix stat abuse of gauntlets of dexterity and helm of brilliance (by Alex Smith)
+* Multiple possible bones files per level (via UnNetHack)
+</ul>
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/README.menucolor nethack-3.4.3-nao-osx/README.menucolor
--- nethack-3.4.3/README.menucolor	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/README.menucolor	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,106 @@
+
+   This is version 1.5 of the menucolors patch.
+
+   This patch allows the user to define in what color menus are shown.
+   For example, putting
+
+   OPTIONS=menucolors
+   MENUCOLOR=" blessed "=green
+   MENUCOLOR=" holy "=green
+   MENUCOLOR=" cursed "=red
+   MENUCOLOR=" unholy "=red
+   MENUCOLOR=" cursed .* (being worn)"=orange&underline
+
+   in the configuration file makes all known blessed items
+   show up in green, all cursed items show up in red and
+   all cursed worn items show up in orange and underlined
+   when viewing inventory.
+
+   If you have regex.h but it is not GNU (e.g. DJGPP, *BSD), uncomment
+   #define MENU_COLOR_REGEX_POSIX in include/config.h
+
+   If you do not have regex.h, comment
+   #define MENU_COLOR_REGEX out from include/config.h
+   and replace the MENUCOLOR lines in your config file with these:
+
+   MENUCOLOR="* blessed *"=green
+   MENUCOLOR="* holy *"=green
+   MENUCOLOR="* cursed *"=red
+   MENUCOLOR="* unholy *"=red
+   MENUCOLOR="* cursed * (being worn)"=orange&underline
+
+
+   Colors: black, red, green, brown, blue, magenta, cyan, gray, orange,
+           lightgreen, yellow, lightblue, lightmagenta, lightcyan, white.
+   Attributes: none, bold, dim, underline, blink, inverse.
+
+   Note that the terminal is free to interpret the attributes however
+   it wants.
+
+
+   TODO/BUGS:
+
+    o Only works with TTY and Windows GUI.
+    o You can't use '=' or '&' in the match-string.
+    o Maybe add color-field to tty_menu_item in include/wintty.h
+      (so there's no need to find the color for the line again)
+    o Guidebook is not up to date
+    o Better place to put the functions, colornames[] and attrnames[]?
+    o Some menus do not need coloring; maybe add new parameter
+      to process_menu_window()?
+
+
+   FIXES:
+
+   v1.5:
+    o Partial support for Windows GUI windowport; supports colors,
+      but not attributes.
+
+   v1.4:
+    o Option to use standard instead of GNU regex functions.
+
+   v1.3:
+    o Updated to use 3.4.3 codebase.
+    o Added a text to #version to show menucolors is compiled in.
+
+   v1.2:
+    o Updated to use 3.4.2 codebase.
+
+   v1.1:
+    o Updated to use 3.4.1 codebase.
+    o replaced USE_REGEX_MATCH with MENU_COLOR_REGEX
+
+   v1.04:
+    o Oops! 1.03 worked only on *nixes... (GNU regex.h)
+    o Compile-time option USE_REGEX_MATCH: if it's defined, use regex,
+      otherwise use globbing. ('?' and '*' wildcards)
+
+   v1.03:
+
+    o Now using Nethack 3.4.0 codebase
+    o Compile-time option MENU_COLOR
+    o Strings match using regular expressions instead of globbing
+    o You can use attribute with color (attr must come after '&')
+    o Use ``MENUCOLOR="foo"=color'' instead of ``OPTIONS=menucolor=...''
+      (Both work, but OPTIONS complains if you define menucolor
+      more than once)
+
+   v1.02:
+
+    o Should now work with OS/2, thanks to Jukka Lahtinen
+    o Strings match now using simple globbing. ('?' and '*' wildcards)
+
+   v1.01:
+
+    o Moved 'menucolors' boolean option, so now the options-menu
+      is in alphabetical order.
+    o Fixed 'menucolor' description in dat/opthelp.
+    o menu_colorings is now initialized to null in src/decl.c.
+
+   v1.0:
+
+    o Initial release
+
+--
+ Pasi Kallinen
+ paxed@alt.org
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/dat/cmdhelp nethack-3.4.3-nao-osx/dat/cmdhelp
--- nethack-3.4.3/dat/cmdhelp	2003-12-07 15:39:12.000000000 -0800
+++ nethack-3.4.3-nao-osx/dat/cmdhelp	2014-12-20 12:08:36.000000000 -0800
@@ -69,7 +69,7 @@ V       Show long version and game histo
 w       Wield (put in use) a weapon
 W       Wear a piece of armor
 x       Swap wielded and secondary weapons
-X       Enter explore (discovery) mode (only if defined)
+X       Toggle two-weapon combat
 y       Go northwest 1 space
 Y       Go northwest until you are on top of something
 ^Y      Go northwest until you are near something
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/dat/help nethack-3.4.3-nao-osx/dat/help
--- nethack-3.4.3/dat/help	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/dat/help	2014-12-20 12:08:36.000000000 -0800
@@ -141,7 +141,7 @@ Commands:
         w       Wield weapon.  w- means wield nothing, use bare hands.
         W       Wear armor.
         x       Swap wielded and secondary weapons.
-        X       Switch the game to explore (discovery) mode.
+        X       Toggle twoweapon combat.
         ^X      Show your attributes.
         z       Zap a wand.
         Z       Cast a spell.
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/dat/hh nethack-3.4.3-nao-osx/dat/hh
--- nethack-3.4.3/dat/hh	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/dat/hh	2014-12-20 12:08:36.000000000 -0800
@@ -26,7 +26,7 @@ O       options set options
 \       known   display list of what's been discovered
 v       version display version number
 V       history display game history
-X       explore switch the game to explore (discovery) mode
+X       twotweapon toggle two-weapon combat
 ^A      again   redo the previous command (^A denotes the keystroke CTRL-A)
 ^R      redraw  redraw the screen
 ^P      prevmsg repeat previous message (subsequent ^P's repeat earlier ones)
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/dat/opthelp nethack-3.4.3-nao-osx/dat/opthelp
--- nethack-3.4.3/dat/opthelp	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/dat/opthelp	2014-12-20 12:08:36.000000000 -0800
@@ -25,9 +25,13 @@ null           allow nulls to be sent to
                delay code) if moving objects seem to teleport across rooms
 number_pad     use the number keys to move instead of yuhjklbn    [FALSE]
 perm_invent    keep inventory in a permanent window               [FALSE]
+pickup_thrown  autopickup things you threw                        [FALSE]
 prayconfirm    use confirmation prompt when #pray command issued  [TRUE]
 pushweapon     when wielding a new weapon, put your previously
                wielded weapon into the secondary weapon slot      [FALSE]
+quiver_fired   when using the f (fire) command and no ammunition
+               is quivered, prompt for ammunition to quiver, then 
+               fire it.                                           [TRUE]
 rawio          allow the use of raw I/O                           [FALSE]
 rest_on_space  count the space bar as a rest character            [FALSE]
 safe_pet       prevent you from (knowingly) attacking your pet(s) [TRUE]
@@ -61,6 +65,19 @@ news       print any news from game admi
 Boolean option if MFLOPPY was set at compile time:
 checkspace check free disk space before writing files to disk     [TRUE]
 
+Boolean option if SHOW_BORN was set at compile time:
+showborn   show numbers of created monsters after the number
+           vanquished                                             [FALSE]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_hit   ask for explicit 'yes' when hitting peacefuls      [FALSE]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_quit  ask for explicit 'yes' when quitting               [FALSE]
+
+Boolean option if PARANOID was set at compile time:
+paranoid_remove always show menu with the T and R commands        [FALSE]
+
 Boolean option if EXP_ON_BOTL was set at compile time:
 showexp    display your accumulated experience points             [FALSE]
 
@@ -82,6 +99,9 @@ preload_tiles  control whether tiles get
                start of the game.  Doing so enhances performance
                of the tile graphics, but uses more memory.        [TRUE]
 
+Boolean option if WIN_EDGE was set at compile time (tty interface only):
+win_edge       align menus and text windows left instead of right [FALSE]
+
 Any Boolean option can be negated by prefixing it with a '!' or 'no'.
 
 
@@ -92,6 +112,9 @@ Compound options which can be set during
 boulder       override the default boulder symbol with another default: [`]
 disclose      the types of information you want offered at the end of the
               game  [ni na nv ng nc]
+dumpfile      the name of the file where to dump the disclosure information
+              when the game ends (only if the patch has been compiled in)
+              [none]
 fruit         the name of a fruit you enjoy eating  [slime mold]
               (basically a whimsy which NetHack uses from time to time).
 menustyle     user interface for selection of multiple objects:
@@ -120,6 +143,11 @@ runmode       controls how often the map
 scores        the parts of the score list you wish to see when the game ends
               You choose a combination of top scores, scores around the top
               scores, and all of your own scores.  [!own/3 top/2 around]
+sortloot      controls the sortloot patch [none]:
+              full -- All pickup lists of items are sorted by item description
+              loot -- When inventory letters are shown, has no effect.
+                      Otherwise sorts by description
+              none -- Works the traditional way, like without the patch
 suppress_alert disable various version-specific warnings about changes
               in game play or the user interface, such as notification given
               for the 'Q' command that quitting is now done via #quit
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/dat/wizhelp nethack-3.4.3-nao-osx/dat/wizhelp
--- nethack-3.4.3/dat/wizhelp	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/dat/wizhelp	2014-12-20 12:08:36.000000000 -0800
@@ -16,6 +16,7 @@ Debug-Mode Quick Reference:
 #panic == panic test
 #polyself == polymorph self
 #seenv == show seen vectors
+#showkills == show numbers of monsters killed
 #stats == show memory statistics
 #timeout == look at timeout queue
 #vision == show vision array
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/doc/Guidebook.mn nethack-3.4.3-nao-osx/doc/Guidebook.mn
--- nethack-3.4.3/doc/Guidebook.mn	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/doc/Guidebook.mn	2014-12-20 12:08:36.000000000 -0800
@@ -1770,6 +1770,12 @@ traps and each other as well as by you.
 .lp dogname
 Name your starting dog (ex. ``dogname:Fang'').
 Cannot be set with the `O' command.
+.lp dumpfile
+The name of a file where the disclosure information is written when the
+game ends. You may use the macro %n that will be replaced with the name
+of your player character. The game must have write permissions to the
+directory where the file is written. Normally /tmp may be used for unix
+systems.
 .lp dungeon
 Set the graphics symbols for displaying the dungeon
 (default \&``\ |--------||.-|++##.##<><>_|\e\e#{}.}..##\ #}'').
@@ -2027,6 +2033,15 @@ Specify the order to list object types i
 The value of this option should be a string containing the
 symbols for the various object types.  Any omitted types are filled in
 at the end from the previous order.
+.lp paranoid_hit
+If true, asks you to type the word ``yes'' when hitting any peaceful
+monster, not just the letter ``y''.
+.lp paranoid_quit
+If true, asks you to type the word ``yes'' when quitting or entering
+Explore mode, not just the letter ``y''.
+.lp paranoid_remove
+If true, always show menu with the R and T commands even when there is
+only one item to remove or take off.
 .lp perm_invent
 If true, always display your current inventory in a window.  This only
 makes sense for windowing system interfaces that implement this feature.
@@ -2088,6 +2103,10 @@ Prevent you from (knowingly) attacking y
 Control what parts of the score list you are shown at the end (ex.
 ``scores:5 top scores/4 around my score/own scores'').  Only the first
 letter of each category (`t', `a', or `o') is necessary.
+.lp showborn
+When the game ends, show the number of each monster created
+in the "Vanquished creatures" list, if it differs from the
+number of those monsters killed.
 .lp showexp
 Show your accumulated experience points on bottom line (default off).
 .lp showrace
@@ -2098,6 +2117,18 @@ the appearance of the display, not the w
 Show your approximate accumulated score on bottom line (default off).
 .lp "silent  "
 Suppress terminal beeps (default on).
+.lp sortloot
+Controls the behavior of the sortloot patch that sorts pickup lists for
+inventory and #loot commands and some others.
+The possible values are:
+.sd
+.si
+full - always sort the lists;
+loot - only sort the lists that don't use inventory
+       letters, like with the #loot and pickup commands;
+none - show lists the traditional way without sorting.
+.ei
+.ed
 .lp sortpack
 Sort the pack contents by type when displaying inventory (default on).
 .lp sound
@@ -2157,6 +2188,8 @@ Provide more commentary during the game 
 Select which windowing system to use, such as ``tty'' or ``X11''
 (default depends on version).
 Cannot be set with the `O' command.
+.lp win_edge
+Align menus and text windows in tty left instead of right. (default off)
 .hn 2
 Window Port Customization options
 .pg
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/doc/Guidebook.tex nethack-3.4.3-nao-osx/doc/Guidebook.tex
--- nethack-3.4.3/doc/Guidebook.tex	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/doc/Guidebook.tex	2014-12-20 12:08:36.000000000 -0800
@@ -2209,6 +2209,13 @@ traps and each other as well as by you. 
 Name your starting dog (ex.\ ``{\tt dogname:Fang}'').
 Cannot be set with the `{\tt O}' command.
 %.lp
+\item[\ib{dumpfile}]
+The name of a file where the disclosure information is written when the
+game ends. You may use the macro %n that will be replaced with the name
+of your player character. The game must have write permissions to the
+directory where the file is written. Normally /tmp may be used for unix
+systems.
+%.lp
 \item[\ib{dungeon}]
 Set the graphics symbols for displaying the dungeon (default
 ``\verb& |--------||.-|++##& \verb&.##<><>_|\\#{}.}..## #}&'').
@@ -2486,6 +2493,18 @@ Specify the order to list object types i
 containing the symbols for the various object types.  Any omitted types
 are filled in at the end from the previous order.
 %.lp
+\item[\ib{paranoid\_hit}]
+If true, asks you to type the word ``yes'' when hitting any peaceful
+monster, not just the letter ``y''.
+%.lp
+\item[\ib{paranoid\_quit}]
+If true, asks you to type the word ``yes'' when quitting or entering
+Explore mode, not just the letter ``y''.
+%.lp
+\item[\ib{paranoid\_remove}]
+If true, always show menu with the R and T commands even when there is
+only one item to remove or take off.
+%.lp
 \item[\ib{perm\_invent}]
 If true, always display your current inventory in a window.  This only
 makes sense for windowing system interfaces that implement this feature.
@@ -2559,6 +2578,11 @@ Control what parts of the score list you
 ``{\tt scores:5top scores/4around my score/own scores}'').  Only the first
 letter of each category (`{\tt t}', `{\tt a}' or `{\tt o}') is necessary.
 %.lp
+\item[\ib{showborn}]
+When the game ends, show the number of each monster created
+in the ``Vanquished creatures'' list, if it differs from the
+number of those monsters killed.
+%.lp
 \item[\ib{showexp}]
 Show your accumulated experience points on bottom line (default off).
 %.lp
@@ -2573,6 +2597,21 @@ Show your approximate accumulated score 
 \item[\ib{silent}]
 Suppress terminal beeps (default on).
 %.lp
+\item[\ib{sortloot}]
+Controls the behavior of the sortloot patch that sorts pickup lists for
+inventory and \#loot commands and some others.
+
+The possible values are:
+%.sd
+%.si
+{\tt full} --- always sort the lists;\\
+{\tt loot} --- only sort the lists that don't use inventory
+       letters, like with the \#loot and pickup commands;\\
+{\tt none} --- show lists the traditional way without sorting.
+%.ei
+%.ed
+%.lp
+The default is 'none', the way an unpatched game works.
 \item[\ib{sortpack}]
 Sort the pack contents by type when displaying inventory (default on).
 %.lp
@@ -2640,6 +2679,9 @@ Provide more commentary during the game 
 Select which windowing system to use, such as ``{\tt tty}'' or ``{\tt X11}''
 (default depends on version).
 Cannot be set with the `{\tt O}' command.
+%.lp
+\item[\ib{win_edge}]
+Align menus and text windows in tty left instead of right. (default off)
 \elist
 
 %.hn 2
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/doc/Guidebook.txt nethack-3.4.3-nao-osx/doc/Guidebook.txt
--- nethack-3.4.3/doc/Guidebook.txt	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/doc/Guidebook.txt	2014-12-20 12:08:36.000000000 -0800
@@ -2274,6 +2274,13 @@
             Name  your  starting dog (ex. ``dogname:Fang'').  Cannot be set
             with the `O' command.
 
+          dumpfile
+            The name of a file where the disclosure information is
+            written when the game ends. You may use the macro %n that
+            will be replaced with the name of your player character.
+            The game must have write permissions to the directory where
+            the file is written. Normally /tmp may be used for unixes.
+
           dungeon
             Set the graphics symbols for displaying  the  dungeon  (default
             `` |--------||.-|++##.##<><>_|\\#{}.}..## #}'').   The  dungeon
@@ -2607,6 +2614,18 @@
             Any  omitted  types  are filled in at the end from the previous
             order.
 
+          paranoid_hit
+            If true, asks you to type the word ``yes'' when hitting any
+            peaceful monster, not just the letter ``y''.
+
+          paranoid_quit
+            If true, asks you  to type the word ``yes'' when quitting or
+            entering Explore mode, not just the letter ``y''.
+
+          paranoid_remove
+            If true, always show menu with the R and T commands even when
+	    there is only one item to remove or take off.
+
           perm_invent
             If true, always display your current  inventory  in  a  window.
             This  only makes sense for windowing system interfaces that im-
@@ -2693,6 +2712,11 @@
             Only the first letter of each category (`t', `a',  or  `o')  is
             necessary.
 
+          showborn
+               When the game ends, show the number of each monster created
+               in the "Vanquished creatures" list, if it differs from the
+               number of those monsters killed.
+
           showexp
             Show your accumulated experience points on bottom line (default
             off).
@@ -2723,6 +2747,18 @@
           silent
             Suppress terminal beeps (default on).
 
+          sortloot
+            Controls the behavior of the sortloot patch that sorts
+            pickup lists for inventory and #loot commands and some
+            others.
+            The possible values are:
+
+                 full - always sort the lists
+                 loot - only sort the lists that don't use inventory
+                        letters, like with the #loot and pickup commands
+                 none - show lists the traditional way without sorting
+            The default is 'none', the way an unpatched game works.
+
           sortpack
             Sort the pack contents by type when displaying  inventory  (de-
             fault on).
@@ -2808,6 +2844,10 @@
             ``X11''  (default  depends on version).  Cannot be set with the
             `O' command.
 
+          win_edge
+            Align menus and text windows in tty left instead of right.
+            (default off)
+
           9.5.  Window Port Customization options
 
                Here are explanations of the various options that  are  used
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/doc/window.doc nethack-3.4.3-nao-osx/doc/window.doc
--- nethack-3.4.3/doc/window.doc	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/doc/window.doc	2014-12-20 12:08:36.000000000 -0800
@@ -518,6 +518,9 @@ to support:
   |  fullscreen        | WC2_FULLSCREEN     | wc2_fullscreen     |boolean |
   |  softkeyboard      | WC2_SOFTKEYBOARD   | wc2_softkeyboard   |boolean |
   |  wraptext          | WC2_WRAPTEXT       | wc2_wraptext       |boolean |
+  |  term_cols         | WC2_TERM_COLS      | wc2_term_cols      |int     |
+  |  term_rows         | WC2_TERM_ROWS      | wc2_term_rows      |int     |
+  |  windowborders     | WC2_WINDOWBORDERS  | wc2_windowborders  |int     |
   +--------------------+--------------------+--------------------+--------+
 
 align_message	-- where to place message window (top, bottom, left, right)
@@ -548,6 +551,8 @@ scroll_margin	-- port should scroll the 
 		   is this number of cells away from the edge of the window.
 softkeyboard    -- handhelds should display an on-screen keyboard if possible.
 splash_screen   -- port should/should not display an opening splashscreen.
+term_cols       -- Terminal should size itself to specified width, if possible.
+term_rows       -- Terminal should size itself to specified height, if possible.
 tiled_map	-- port should display a tiled map if it can.
 tile_width	-- port should display tiles with this width or round to closest
 		   if it can.
@@ -558,6 +563,8 @@ tile_file	-- open this alternative tile 
 use_inverse	-- port should display inverse when NetHack asks for it.
 vary_msgcount	-- port should display this number of messages at a time in
 		   the message window.
+windowborders   -- port should display borders around main NetHack windows.
+                   Can be set to (1) on, (2) off, or (3) auto.
 windowcolors
 		-- port should use these colors for window foreground/background
 		   colors.  Syntax:
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/color.h nethack-3.4.3-nao-osx/include/color.h
--- nethack-3.4.3/include/color.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/color.h	2014-12-20 12:08:36.000000000 -0800
@@ -5,6 +5,12 @@
 #ifndef COLOR_H
 #define COLOR_H
 
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+#  include <regex.h>
+# endif
+#endif
+
 /*
  * The color scheme used is tailored for an IBM PC.  It consists of the
  * standard 8 colors, folowed by their bright counterparts.  There are
@@ -49,4 +55,47 @@
 #define DRAGON_SILVER	CLR_BRIGHT_CYAN
 #define HI_ZAP		CLR_BRIGHT_BLUE
 
+#ifdef MENU_COLOR
+struct menucoloring {
+# ifdef MENU_COLOR_REGEX
+#  ifdef MENU_COLOR_REGEX_POSIX
+    regex_t match;
+#  else
+    struct re_pattern_buffer match;
+#  endif
+# else
+    char *match;
+# endif
+    int color, attr;
+    struct menucoloring *next;
+};
+#endif /* MENU_COLOR */
+
+#ifdef STATUS_COLORS
+struct color_option {
+    int color;
+    int attr_bits;
+};
+
+#define STATCLR_TYPE_PERCENT 0
+#define STATCLR_TYPE_NUMBER_LT 1
+#define STATCLR_TYPE_NUMBER_GT 2
+#define STATCLR_TYPE_NUMBER_EQ 3
+
+
+struct percent_color_option {
+    xchar statclrtype;
+    int percentage;
+    struct color_option color_option;
+    const struct percent_color_option *next;
+};
+
+struct text_color_option {
+    const char *text;
+    struct color_option color_option;
+    const struct text_color_option *next;
+};
+#endif
+
+
 #endif /* COLOR_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/config.h nethack-3.4.3-nao-osx/include/config.h
--- nethack-3.4.3/include/config.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/config.h	2014-12-24 10:44:10.000000000 -0800
@@ -43,11 +43,21 @@
  * Some combinations make no sense.  See the installation document.
  */
 #define TTY_GRAPHICS	/* good old tty based graphics */
+#define CURSES_GRAPHICS     /* Proper curses interface */
 /* #define X11_GRAPHICS */	/* X11 interface */
 /* #define QT_GRAPHICS */	/* Qt interface */
 /* #define GNOME_GRAPHICS */	/* Gnome interface */
 /* #define MSWIN_GRAPHICS */	/* Windows NT, CE, Graphics */
 
+#define TTY_TILES_PATCH
+
+#ifdef TTY_TILES_PATCH
+#ifndef USE_TILES
+#define USE_TILES
+#endif
+#endif
+
+
 /*
  * Define the default window system.  This should be one that is compiled
  * into your system (see defines above).  Known window systems are:
@@ -169,11 +179,15 @@
 
 #ifdef UNIX
 /* path and file name extension for compression program */
-#define COMPRESS "/usr/bin/compress"	/* Lempel-Ziv compression */
-#define COMPRESS_EXTENSION ".Z"		/* compress's extension */
+/* #define COMPRESS "/usr/bin/compress" */	/* Lempel-Ziv compression */
+/* #define COMPRESS_EXTENSION ".Z" */		/* compress's extension */
 /* An example of one alternative you might want to use: */
-/* #define COMPRESS "/usr/local/bin/gzip" */	/* FSF gzip compression */
-/* #define COMPRESS_EXTENSION ".gz" */		/* normal gzip extension */
+#define COMPRESS "/bin/gzip"	/* FSF gzip compression */
+#define COMPRESS_EXTENSION ".gz"		/* normal gzip extension */
+#endif
+
+#ifdef __APPLE__
+#define COMPRESS "/usr/bin/compress"
 #endif
 
 #ifndef COMPRESS
@@ -204,7 +218,7 @@
  * otherwise it will be the current directory.
  */
 # ifndef HACKDIR
-#  define HACKDIR "/usr/games/lib/nethackdir"
+#  define HACKDIR "/opt/nethack"
 # endif
 
 /*
@@ -276,6 +290,12 @@ typedef signed char	schar;
 typedef unsigned char	uchar;
 #endif
 
+/* TODO: include inttypes.h or stdint.h and use uint32_t instead of long? */
+typedef long glyph_t;
+
+#define UTF8_GLYPHS	/* Allow UTF8 glyphs for monsters, objects and dungeon */
+/* #define HAVE_SETLOCALE */ /* Query locale, if UTF8 is supported? */
+
 /*
  * Various structures have the option of using bitfields to save space.
  * If your C compiler handles bitfields well (e.g., it can initialize structs
@@ -338,7 +358,7 @@ typedef unsigned char	uchar;
 #endif
 
 #define EXP_ON_BOTL	/* Show experience on bottom line */
-/* #define SCORE_ON_BOTL */	/* added by Gary Erickson (erickson@ucivax) */
+#define SCORE_ON_BOTL	/* added by Gary Erickson (erickson@ucivax) */
 
 /*
  * Section 5:  EXPERIMENTAL STUFF
@@ -348,8 +368,95 @@ typedef unsigned char	uchar;
  * bugs left here.
  */
 
+#if defined(TTY_GRAPHICS) || defined(MSWIN_GRAPHICS)
+# define MENU_COLOR
+# define MENU_COLOR_REGEX
+# define MENU_COLOR_REGEX_POSIX
+/* if MENU_COLOR_REGEX is defined, use regular expressions (regex.h,
+ * GNU specific functions by default, POSIX functions with
+ * MENU_COLOR_REGEX_POSIX).
+ * otherwise use pmatch() to match menu color lines.
+ * pmatch() provides basic globbing: '*' and '?' wildcards.
+ */
+#endif
+
+#define STATUS_COLORS /* Shachaf & Oren Ben-Kiki */
+
+#ifdef TTY_GRAPHICS
+# define WIN_EDGE	/* windows aligned left&top */
+#endif
+
 /*#define GOLDOBJ */	/* Gold is kept on obj chains - Helge Hafting */
-/*#define AUTOPICKUP_EXCEPTIONS */ /* exceptions to autopickup */
+#define AUTOPICKUP_EXCEPTIONS  /* exceptions to autopickup */
+
+#define DUMP_LOG        /* Dump game end information to a file */
+#define DUMP_FN "/tmp/dump.nh"      /* Fixed dumpfile name, if you want
+                                   * to prevent definition by users */
+#define DUMPMSGS 20     /* Number of latest messages in the dump file  */
+
+/* In the following filename definitions, you can use the some string substitutions:
+  %n = player's name
+  %N = first character of player's name
+  %t = character's starting time, in unix epoch format
+*/
+
+/* Filename for the wizard-mode command for dumping the map data.
+   Can be left undefined, in which case the wiz-mode command does nothing. */
+#define MAPDUMP_FN "/tmp/mapdump.nh"
+
+/* Filename for where HUPping a game is saved.
+   Can be left undefined, in which case HUPping doesn't write the data. */
+// #define HUPLIST_FN "/dgldir/userdata/%N/%n/hanguplist.txt"
+
+/* Filename for dgamelaunch extra info field.
+   Can be left undefined for not writing extrainfo. */
+// #define EXTRAINFO_FN "/dgldir/extrainfo-nh343/%n.extrainfo"
+
+#define SHOW_BORN    /* extinct & showborn -patch */
+#define SHOW_EXTINCT
+
+#define SORTLOOT /* sortloot -patch */
+
+#define SIMPLE_MAIL /* dgamelaunch simple mail */
+
+#define PARANOID /* paranoid quit &c */
+
+/* If this file exists, players get a message from the user defined
+   in the file.  The file format is "username:message to be shown" all
+   in one line.  Can be left undefined to disable the feature.
+   Requires UNIX
+*/
+// #define SERVER_ADMIN_MSG "admin_msg"
+
+// #define LIVELOGFILE "livelog"
+
+#define XLOGFILE "xlogfile"  /* even larger logfile */
+/* #define REALTIME_ON_BOTL */  /* Show elapsed time on bottom line.  Note:
+                                 * this breaks savefile compatibility. */
+/* The options in this section require the extended logfile support */
+#ifdef XLOGFILE
+#define RECORD_CONDUCT  /* Record conducts kept in logfile */
+#define RECORD_TURNS    /* Record turns elapsed in logfile */
+#define RECORD_ACHIEVE  /* Record certain notable achievements in the
+                         * logfile.  Note: this breaks savefile compatibility
+                         * due to the addition of the u_achieve struct. */
+#define RECORD_REALTIME /* Record the amount of actual playing time (in
+                         * seconds) in the record file.  Note: this breaks
+                         * savefile compatibility. */
+#define RECORD_START_END_TIME /* Record to-the-second starting and ending
+                               * times; stored as 32-bit values obtained
+                               * from time(2) (seconds since the Epoch.) */
+#define RECORD_GENDER0   /* Record initial gender in logfile */
+#define RECORD_ALIGN0   /* Record initial alignment in logfile */
+#endif
+
+/* Write out player's current location to this file.
+   Can be left undefined, which will disable the feature. */
+// #define WHEREIS_FILE "whereis/%n.whereis"
+
+#define USER_DUNGEONCOLOR
+
+#define BONES_POOL /* Multiple bones files per level */
 
 /* End of Section 5 */
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/decl.h nethack-3.4.3-nao-osx/include/decl.h
--- nethack-3.4.3/include/decl.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/decl.h	2014-12-20 12:08:36.000000000 -0800
@@ -26,7 +26,12 @@ E char SAVEP[];
 
 E NEARDATA int bases[MAXOCLASSES];
 
+E long has_loaded_bones;
+
+E long last_clear_screen;
+
 E NEARDATA int multi;
+E char multi_txt[BUFSZ];
 #if 0
 E NEARDATA int warnlevel;
 #endif
@@ -72,6 +77,10 @@ E struct dgn_topology {		/* special dung
     xchar	d_mines_dnum, d_quest_dnum;
     d_level	d_qstart_level, d_qlocate_level, d_nemesis_level;
     d_level	d_knox_level;
+#ifdef RECORD_ACHIEVE
+    d_level     d_mineend_level;
+    d_level     d_sokoend_level;
+#endif
 } dungeon_topology;
 /* macros for accesing the dungeon levels by their old names */
 #define oracle_level		(dungeon_topology.d_oracle_level)
@@ -104,6 +113,10 @@ E struct dgn_topology {		/* special dung
 #define qlocate_level		(dungeon_topology.d_qlocate_level)
 #define nemesis_level		(dungeon_topology.d_nemesis_level)
 #define knox_level		(dungeon_topology.d_knox_level)
+#ifdef RECORD_ACHIEVE
+#define mineend_level           (dungeon_topology.d_mineend_level)
+#define sokoend_level           (dungeon_topology.d_sokoend_level)
+#endif
 
 E NEARDATA stairway dnstair, upstair;		/* stairs up and down */
 #define xdnstair	(dnstair.sx)
@@ -184,6 +197,12 @@ E const char *delayed_killer;
 E long done_money;
 #endif
 E char killer_buf[BUFSZ];
+
+E long killer_flags;
+
+#ifdef DUMP_LOG
+E char dump_fn[];		/* dumpfile name (dump patch) */
+#endif
 E const char *configfile;
 E NEARDATA char plname[PL_NSIZ];
 E NEARDATA char dogname[];
@@ -197,6 +216,25 @@ E char lock[];
 
 E const char sdir[], ndir[];
 E const schar xdir[], ydir[], zdir[];
+E char misc_cmds[];
+
+#define DORUSH			misc_cmds[0]
+#define DORUN			misc_cmds[1]
+#define DOFORCEFIGHT		misc_cmds[2]
+#define DONOPICKUP		misc_cmds[3]
+#define DORUN_NOPICKUP		misc_cmds[4]
+#define DOESCAPE		misc_cmds[5]
+#ifdef REDO			/* JDS: moved from config.h */
+# undef  DOAGAIN /* remove previous definition from config.h */
+# define DOAGAIN		misc_cmds[6]
+#endif
+
+/* the number of miscellaneous commands */
+#ifdef REDO
+# define MISC_CMD_COUNT		7
+#else
+# define MISC_CMD_COUNT		6
+#endif
 
 E NEARDATA schar tbx, tby;		/* set in mthrowu.c */
 
@@ -380,11 +418,77 @@ E char *fqn_prefix_names[PREFIX_COUNT];
 #ifdef AUTOPICKUP_EXCEPTIONS
 struct autopickup_exception {
 	char *pattern;
+	regex_t match;
 	boolean grab;
+	boolean is_regexp;
 	struct autopickup_exception *next;
 };
 #endif /* AUTOPICKUP_EXCEPTIONS */
 
+#ifdef RECORD_ACHIEVE
+struct u_achieve {
+        Bitfield(get_bell,1);        /* You have obtained the bell of 
+                                      * opening */
+        Bitfield(get_candelabrum,1); /* You have obtained the candelabrum */
+        Bitfield(get_book,1);        /* You have obtained the book of 
+                                      * the dead */
+        Bitfield(enter_gehennom,1);  /* Entered Gehennom (including the 
+                                      * Valley) by any means */
+        Bitfield(perform_invocation,1); /* You have performed the invocation
+                                         * ritual */
+        Bitfield(get_amulet,1);      /* You have obtained the amulet
+                                      * of Yendor */
+        Bitfield(ascended,1);        /* You ascended to demigod[dess]hood.
+                                      * Not quite the same as 
+                                      * u.uevent.ascended. */
+        Bitfield(get_luckstone,1);   /* You obtained the luckstone at the
+                                      * end of the mines. */
+        Bitfield(finish_sokoban,1);  /* You obtained the sokoban prize. */
+        Bitfield(killed_medusa,1);   /* You defeated Medusa. */
+};
+
+E struct u_achieve achieve;
+#endif
+
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+E struct realtime_data {
+  time_t realtime;    /* Amount of actual playing time up until the last time
+                       * the game was restored. */
+  time_t restoretime; /* The time that the game was started or restored. */
+  time_t last_displayed_time; /* Last time displayed on the status line */
+} realtime_data;
+#endif /* RECORD_REALTIME || REALTIME_ON_BOTL */
+
+
+#ifdef SIMPLE_MAIL
+E int mailckfreq;
+#endif
+
+
+struct _plinemsg {
+    xchar msgtype;
+    char *pattern;
+    regex_t match;
+    boolean is_regexp;
+    struct _plinemsg *next;
+};
+
+E struct _plinemsg *pline_msg;
+
+#define MSGTYP_NORMAL  0
+#define MSGTYP_NOREP   1
+#define MSGTYP_NOSHOW  2
+#define MSGTYP_STOP    3
+
+
+/* FIXME: These should be integrated into objclass and permonst structs,
+   but that invalidates saves */
+E glyph_t objclass_unicode_codepoint[NUM_OBJECTS];
+E glyph_t permonst_unicode_codepoint[NUMMONS];
+
+
+E boolean curses_stupid_hack;
+
 #undef E
 
 #endif /* DECL_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/dungeon.h nethack-3.4.3-nao-osx/include/dungeon.h
--- nethack-3.4.3/include/dungeon.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/dungeon.h	2014-12-20 12:08:36.000000000 -0800
@@ -121,8 +121,13 @@ typedef struct branch {
 #define Is_qlocate(x)		(on_level(x, &qlocate_level))
 #define Is_nemesis(x)		(on_level(x, &nemesis_level))
 #define Is_knox(x)		(on_level(x, &knox_level))
+#ifdef RECORD_ACHIEVE
+#define Is_mineend_level(x)     (on_level(x, &mineend_level))
+#define Is_sokoend_level(x)     (on_level(x, &sokoend_level))
+#endif
 
 #define In_sokoban(x)		((x)->dnum == sokoban_dnum)
+#define In_tower(x)		((x)->dnum == tower_dnum)
 #define Inhell			In_hell(&u.uz)	/* now gehennom */
 #define In_endgame(x)		((x)->dnum == astral_level.dnum)
 
@@ -150,6 +155,7 @@ struct linfo {
 #define VISITED		0x01	/* hero has visited this level */
 #define FORGOTTEN	0x02	/* hero will forget this level when reached */
 #define LFILE_EXISTS	0x04	/* a level file exists for this level */
+#define HANGUP_HERE     0x40    /* AIS: there was a hangup on this level */
 /*
  * Note:  VISITED and LFILE_EXISTS are currently almost always set at the
  * same time.  However they _mean_ different things.
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/extern.h nethack-3.4.3-nao-osx/include/extern.h
--- nethack-3.4.3/include/extern.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/extern.h	2014-12-20 12:08:36.000000000 -0800
@@ -25,6 +25,9 @@ E void NDECL(stop_occupation);
 E void NDECL(display_gamewindows);
 E void NDECL(newgame);
 E void FDECL(welcome, (BOOLEAN_P));
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+E time_t NDECL(get_realtime);
+#endif
 
 /* ### apply.c ### */
 
@@ -63,7 +66,7 @@ E int NDECL(nartifact_exist);
 E boolean FDECL(spec_ability, (struct obj *,unsigned long));
 E boolean FDECL(confers_luck, (struct obj *));
 E boolean FDECL(arti_reflects, (struct obj *));
-E boolean FDECL(restrict_name, (struct obj *,const char *));
+E boolean FDECL(restrict_name, (struct obj *,const char *,BOOLEAN_P));
 E boolean FDECL(defends, (int,struct obj *));
 E boolean FDECL(protects, (int,struct obj *));
 E void FDECL(set_artifact_intrinsic, (struct obj *,BOOLEAN_P,long));
@@ -101,6 +104,8 @@ E int NDECL(newhp);
 E schar FDECL(acurr, (int));
 E schar NDECL(acurrstr);
 E void FDECL(adjalign, (int));
+E int NDECL(uhp);
+E int NDECL(uhpmax);
 
 /* ### ball.c ### */
 
@@ -122,6 +127,7 @@ E int NDECL(getbones);
 
 /* ### botl.c ### */
 
+E int NDECL(force_bot);
 E int FDECL(xlev_to_rank, (int));
 E int FDECL(title_to_mon, (const char *,int *,int *));
 E void NDECL(max_rank_sz);
@@ -131,6 +137,10 @@ E long NDECL(botl_score);
 E int FDECL(describe_level, (char *));
 E const char *FDECL(rank_of, (int,SHORT_P,BOOLEAN_P));
 E void NDECL(bot);
+#ifdef DUMP_LOG
+E void FDECL(bot1str, (char *));
+E void FDECL(bot2str, (char *));
+#endif
 
 /* ### cmd.c ### */
 
@@ -158,14 +168,16 @@ E char NDECL(pgetchar);
 E void FDECL(pushch, (CHAR_P));
 E void FDECL(savech, (CHAR_P));
 #endif
-#ifdef WIZARD
-E void NDECL(add_debug_extended_commands);
-#endif /* WIZARD */
 E void FDECL(rhack, (char *));
+E void NDECL(dokeylist);
 E int NDECL(doextlist);
 E int NDECL(extcmd_via_menu);
 E void FDECL(enlightenment, (int));
 E void FDECL(show_conduct, (int));
+#ifdef DUMP_LOG
+E void FDECL(dump_enlightenment, (int));
+E void FDECL(dump_conduct, (int));
+#endif
 E int FDECL(xytod, (SCHAR_P,SCHAR_P));
 E void FDECL(dtoxy, (coord *,int));
 E int FDECL(movecmd, (CHAR_P));
@@ -178,6 +190,13 @@ E char NDECL(readchar);
 #ifdef WIZARD
 E void NDECL(sanity_check);
 #endif
+E void NDECL(commands_init);
+E char* FDECL(stripspace, (char*));
+E void FDECL(parsebindings, (char*));
+E void FDECL(parseautocomplete, (char*,boolean));
+E char FDECL(txt2key, (char*));
+E char* FDECL(key2txt, (char, char*));
+E char* FDECL(str2txt, (char*, char*));
 E char FDECL(yn_function, (const char *, const char *, CHAR_P));
 
 /* ### dbridge.c ### */
@@ -281,6 +300,9 @@ E void NDECL(clear_glyph_buffer);
 E void FDECL(row_refresh, (int,int,int));
 E void NDECL(cls);
 E void FDECL(flush_screen, (int));
+#ifdef DUMP_LOG
+E void FDECL(dump_screen, (int));
+#endif
 E int FDECL(back_to_glyph, (XCHAR_P,XCHAR_P));
 E int FDECL(zapdir_to_glyph, (int,int,int));
 E int FDECL(glyph_at, (XCHAR_P,XCHAR_P));
@@ -319,6 +341,7 @@ E void NDECL(heal_legs);
 
 /* ### do_name.c ### */
 
+E void FDECL(do_oname, (struct obj *));
 E int FDECL(getpos, (coord *,BOOLEAN_P,const char *));
 E struct monst *FDECL(christen_monst, (struct monst *,const char *));
 E int NDECL(do_mname);
@@ -452,11 +475,15 @@ E boolean FDECL(hurtle_step, (genericptr
 E int FDECL(def_char_to_objclass, (CHAR_P));
 E int FDECL(def_char_to_monclass, (CHAR_P));
 #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
-E void FDECL(assign_graphics, (uchar *,int,int,int));
+E void FDECL(assign_graphics, (glyph_t *,int,int,int));
 E void FDECL(switch_graphics, (int));
 #ifdef REINCARNATION
 E void FDECL(assign_rogue_graphics, (BOOLEAN_P));
 #endif
+E void FDECL(assign_utf8graphics_symbol, (int, glyph_t));
+#ifdef USER_DUNGEONCOLOR
+E void FDECL(assign_colors, (uchar *,int,int,int));
+#endif
 
 /* ### dungeon.c ### */
 
@@ -542,6 +569,9 @@ E boolean FDECL(maybe_finished_meal, (BO
 
 /* ### end.c ### */
 
+E void FDECL(mk_mapdump, (char *));
+E void NDECL(mk_dgl_extrainfo);
+E char *FDECL(dump_format_str, (char *));
 E void FDECL(done1, (int));
 E int NDECL(done2);
 #ifdef USE_TRAMPOLI
@@ -553,6 +583,10 @@ E void VDECL(panic, (const char *,...)) 
 #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
 E void FDECL(done, (int));
 E void FDECL(container_contents, (struct obj *,BOOLEAN_P,BOOLEAN_P));
+#ifdef DUMP_LOG
+E void FDECL(dump, (char *, char *));
+E void FDECL(do_containerconts, (struct obj *,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
+#endif
 E void FDECL(terminate, (int));
 E int NDECL(num_genocides);
 
@@ -660,6 +694,11 @@ E boolean NDECL(recover_savefile);
 #ifdef HOLD_LOCKFILE_OPEN
 E void NDECL(really_close);
 #endif
+#ifdef WHEREIS_FILE
+E void NDECL(touch_whereis);
+E void NDECL(delete_whereis);
+#endif
+E void FDECL(livelog_write_string, (char *));
 
 /* ### fountain.c ### */
 
@@ -694,7 +733,7 @@ E void FDECL(check_special_room, (BOOLEA
 E int NDECL(dopickup);
 E void NDECL(lookaround);
 E int NDECL(monster_nearby);
-E void FDECL(nomul, (int));
+E void FDECL(nomul, (int, const char *));
 E void FDECL(unmul, (const char *));
 E void FDECL(losehp, (int,const char *,BOOLEAN_P));
 E int NDECL(weight_cap);
@@ -718,6 +757,7 @@ E char *FDECL(lcase, (char *));
 E char *FDECL(upstart, (char *));
 E char *FDECL(mungspaces, (char *));
 E char *FDECL(eos, (char *));
+E void FDECL(sanitizestr, (char *));
 E char *FDECL(strkitten, (char *,CHAR_P));
 E char *FDECL(s_suffix, (const char *));
 E char *FDECL(xcrypt, (const char *,char *));
@@ -790,6 +830,9 @@ E void FDECL(prinv, (const char *,struct
 E char *FDECL(xprname, (struct obj *,const char *,CHAR_P,BOOLEAN_P,long,long));
 E int NDECL(ddoinv);
 E char FDECL(display_inventory, (const char *,BOOLEAN_P));
+#ifdef DUMP_LOG
+E char FDECL(dump_inventory, (const char *,BOOLEAN_P,BOOLEAN_P));
+#endif
 E int FDECL(display_binventory, (int,int,BOOLEAN_P));
 E struct obj *FDECL(display_cinventory,(struct obj *));
 E struct obj *FDECL(display_minventory,(struct monst *,int,char *));
@@ -808,7 +851,7 @@ E int NDECL(dopramulet);
 E int NDECL(doprtool);
 E int NDECL(doprinuse);
 E void FDECL(useupf, (struct obj *,long));
-E char *FDECL(let_to_name, (CHAR_P,BOOLEAN_P));
+E char *FDECL(let_to_name, (CHAR_P,BOOLEAN_P,BOOLEAN_P));
 E void NDECL(free_invbuf);
 E void NDECL(reassign);
 E int NDECL(doorganize);
@@ -817,6 +860,10 @@ E int FDECL(count_buc, (struct obj *,int
 E void FDECL(carry_obj_effects, (struct obj *));
 E const char *FDECL(currency, (long));
 E void FDECL(silly_thing, (const char *,struct obj *));
+E struct obj *NDECL(getnextgetobj);
+#ifdef SORTLOOT
+E int FDECL(sortloot_cmp, (struct obj *, struct obj *));
+#endif
 
 /* ### ioctl.c ### */
 
@@ -908,6 +955,7 @@ E void FDECL(nocmov, (int x, int y));
 
 /* ### mail.c ### */
 
+E void NDECL(server_admin_msg);
 #ifdef MAIL
 # ifdef UNIX
 E void NDECL(getmailstatus);
@@ -942,7 +990,7 @@ E boolean FDECL(propagate, (int, BOOLEAN
 
 /* ### mapglyph.c ### */
 
-E void FDECL(mapglyph, (int, int *, int *, unsigned *, int, int));
+E void FDECL(mapglyph, (int, glyph_t *, int *, unsigned *, int, int));
 
 /* ### mcastu.c ### */
 
@@ -1357,9 +1405,13 @@ E char *FDECL(xname, (struct obj *));
 E char *FDECL(mshot_xname, (struct obj *));
 E boolean FDECL(the_unique_obj, (struct obj *obj));
 E char *FDECL(doname, (struct obj *));
+E char *FDECL(doname_with_price, (struct obj *));
 E boolean FDECL(not_fully_identified, (struct obj *));
 E char *FDECL(corpse_xname, (struct obj *,BOOLEAN_P));
 E char *FDECL(cxname, (struct obj *));
+#ifdef SORTLOOT
+E char *FDECL(cxname2, (struct obj *));
+#endif
 E char *FDECL(killer_xname, (struct obj *));
 E const char *FDECL(singular, (struct obj *,char *(*)(OBJ_P)));
 E char *FDECL(an, (const char *));
@@ -1405,6 +1457,11 @@ E void FDECL(set_option_mod_status, (con
 E int FDECL(add_autopickup_exception, (const char *));
 E void NDECL(free_autopickup_exceptions);
 #endif /* AUTOPICKUP_EXCEPTIONS */
+#ifdef MENU_COLOR
+E boolean FDECL(add_menu_coloring, (char *));
+#endif /* MENU_COLOR */
+E boolean FDECL(parse_monster_color, (char *));
+E int FDECL(parse_codepoint, (char *));
 
 /* ### pager.c ### */
 
@@ -1415,6 +1472,7 @@ E int NDECL(dowhatdoes);
 E char *FDECL(dowhatdoes_core,(CHAR_P, char *));
 E int NDECL(dohelp);
 E int NDECL(dohistory);
+E void FDECL(checkfile, (char *,struct permonst *,BOOLEAN_P,BOOLEAN_P));
 
 /* ### pcmain.c ### */
 
@@ -1500,6 +1558,8 @@ E boolean FDECL(is_autopickup_exception,
 
 /* ### pline.c ### */
 
+E void FDECL(msgpline_add, (int, char *));
+E void NDECL(msgpline_free);
 E void VDECL(pline, (const char *,...)) PRINTF_F(1,2);
 E void VDECL(Norep, (const char *,...)) PRINTF_F(1,2);
 E void NDECL(free_youbuf);
@@ -1698,6 +1758,7 @@ E void FDECL(genl_outrip, (winid,int));
 
 /* ### rnd.c ### */
 
+E void NDECL(check_reseed);
 E int FDECL(rn2, (int));
 E int FDECL(rnl, (int));
 E int FDECL(rnd, (int));
@@ -1796,6 +1857,7 @@ E void FDECL(home_shk, (struct monst *,B
 E void FDECL(make_happy_shk, (struct monst *,BOOLEAN_P));
 E void FDECL(hot_pursuit, (struct monst *));
 E void FDECL(make_angry_shk, (struct monst *,XCHAR_P,XCHAR_P));
+E long FDECL(get_cost_of_shop_item, (struct obj *));
 E int NDECL(dopay);
 E boolean FDECL(paybill, (int));
 E void NDECL(finish_paybill);
@@ -1985,9 +2047,13 @@ E void NDECL(timer_sanity_check);
 
 /* ### topten.c ### */
 
+#ifdef RECORD_CONDUCT
+E long FDECL(encodeconduct, (void));
+#endif
 E void FDECL(topten, (int));
 E void FDECL(prscore, (int,char **));
 E struct obj *FDECL(tt_oname, (struct obj *));
+E void NDECL(write_HUP_file);
 
 /* ### track.c ### */
 
@@ -2016,7 +2082,7 @@ E void NDECL(float_up);
 E void FDECL(fill_pit, (int,int));
 E int FDECL(float_down, (long, long));
 E int FDECL(fire_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P,XCHAR_P,XCHAR_P));
-E void FDECL(water_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P));
+E boolean FDECL(water_damage, (struct obj *,BOOLEAN_P,BOOLEAN_P));
 E boolean NDECL(drown);
 E void FDECL(drain_en, (int));
 E int NDECL(dountrap);
@@ -2237,6 +2303,9 @@ E int FDECL(mon_wield_item, (struct mons
 E int NDECL(abon);
 E int NDECL(dbon);
 E int NDECL(enhance_weapon_skill);
+#ifdef DUMP_LOG
+E void NDECL(dump_weapon_skill);
+#endif
 E void FDECL(unrestrict_weapon_skill, (int));
 E void FDECL(use_skill, (int,int));
 E void FDECL(add_weapon_skill, (int));
@@ -2367,7 +2436,7 @@ E const char *FDECL(exclam, (int force))
 E void FDECL(hit, (const char *,struct monst *,const char *));
 E void FDECL(miss, (const char *,struct monst *));
 E struct monst *FDECL(bhit, (int,int,int,int,int (*)(MONST_P,OBJ_P),
-			     int (*)(OBJ_P,OBJ_P),struct obj *));
+			     int (*)(OBJ_P,OBJ_P),struct obj *, boolean *));
 E struct monst *FDECL(boomhit, (int,int));
 E int FDECL(burn_floor_paper, (int,int,BOOLEAN_P,BOOLEAN_P));
 E void FDECL(buzz, (int,int,XCHAR_P,XCHAR_P,int,int));
@@ -2382,6 +2451,10 @@ E void NDECL(makewish);
 
 #endif /* !MAKEDEFS_C && !LEV_LEX_C */
 
+/* ### unicode.c ### */
+E glyph_t FDECL(get_unicode_codepoint, (int));
+E int FDECL(pututf8char, (glyph_t));
+
 #undef E
 
 #endif /* EXTERN_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/flag.h nethack-3.4.3-nao-osx/include/flag.h
--- nethack-3.4.3/include/flag.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/flag.h	2014-12-20 12:08:36.000000000 -0800
@@ -156,9 +156,13 @@ struct flag {
 
 struct instance_flags {
 	boolean  cbreak;	/* in cbreak mode, rogue format */
+#ifdef CURSES_GRAPHICS
+    boolean  cursesgraphics;    /* Use portable curses extended characters */
+#endif
 	boolean  DECgraphics;	/* use DEC VT-xxx extended character set */
 	boolean  echo;		/* 1 to echo characters */
 	boolean  IBMgraphics;	/* use IBM extended character set */
+	boolean  UTF8graphics;	/* use UTF-8 characters */
 	unsigned msg_history;	/* hint: # of top lines to save */
 	boolean  num_pad;	/* use numbers for movement commands */
 	boolean  news;		/* print news */
@@ -168,6 +172,9 @@ struct instance_flags {
 	boolean  menu_requested; /* Flag for overloaded use of 'm' prefix
 				  * on some non-move commands */
 	uchar num_pad_mode;
+
+    int bones;
+
 	int	menu_headings;	/* ATR for menu headings */
 	int      purge_monsters;	/* # of dead monsters still on fmon list */
 	int *opt_booldup;	/* for duplication of boolean opts in config file */
@@ -175,14 +182,29 @@ struct instance_flags {
 	uchar	bouldersym;	/* symbol for boulder display */
 	boolean travel1;	/* first travel step */
 	coord	travelcc;	/* coordinates for travel_cache */
+#ifdef SIMPLE_MAIL
+	boolean simplemail;	/* simple mail format $NAME:$MESSAGE */
+#endif
 #ifdef WIZARD
 	boolean  sanity_check;	/* run sanity checks */
 	boolean  mon_polycontrol;	/* debug: control monster polymorphs */
 #endif
 #ifdef TTY_GRAPHICS
 	char prevmsg_window;	/* type of old message window to use */
+#endif
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
 	boolean  extmenu;	/* extended commands use menu interface */
 #endif
+#ifdef MENU_COLOR
+	boolean use_menu_color;	/* use color in menus; only if wc_color */
+#endif
+#ifdef WIN_EDGE
+	boolean  win_edge;	/* are the menus aligned left&top */
+#endif
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+    boolean use_status_colors; /* use color in status line; only if wc_color */
+#endif
+    boolean hitpointbar;
 #ifdef MFLOPPY
 	boolean  checkspace;	/* check disk space before writing files */
 				/* (in iflags to allow restore after moving
@@ -216,6 +238,30 @@ struct instance_flags {
 	boolean lan_mail;	/* mail is initialized */
 	boolean lan_mail_fetched; /* mail is awaiting display */
 #endif
+#ifdef SHOW_BORN
+	boolean show_born;	/* show numbers of created monsters */
+#endif
+#ifdef SORTLOOT
+	char sortloot;          /* sort items to loot alphabetically */
+#endif
+#ifdef PARANOID
+	boolean  paranoid_hit;  /* Ask for 'yes' when hitting peacefuls */
+	boolean  paranoid_quit; /* Ask for 'yes' when quitting */
+	boolean  paranoid_remove; /* Always show menu for 'T' and 'R' */
+#endif
+#ifdef USE_TILES
+	boolean  vt_nethack;
+#endif
+	boolean  quiver_fired;
+       boolean  pickup_thrown;
+    boolean msgtype_regex;
+    boolean ape_regex;
+    boolean show_shop_prices;
+    boolean item_use_menu;
+    boolean notice_walls;
+    boolean use_menu_glyphs;
+    boolean hilite_hidden_stairs;
+    boolean hilite_obj_piles;
 /*
  * Window capability support.
  */
@@ -263,7 +309,20 @@ struct instance_flags {
 	boolean wc2_fullscreen;		/* run fullscreen */
 	boolean wc2_softkeyboard;	/* use software keyboard */
 	boolean wc2_wraptext;		/* wrap text */
-
+    int     wc2_term_cols;      /* terminal width, in characters */
+    int     wc2_term_rows;      /* terminal height, in characters */
+    int     wc2_windowborders;  /* display borders on NetHack windows */
+    int     wc2_petattr;        /* points to text attributes for pet */
+    boolean wc2_guicolor;       /* allow colors in GUI (outside map) */
+	boolean wc2_darkgray;		/* try to use PC dark-gray color
+					 * to represent black object */
+
+  boolean botl_updates;
+  boolean hp_notify;
+  char *hp_notify_fmt;
+  boolean old_C_behaviour;
+        boolean show_buc;
+	boolean show_obj_sym;
 	boolean  cmdassist;	/* provide detailed assistance for some commands */
 	boolean	 obsolete;	/* obsolete options can point at this, it isn't used */
 	/* Items which belong in flags, but are here to allow save compatibility */
@@ -280,6 +339,9 @@ struct instance_flags {
 #define MAX_ALTKEYHANDLER 25
 	char	 altkeyhandler[MAX_ALTKEYHANDLER];
 #endif
+#ifdef REALTIME_ON_BOTL
+  boolean  showrealtime; /* show actual elapsed time */
+#endif
 };
 
 /*
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/func_tab.h nethack-3.4.3-nao-osx/include/func_tab.h
--- nethack-3.4.3/include/func_tab.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/func_tab.h	2014-12-20 12:08:36.000000000 -0800
@@ -5,17 +5,27 @@
 #ifndef FUNC_TAB_H
 #define FUNC_TAB_H
 
-struct func_tab {
-	char f_char;
-	boolean can_if_buried;
-	int NDECL((*f_funct));
-	const char *f_text;
-};
-
 struct ext_func_tab {
 	const char *ef_txt, *ef_desc;
 	int NDECL((*ef_funct));
 	boolean can_if_buried;
+	boolean autocomplete;
+
+  	/* for interrupted repeats; e.g.,
+	 * "searching" => "You stop searching." */
+	const char *f_text;
+};
+
+/* Tells what extended command to do on a command key press */
+struct key_tab {
+	struct ext_func_tab * bind_cmd;
+};
+
+/* Linked list of bindings; see "crappy hack" in cmd.c */
+struct binding_list_tab {
+	char key;	/* ascii code for key */
+	char* extcmd;	/* extended command key is going to be rebound to */
+	struct binding_list_tab * next;
 };
 
 extern struct ext_func_tab extcmdlist[];
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/global.h nethack-3.4.3-nao-osx/include/global.h
--- nethack-3.4.3/include/global.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/global.h	2014-12-20 12:08:36.000000000 -0800
@@ -317,6 +317,20 @@ struct version_info {
 #define COLNO	80
 #define ROWNO	21
 
+/* MAXCO must hold longest uncompressed status line, and must be larger
+ * than COLNO
+ *
+ * longest practical second status line at the moment is
+ *	Astral Plane $:12345 HP:700(700) Pw:111(111) AC:-127 Xp:30/123456789
+ *	T:123456 Satiated Conf FoodPois Ill Blind Stun Hallu Overloaded
+ * -- or somewhat over 130 characters
+ */
+#if COLNO <= 140
+#define MAXCO 160
+#else
+#define MAXCO (COLNO+20)
+#endif
+
 #define MAXNROFROOMS	40	/* max number of rooms per level */
 #define MAX_SUBROOMS	24	/* max # of subrooms in a given room */
 #define DOORMAX		120	/* max number of doors per level */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/hack.h nethack-3.4.3-nao-osx/include/hack.h
--- nethack-3.4.3/include/hack.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/hack.h	2014-12-20 12:08:36.000000000 -0800
@@ -53,6 +53,8 @@
 #define MG_DETECT	0x04
 #define MG_PET		0x08
 #define MG_RIDDEN	0x10
+#define MG_STAIRS	0x20
+#define MG_OBJPILE	0x40
 
 /* sellobj_state() states */
 #define SELL_NORMAL	(0)
@@ -155,6 +157,7 @@ NEARDATA extern coord bhitpos;	/* place 
 #define INVORDER_SORT	  0x8	/* sort objects by packorder */
 #define SIGNAL_NOMENU	  0x10	/* return -1 rather than 0 if none allowed */
 #define FEEL_COCKATRICE   0x20  /* engage cockatrice checks and react */
+#define SIGNAL_ESCAPE	  0x40  /* return -2 if menu was escaped */
 
 /* Flags to control query_category() */
 /* BY_NEXTHERE used by query_category() too, so skip 0x01 */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/obj.h nethack-3.4.3-nao-osx/include/obj.h
--- nethack-3.4.3/include/obj.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/obj.h	2014-12-20 12:08:36.000000000 -0800
@@ -91,12 +91,18 @@ struct obj {
 
 	Bitfield(in_use,1);	/* for magic items before useup items */
 	Bitfield(bypass,1);	/* mark this as an object to be skipped by bhito() */
-	/* 6 free bits */
+       Bitfield(was_thrown,1); /* for pickup_thrown */
+       /* 5 free bits */
 
 	int	corpsenm;	/* type of corpse is mons[corpsenm] */
 #define leashmon  corpsenm	/* gets m_id of attached pet */
 #define spestudied corpsenm	/* # of times a spellbook has been studied */
 #define fromsink  corpsenm	/* a potion from a sink */
+
+#ifdef RECORD_ACHIEVE
+#define record_achieve_special corpsenm
+#endif
+
 	unsigned oeaten;	/* nutrition left in food, if partly eaten */
 	long age;		/* creation date */
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/rm.h nethack-3.4.3-nao-osx/include/rm.h
--- nethack-3.4.3/include/rm.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/rm.h	2014-12-20 12:08:36.000000000 -0800
@@ -224,8 +224,11 @@ struct symdef {
 };
 
 extern const struct symdef defsyms[MAXPCHARS];	/* defaults */
-extern uchar showsyms[MAXPCHARS];
+extern glyph_t showsyms[MAXPCHARS];
 extern const struct symdef def_warnsyms[WARNCOUNT];
+#ifdef USER_DUNGEONCOLOR
+extern uchar showsymcolors[MAXPCHARS];
+#endif
 
 /*
  * Graphics sets for display symbols
@@ -234,6 +237,8 @@ extern const struct symdef def_warnsyms[
 #define IBM_GRAPHICS	1	/* PC graphic characters */
 #define DEC_GRAPHICS	2	/* VT100 line drawing characters */
 #define MAC_GRAPHICS	3	/* Macintosh drawing characters */
+#define CURS_GRAPHICS	4	/* Portable curses drawing characters */
+#define UTF8_GRAPHICS	5	/* UTF8 characters */
 
 /*
  * The 5 possible states of doors
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/system.h nethack-3.4.3-nao-osx/include/system.h
--- nethack-3.4.3/include/system.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/system.h	2014-12-20 12:53:39.000000000 -0800
@@ -79,10 +79,10 @@ typedef long	off_t;
 # if !defined(__SC__) && !defined(LINUX)
 E  long NDECL(random);
 # endif
-# if (!defined(SUNOS4) && !defined(bsdi) && !defined(__FreeBSD__)) || defined(RANDOM)
+# if (!defined(SUNOS4) && !defined(bsdi) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(__DragonFly__) && !defined(__APPLE__)) || defined(RANDOM)
 E void FDECL(srandom, (unsigned int));
 # else
-#  if !defined(bsdi) && !defined(__FreeBSD__)
+#  if !defined(bsdi) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(__DragonFly__) && !defined(__APPLE__)
 E int FDECL(srandom, (unsigned int));
 #  endif
 # endif
@@ -132,7 +132,7 @@ E void FDECL(perror, (const char *));
 E void FDECL(qsort, (genericptr_t,size_t,size_t,
 		     int(*)(const genericptr,const genericptr)));
 #else
-# if defined(BSD) || defined(ULTRIX)
+# if defined(BSD) || defined(ULTRIX) && !defined(__NetBSD__)
 E  int qsort();
 # else
 #  if !defined(LATTICE) && !defined(AZTEC_50)
@@ -421,7 +421,7 @@ E size_t FDECL(strlen, (const char *));
 # ifdef HPUX
 E unsigned int	FDECL(strlen, (char *));
 #  else
-#   if !(defined(ULTRIX_PROTO) && defined(__GNUC__))
+#   if !(defined(ULTRIX_PROTO) && defined(__GNUC__)) && !defined(__NetBSD__)
 E int	FDECL(strlen, (const char *));
 #   endif
 #  endif /* HPUX */
@@ -476,9 +476,9 @@ E  char *sprintf();
 #  if !defined(SVR4) && !defined(apollo)
 #   if !(defined(ULTRIX_PROTO) && defined(__GNUC__))
 #    if !(defined(SUNOS4) && defined(__STDC__)) /* Solaris unbundled cc (acc) */
-E int FDECL(vsprintf, (char *, const char *, va_list));
-E int FDECL(vfprintf, (FILE *, const char *, va_list));
-E int FDECL(vprintf, (const char *, va_list));
+// E int FDECL(vsprintf, (char *, const char *, va_list));
+// E int FDECL(vfprintf, (FILE *, const char *, va_list));
+// E int FDECL(vprintf, (const char *, va_list));
 #    endif
 #   endif
 #  endif
@@ -521,7 +521,7 @@ E struct tm *FDECL(localtime, (const tim
 #  endif
 # endif
 
-# if defined(ULTRIX) || (defined(BSD) && defined(POSIX_TYPES)) || defined(SYSV) || defined(MICRO) || defined(VMS) || defined(MAC) || (defined(HPUX) && defined(_POSIX_SOURCE))
+# if defined(ULTRIX) || (defined(BSD) && defined(POSIX_TYPES)) || defined(SYSV) || defined(MICRO) || defined(VMS) || defined(MAC) || (defined(HPUX) && defined(_POSIX_SOURCE)) || defined(__NetBSD__)
 E time_t FDECL(time, (time_t *));
 # else
 E long FDECL(time, (time_t *));
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/unixconf.h nethack-3.4.3-nao-osx/include/unixconf.h
--- nethack-3.4.3/include/unixconf.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/unixconf.h	2014-12-24 10:44:10.000000000 -0800
@@ -19,25 +19,25 @@
  */
 
 /* define exactly one of the following four choices */
-/* #define BSD 1 */	/* define for 4.n/Free/Open/Net BSD  */
+#define BSD 1 	/* define for 4.n/Free/Open/Net BSD  */
 			/* also for relatives like SunOS 4.x, DG/UX, and */
 			/* older versions of Linux */
 /* #define ULTRIX */	/* define for Ultrix v3.0 or higher (but not lower) */
 			/* Use BSD for < v3.0 */
 			/* "ULTRIX" not to be confused with "ultrix" */
-#define SYSV		/* define for System V, Solaris 2.x, newer versions */
+/* #define SYSV		/* define for System V, Solaris 2.x, newer versions */
 			/* of Linux */
 /* #define HPUX */	/* Hewlett-Packard's Unix, version 6.5 or higher */
 			/* use SYSV for < v6.5 */
 
 
 /* define any of the following that are appropriate */
-#define SVR4		/* use in addition to SYSV for System V Release 4 */
+/*#define SVR4*/		/* use in addition to SYSV for System V Release 4 */
 			/* including Solaris 2+ */
 #define NETWORK		/* if running on a networked system */
 			/* e.g. Suns sharing a playground through NFS */
 /* #define SUNOS4 */	/* SunOS 4.x */
-/* #define LINUX */	/* Another Unix clone */
+#define LINUX	/* Another Unix clone */
 /* #define CYGWIN32 */	/* Unix on Win32 -- use with case sensitive defines */
 /* #define GENIX */	/* Yet Another Unix Clone */
 /* #define HISX */	/* Bull Unix for XPS Machines */
@@ -102,7 +102,7 @@
  * If you want the static parts of your playground on a read-only file
  * system, define VAR_PLAYGROUND to be where the variable parts are kept.
  */
-/* #define VAR_PLAYGROUND "/var/lib/games/nethack" */
+#define VAR_PLAYGROUND "/opt/nethack/var"
 
 
 /*
@@ -132,7 +132,7 @@
  * "extra output" method is used, but not all systems provide access to
  * a fine-grained timer.
  */
-/* #define TIMED_DELAY */	/* usleep() */
+#define TIMED_DELAY	/* usleep() */
 #endif
 
 /*
@@ -193,7 +193,7 @@
 # endif
 #endif
 
-#define MAILCKFREQ	50
+/* #define MAILCKFREQ	50 */
 #endif	/* MAIL */
 
 
@@ -209,6 +209,12 @@
 
 #define FCMASK	0660	/* file creation mask */
 
+/* fcntl(2) is a POSIX-portable call for manipulating file descriptors.
+ * Comment out the USE_FCNTL if for some reason you have a strange
+ * os/filesystem combination for which fcntl(2) does not work. */
+#ifdef POSIX_TYPES
+# define USE_FCNTL
+#endif
 
 /*
  * The remainder of the file should not need to be changed.
@@ -285,8 +291,8 @@
 
 #if defined(BSD) || defined(ULTRIX)
 # if !defined(DGUX) && !defined(SUNOS4)
-#define memcpy(d, s, n)		bcopy(s, d, n)
-#define memcmp(s1, s2, n)	bcmp(s2, s1, n)
+// #define memcpy(d, s, n)      bcopy(s, d, n)
+// #define memcmp(s1, s2, n)    bcmp(s2, s1, n)
 # endif
 # ifdef SUNOS4
 #include <memory.h>
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/wincurs.h nethack-3.4.3-nao-osx/include/wincurs.h
--- nethack-3.4.3/include/wincurs.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/wincurs.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,295 @@
+#ifndef WINCURS_H
+#define WINCURS_H
+
+/* Global declarations for curses interface */
+
+int term_rows, term_cols; /* size of underlying terminal */
+
+WINDOW *base_term;    /* underlying terminal window */
+
+WINDOW *mapwin, *statuswin, *messagewin;    /* Main windows */
+
+int orig_cursor;	/* Preserve initial cursor state */
+
+boolean counting;   /* Count window is active */
+
+
+#define TEXTCOLOR   /* Allow color */
+#define NHW_END 19
+#define OFF 0
+#define ON 1
+#define NONE -1
+#define KEY_ESC 0x1b
+#define DIALOG_BORDER_COLOR CLR_MAGENTA
+#define SCROLLBAR_COLOR CLR_MAGENTA
+#define SCROLLBAR_BACK_COLOR CLR_BLACK
+#define HIGHLIGHT_COLOR CLR_WHITE
+#define MORECOLOR CLR_ORANGE
+#define STAT_UP_COLOR CLR_GREEN
+#define STAT_DOWN_COLOR CLR_RED
+#define MESSAGE_WIN 1
+#define STATUS_WIN  2
+#define MAP_WIN     3
+#define NHWIN_MAX   4
+#define MESG_HISTORY_MAX   200
+#if !defined(__APPLE__) || !defined(NCURSES_VERSION)
+# define USE_DARKGRAY /* Allow "bright" black; delete if not visible */
+#endif	/* !__APPLE__ && !PDCURSES */
+#define CURSES_DARK_GRAY    17
+#define MAP_SCROLLBARS
+#ifdef PDCURSES
+# define getmouse nc_getmouse
+# ifndef NCURSES_MOUSE_VERSION
+#  define NCURSES_MOUSE_VERSION
+# endif
+#endif
+
+
+typedef enum orient_type
+{
+    CENTER,
+    UP,
+    DOWN,
+    RIGHT,
+    LEFT,
+    UNDEFINED
+} orient;
+
+
+/* cursmain.c */
+
+extern struct window_procs curses_procs;
+
+extern void curses_init_nhwindows(int* argcp, char** argv);
+
+extern void curses_player_selection(void);
+
+extern void curses_askname(void);
+
+extern void curses_get_nh_event(void);
+
+extern void curses_exit_nhwindows(const char *str);
+
+extern void curses_suspend_nhwindows(const char *str);
+
+extern void curses_resume_nhwindows(void);
+
+extern winid curses_create_nhwindow(int type);
+
+extern void curses_clear_nhwindow(winid wid);
+
+extern void curses_display_nhwindow(winid wid, BOOLEAN_P block);
+
+extern void curses_destroy_nhwindow(winid wid);
+
+extern void curses_curs(winid wid, int x, int y);
+
+extern void curses_putstr(winid wid, int attr, const char *text);
+
+extern void curses_display_file(const char *filename,BOOLEAN_P must_exist);
+
+extern void curses_start_menu(winid wid);
+
+extern void curses_add_menu(winid wid, int glyph, const ANY_P * identifier,
+		CHAR_P accelerator, CHAR_P group_accel, int attr, 
+		const char *str, BOOLEAN_P presel);
+
+extern void curses_end_menu(winid wid, const char *prompt);
+
+extern int curses_select_menu(winid wid, int how, MENU_ITEM_P **selected);
+
+extern void curses_update_inventory(void);
+
+extern void curses_mark_synch(void);
+
+extern void curses_wait_synch(void);
+
+extern void curses_cliparound(int x, int y);
+
+extern void curses_print_glyph(winid wid,XCHAR_P x,XCHAR_P y,int glyph);
+
+extern void curses_raw_print(const char *str);
+
+extern void curses_raw_print_bold(const char *str);
+
+extern int curses_nhgetch(void);
+
+extern int curses_nh_poskey(int *x, int *y, int *mod);
+
+extern void curses_nhbell(void);
+
+extern int curses_doprev_message(void);
+
+extern char curses_yn_function(const char *question, const char *choices, CHAR_P def);
+
+extern void curses_getlin(const char *question, char *input);
+
+extern int curses_get_ext_cmd(void);
+
+extern void curses_number_pad(int state);
+
+extern void curses_delay_output(void);
+
+extern void curses_start_screen(void);
+
+extern void curses_end_screen(void);
+
+extern void curses_outrip(winid wid, int how);
+
+extern void genl_outrip(winid tmpwin, int how);
+
+extern void curses_preference_update(const char *pref);
+
+
+/* curswins.c */
+
+extern WINDOW *curses_create_window(int width, int height, orient orientation);
+
+extern void curses_destroy_win(WINDOW *win);
+
+extern WINDOW *curses_get_nhwin(winid wid);
+
+extern void curses_add_nhwin(winid wid, int height, int width, int y,
+ int x, orient orientation, boolean border);
+
+extern void curses_add_wid(winid wid);
+
+extern void curses_refresh_nhwin(winid wid);
+
+extern void curses_refresh_nethack_windows(void);
+
+extern void curses_del_nhwin(winid wid);
+
+extern void curses_del_wid(winid wid);
+
+extern void curses_putch(winid wid, int x, int y, int ch, int color, int attrs);
+
+extern void curses_get_window_size(winid wid, int *height, int *width);
+
+extern boolean curses_window_has_border(winid wid);
+
+extern boolean curses_window_exists(winid wid);
+
+extern int curses_get_window_orientation(winid wid);
+
+extern void curses_get_window_xy(winid wid, int *x, int *y);
+
+extern void curses_puts(winid wid, int attr, const char *text);
+
+extern void curses_clear_nhwin(winid wid);
+
+extern void curses_draw_map(int sx, int sy, int ex, int ey);
+
+extern boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey,
+ int ux, int uy);
+
+
+/* cursmisc.c */
+
+extern int curses_read_char(void);
+
+extern void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff);
+
+extern void curses_bail(const char *mesg);
+
+extern winid curses_get_wid(int type);
+
+extern char *curses_copy_of(const char *s);
+
+extern int curses_num_lines(const char *str, int width);
+
+extern char *curses_break_str(const char *str, int width, int line_num);
+
+extern char *curses_str_remainder(const char *str, int width, int line_num);
+
+extern boolean curses_is_menu(winid wid);
+
+extern boolean curses_is_text(winid wid);
+
+extern int curses_convert_glyph(int ch, int glyph);
+
+extern void curses_move_cursor(winid wid, int x, int y);
+
+extern void curses_prehousekeeping(void);
+
+extern void curses_posthousekeeping(void);
+
+extern void curses_view_file(const char *filename, boolean must_exist);
+
+extern void curses_rtrim(char *str);
+
+extern int curses_get_count(int first_digit);
+
+extern int curses_convert_attr(int attr);
+
+extern int curses_read_attrs(char *attrs);
+
+extern int curses_convert_keys(int key);
+
+extern int curses_get_mouse(int *mousex, int *mousey, int *mod);
+
+/* cursdial.c */
+
+extern void curses_line_input_dialog(const char *prompt, char *answer, int buffer);
+
+extern int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def);
+
+extern int curses_ext_cmd(void);
+
+extern void curses_create_nhmenu(winid wid);
+
+extern void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel);
+
+extern void curses_finalize_nhmenu(winid wid, const char *prompt);
+
+extern int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected);
+
+extern boolean curses_menu_exists(winid wid);
+
+extern void curses_del_menu(winid wid);
+
+
+/* cursstat.c */
+
+extern void curses_update_stats(boolean redraw);
+
+extern void curses_decrement_highlight(void);
+
+
+/* cursinit.c */
+
+extern void curses_create_main_windows(void);
+
+extern void curses_init_nhcolors(void);
+
+extern void curses_choose_character(void);
+
+extern int curses_character_dialog(const char** choices, const char *prompt);
+
+extern void curses_init_options(void);
+
+extern void curses_display_splash_window(void);
+
+extern void curses_cleanup(void);
+
+
+/* cursmesg.c */
+
+extern void curses_message_win_puts(const char *message, boolean recursed);
+
+extern int curses_more(void);
+
+extern void curses_clear_unhighlight_message_window(void);
+
+extern void curses_last_messages(void);
+
+extern void curses_init_mesg_history(void);
+
+extern void curses_prev_mesg(void);
+
+extern void curses_count_window(const char *count_text);
+
+#endif  /* WINCURS_H */
+
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/winprocs.h nethack-3.4.3-nao-osx/include/winprocs.h
--- nethack-3.4.3/include/winprocs.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/winprocs.h	2014-12-20 12:08:36.000000000 -0800
@@ -176,8 +176,14 @@ extern NEARDATA struct window_procs wind
 
 #define WC2_FULLSCREEN		0x01L	/* 01 display full screen                    */
 #define WC2_SOFTKEYBOARD	0x02L	/* 02 software keyboard                      */
-#define WC2_WRAPTEXT		0x04L	/* 04 wrap long lines of text                */
-					/* 29 free bits */
+#define WC2_WRAPTEXT		0x04L	/* 03 wrap long lines of text                */
+#define WC2_DARKGRAY		0x08L	/* 04 try to use "bright black" color        */
+#define WC2_TERM_COLS		0x10L	/* 05 supports setting terminal width        */
+#define WC2_TERM_ROWS		0x20L	/* 06 supports setting terminal height       */
+#define WC2_WINDOWBORDERS   0x40L	/* 07 display borders for NetHack windows    */
+#define WC2_PETATTR         0x80L	/* 08 attributes for highlight_pet */
+#define WC2_GUICOLOR        0x100L	/* 09 attributes for highlight_pet */
+					/* 24 free bits */
 
 #define ALIGN_LEFT	1
 #define ALIGN_RIGHT	2
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/include/wintty.h nethack-3.4.3-nao-osx/include/wintty.h
--- nethack-3.4.3/include/wintty.h	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/include/wintty.h	2014-12-20 12:08:36.000000000 -0800
@@ -20,6 +20,7 @@ typedef struct tty_mi {
     boolean selected;		/* TRUE if selected by user */
     char selector;		/* keyboard accelerator */
     char gselector;		/* group accelerator */
+    int glyph;			/* glyph display in menu */
 } tty_menu_item;
 
 /* descriptor for tty-based windows */
@@ -27,10 +28,10 @@ struct WinDesc {
     int flags;			/* window flags */
     xchar type;			/* type of window */
     boolean active;		/* true if window is active */
-    uchar offx, offy;		/* offset from topleft of display */
-    short rows, cols;		/* dimensions */
-    short curx, cury;		/* current cursor position */
-    short maxrow, maxcol;	/* the maximum size used -- for MENU wins */
+    short offx, offy;		/* offset from topleft of display */
+    long rows, cols;		/* dimensions */
+    long curx, cury;		/* current cursor position */
+    long maxrow, maxcol;	/* the maximum size used -- for MENU wins */
 				/* maxcol is also used by WIN_MESSAGE for */
 				/* tracking the ^P command */
     short *datlen;		/* allocation size for *data */
@@ -38,9 +39,9 @@ struct WinDesc {
     char *morestr;		/* string to display instead of default */
     tty_menu_item *mlist;	/* menu information (MENU) */
     tty_menu_item **plist;	/* menu page pointers (MENU) */
-    short plist_size;		/* size of allocated plist (MENU) */
-    short npages;		/* number of pages in menu (MENU) */
-    short nitems;		/* total number of items (MENU) */
+    long plist_size;		/* size of allocated plist (MENU) */
+    long npages;		/* number of pages in menu (MENU) */
+    long nitems;		/* total number of items (MENU) */
     short how;			/* menu mode - pick 1 or N (MENU) */
     char menu_ch;		/* menu char (MENU) */
 };
@@ -51,8 +52,8 @@ struct WinDesc {
 
 /* descriptor for tty-based displays -- all the per-display data */
 struct DisplayDesc {
-    uchar rows, cols;		/* width and height of tty display */
-    uchar curx, cury;		/* current cursor position on the screen */
+    short rows, cols;		/* width and height of tty display */
+    short curx, cury;		/* current cursor position on the screen */
 #ifdef TEXTCOLOR
     int color;			/* current color */
 #endif
@@ -147,6 +148,9 @@ E void FDECL(term_start_color,(int color
 E int FDECL(has_color,(int color));
 #endif /* TEXTCOLOR */
 
+#ifdef STATUS_COLORS
+E boolean FDECL(parse_status_color_options, (char *));
+#endif /* STATUS_COLOR */
 
 /* ### topl.c ### */
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/allmain.c nethack-3.4.3-nao-osx/src/allmain.c
--- nethack-3.4.3/src/allmain.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/allmain.c	2014-12-20 12:08:36.000000000 -0800
@@ -16,6 +16,78 @@ STATIC_DCL void NDECL(do_positionbar);
 
 #ifdef OVL0
 
+static int prev_hp_notify;
+
+char *
+hpnotify_format_str(char *str)
+{
+    static char buf[128];
+    char *f, *p, *end;
+    int ispercent = 0;
+
+    buf[0] = '\0';
+
+    if (!str) return NULL;
+
+    f = str;
+    p = buf;
+    end = buf + sizeof(buf) - 10;
+
+    while (*f) {
+      if (ispercent) {
+	switch (*f) {
+	case 'a':
+	    snprintf (p, end + 1 - p, "%ld", abs(uhp()-prev_hp_notify));
+	  while (*p != '\0')
+	    p++;
+	  break;
+        case 'c':
+	    snprintf (p, end + 1 - p, "%c", (prev_hp_notify > uhp() ? '-' : '+'));
+	  p++;
+	  break;
+	case 'm':
+	    snprintf (p, end + 1 - p, "%ld", uhpmax());
+	  while (*p != '\0')
+	    p++;
+	  break;
+	case 'H':
+	    if (uhp() == uhpmax()) {
+	    snprintf (p, end + 1 - p, "%s", "max");
+	  } else {
+		snprintf (p, end + 1 - p, "%ld", uhp());
+	  }
+	  while (*p != '\0')
+	    p++;
+	  break;
+	case 'h':
+	    snprintf (p, end + 1 - p, "%ld", uhp());
+	  while (*p != '\0')
+	    p++;
+	  break;
+	default:
+	  *p = *f;
+	  if (p < end)
+	    p++;
+	}
+	ispercent = 0;
+      } else {
+	if (*f == '%')
+	  ispercent = 1;
+	else {
+	  *p = *f;
+	  if (p < end)
+	    p++;
+	}
+      }
+      f++;
+    }
+    *p = '\0';
+
+    return buf;
+}
+
+static long prev_dgl_extrainfo = 0;
+
 void
 moveloop()
 {
@@ -50,14 +122,13 @@ moveloop()
     monstr_init();	/* monster strengths */
     objects_init();
 
-#ifdef WIZARD
-    if (wizard) add_debug_extended_commands();
-#endif
+    commands_init();
 
     (void) encumber_msg(); /* in case they auto-picked up something */
 
     u.uz0.dlevel = u.uz.dlevel;
     youmonst.movement = NORMAL_SPEED;	/* give the hero some movement points */
+    prev_hp_notify = uhp();
 
     for(;;) {
 	get_nh_event();
@@ -144,6 +215,12 @@ moveloop()
 		    if(flags.time && !flags.run)
 			flags.botl = 1;
 
+		    if ((prev_dgl_extrainfo == 0) || (prev_dgl_extrainfo < (moves + 250))) {
+			prev_dgl_extrainfo = moves;
+			mk_dgl_extrainfo();
+		    }
+
+
 		    /* One possible result of prayer is healing.  Whether or
 		     * not you get healed depends on your current hit points.
 		     * If you are allowed to regenerate during the prayer, the
@@ -245,7 +322,7 @@ moveloop()
 				if (occupation)
 				    stop_occupation();
 				else
-				    nomul(0);
+				    nomul(0, NULL);
 				if (change == 1) polyself(FALSE);
 				else you_were();
 				change = 0;
@@ -294,6 +371,22 @@ moveloop()
 	    /* once-per-hero-took-time things go here */
 	    /******************************************/
 
+	if(u.utrap && u.utraptype == TT_LAVA) {
+	    if(!is_lava(u.ux,u.uy))
+		u.utrap = 0;
+	    else if (!u.uinvulnerable) {
+		u.utrap -= 1<<8;
+		if(u.utrap < 1<<8) {
+		    killer_format = KILLED_BY;
+		    killer = "molten lava";
+		    You("sink below the surface and die.");
+		    done(DISSOLVED);
+		} else if(didmove && !u.umoved) {
+		    Norep("You sink deeper into the lava.");
+		    u.utrap += rnd(4);
+		}
+	    }
+	}
 
 	} /* actual time passed */
 
@@ -316,8 +409,23 @@ moveloop()
 
 	    if (vision_full_recalc) vision_recalc(0);	/* vision! */
 	}
+
+#ifdef REALTIME_ON_BOTL
+        if(iflags.showrealtime) {
+            /* Update the bottom line if the number of minutes has
+             * changed */
+            if(get_realtime() / 60 != realtime_data.last_displayed_time / 60)
+                flags.botl = 1;
+        }
+#endif
+
 	if(flags.botl || flags.botlx) bot();
 
+	if (iflags.hp_notify && (prev_hp_notify != uhp())) {
+	  pline("%s", hpnotify_format_str(iflags.hp_notify_fmt ? iflags.hp_notify_fmt : "[HP%c%a=%h]"));
+	  prev_hp_notify = uhp();
+	}
+
 	flags.move = 1;
 
 	if(multi >= 0 && occupation) {
@@ -356,23 +464,6 @@ moveloop()
 	    !(moves % 15) && !rn2(2))
 		do_vicinity_map();
 
-	if(u.utrap && u.utraptype == TT_LAVA) {
-	    if(!is_lava(u.ux,u.uy))
-		u.utrap = 0;
-	    else if (!u.uinvulnerable) {
-		u.utrap -= 1<<8;
-		if(u.utrap < 1<<8) {
-		    killer_format = KILLED_BY;
-		    killer = "molten lava";
-		    You("sink below the surface and die.");
-		    done(DISSOLVED);
-		} else if(didmove && !u.umoved) {
-		    Norep("You sink deeper into the lava.");
-		    u.utrap += rnd(4);
-		}
-	    }
-	}
-
 #ifdef WIZARD
 	if (iflags.sanity_check)
 	    sanity_check();
@@ -402,6 +493,7 @@ moveloop()
 		rhack(save_cm);
 	    }
 	} else if (multi == 0) {
+	  ck_server_admin_msg();
 #ifdef MAIL
 	    ckmailstatus();
 #endif
@@ -420,6 +512,9 @@ moveloop()
 	    if (flags.time && flags.run) flags.botl = 1;
 	    display_nhwindow(WIN_MAP, FALSE);
 	}
+
+	if (moves > last_clear_screen + 2000) doredraw();
+
     }
 }
 
@@ -438,7 +533,7 @@ stop_occupation()
 		sync_hunger();
 */
 #ifdef REDO
-		nomul(0);
+		nomul(0, NULL);
 		pushch(0);
 #endif
 	}
@@ -450,6 +545,7 @@ stop_occupation()
 void
 display_gamewindows()
 {
+    curses_stupid_hack = 0;
     WIN_MESSAGE = create_nhwindow(NHW_MESSAGE);
     WIN_STATUS = create_nhwindow(NHW_STATUS);
     WIN_MAP = create_nhwindow(NHW_MAP);
@@ -537,6 +633,19 @@ newgame()
 #endif
 	program_state.something_worth_saving++;	/* useful data now exists */
 
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+
+        /* Start the timer here */
+        realtime_data.realtime = (time_t)0L;
+
+#if defined(BSD) && !defined(POSIX_TYPES)
+        (void) time((long *)&realtime_data.restoretime);
+#else
+        (void) time(&realtime_data.restoretime);
+#endif
+
+#endif /* RECORD_REALTIME || REALTIME_ON_BOTL */
+
 	/* Success! */
 	welcome(TRUE);
 	return;
@@ -628,6 +737,33 @@ do_positionbar()
 }
 #endif
 
+#if defined(REALTIME_ON_BOTL) || defined (RECORD_REALTIME)
+time_t
+get_realtime(void)
+{
+    time_t curtime;
+
+    /* Get current time */
+#if defined(BSD) && !defined(POSIX_TYPES)
+    (void) time((long *)&curtime);
+#else
+    (void) time(&curtime);
+#endif
+
+    /* Since the timer isn't set until the game starts, this prevents us
+     * from displaying nonsense on the bottom line before it does. */
+    if(realtime_data.restoretime == 0) {
+        curtime = realtime_data.realtime;
+    } else {
+        curtime -= realtime_data.restoretime;
+        curtime += realtime_data.realtime;
+    }
+ 
+    return curtime;
+}
+#endif /* REALTIME_ON_BOTL || RECORD_REALTIME */
+
+
 #endif /* OVLB */
 
 /*allmain.c*/
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/apply.c nethack-3.4.3-nao-osx/src/apply.c
--- nethack-3.4.3/src/apply.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/apply.c	2014-12-20 12:08:36.000000000 -0800
@@ -80,7 +80,7 @@ use_camera(obj)
 	} else if ((mtmp = bhit(u.dx, u.dy, COLNO, FLASHED_LIGHT,
 				(int FDECL((*),(MONST_P,OBJ_P)))0,
 				(int FDECL((*),(OBJ_P,OBJ_P)))0,
-				obj)) != 0) {
+				obj, NULL)) != 0) {
 		obj->ox = u.ux,  obj->oy = u.uy;
 		(void) flash_hits_mon(mtmp, obj);
 	}
@@ -624,7 +624,7 @@ struct obj *obj;
 			pline(Hallucination ?
 			      "Yow!  The mirror stares back!" :
 			      "Yikes!  You've frozen yourself!");
-			nomul(-rnd((MAXULEV+6) - u.ulevel));
+			nomul(-rnd((MAXULEV+6) - u.ulevel), "gazing into a mirror");
 			} else You("stiffen momentarily under your gaze.");
 		    } else if (youmonst.data->mlet == S_VAMPIRE)
 			You("don't have a reflection.");
@@ -670,7 +670,7 @@ struct obj *obj;
 	mtmp = bhit(u.dx, u.dy, COLNO, INVIS_BEAM,
 		    (int FDECL((*),(MONST_P,OBJ_P)))0,
 		    (int FDECL((*),(OBJ_P,OBJ_P)))0,
-		    obj);
+		    obj, NULL);
 	if (!mtmp || !haseyes(mtmp->data))
 		return 1;
 
@@ -788,7 +788,7 @@ struct obj **optr;
 				break;
 			case 2: /* no explanation; it just happens... */
 				nomovemsg = "";
-				nomul(-rnd(2));
+				nomul(-rnd(2), "ringing a bell");
 				break;
 		}
 	    }
@@ -1358,7 +1358,7 @@ int magic; /* 0=Physical, otherwise skil
 		change_luck(-1);
 
 	    teleds(cc.x, cc.y, TRUE);
-	    nomul(-1);
+	    nomul(-1, "jumping around");
 	    nomovemsg = "";
 	    morehungry(rnd(25));
 	    return 1;
@@ -2750,7 +2750,7 @@ do_break_wand(obj)
     current_wand = 0;
     if (obj)
 	delobj(obj);
-    nomul(0);
+    nomul(0, NULL);
     return 1;
 }
 
@@ -2830,6 +2830,7 @@ doapply()
 	case BAG_OF_HOLDING:
 	case OILSKIN_SACK:
 		res = use_container(obj, 1);
+		goto xit2; /* obj may have been destroyed */
 		break;
 	case BAG_OF_TRICKS:
 		bagotricks(obj);
@@ -3012,11 +3013,12 @@ doapply()
 		}
 		pline("Sorry, I don't know how to use that.");
 	xit:
-		nomul(0);
+		nomul(0, NULL);
 		return 0;
 	}
 	if (res && obj && obj->oartifact) arti_speak(obj);
-	nomul(0);
+xit2:
+	nomul(0, NULL);
 	return res;
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/artifact.c nethack-3.4.3-nao-osx/src/artifact.c
--- nethack-3.4.3/src/artifact.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/artifact.c	2014-12-20 12:08:36.000000000 -0800
@@ -283,9 +283,10 @@ struct obj *obj;
 #ifdef OVLB
 
 boolean
-restrict_name(otmp, name)  /* returns 1 if name is restricted for otmp->otyp */
+restrict_name(otmp, name, restrict_typ)  /* returns 1 if name is restricted for otmp->otyp */
 register struct obj *otmp;
 register const char *name;
+register boolean restrict_typ; /* restrict for otmp->otyp? */
 {
 	register const struct artifact *a;
 	register const char *aname;
@@ -298,10 +299,10 @@ register const char *name;
 		   Bug fix:  don't name multiple elven daggers "Sting".
 		 */
 	for (a = artilist+1; a->otyp; a++) {
-	    if (a->otyp != otmp->otyp) continue;
+	    if (restrict_typ && a->otyp != otmp->otyp) continue;
 	    aname = a->name;
 	    if (!strncmpi(aname, "the ", 4)) aname += 4;
-	    if (!strcmp(aname, name))
+	    if (!strcmpi(aname, name))
 		return ((boolean)((a->spfx & (SPFX_NOGEN|SPFX_RESTR)) != 0 ||
 			otmp->quan > 1L));
 	}
@@ -856,7 +857,7 @@ char *hittee;			/* target's name: "you" 
 	    if (Antimagic) {
 		resisted = TRUE;
 	    } else {
-		nomul(-3);
+		nomul(-3, "being scared stiff");
 		nomovemsg = "";
 		if (magr && magr == u.ustuck && sticks(youmonst.data)) {
 		    u.ustuck = (struct monst *)0;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/attrib.c nethack-3.4.3-nao-osx/src/attrib.c
--- nethack-3.4.3/src/attrib.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/attrib.c	2014-12-20 12:08:36.000000000 -0800
@@ -728,4 +728,19 @@ register int n;
 
 #endif /* OVL2 */
 
+/** Returns the hitpoints of your current form. */
+int
+uhp()
+{
+    return (Upolyd ? u.mh : u.uhp);
+}
+
+/** Returns the maximal hitpoints of your current form. */
+int
+uhpmax()
+{
+    return (Upolyd ? u.mhmax : u.uhpmax);
+}
+
+
 /*attrib.c*/
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/ball.c nethack-3.4.3-nao-osx/src/ball.c
--- nethack-3.4.3/src/ball.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/ball.c	2014-12-20 12:08:36.000000000 -0800
@@ -557,7 +557,7 @@ drag:
 	if (near_capacity() > SLT_ENCUMBER && dist2(x, y, u.ux, u.uy) <= 2) {
 	    You("cannot %sdrag the heavy iron ball.",
 			    invent ? "carry all that and also " : "");
-	    nomul(0);
+	    nomul(0, NULL);
 	    return FALSE;
 	}
 
@@ -595,7 +595,7 @@ drag:
 		    u.uy = uchain->oy;
 		    newsym(u.ux0, u.uy0);
 		}
-		nomul(0);
+		nomul(0, NULL);
 
 		*bc_control = BC_BALL;
 		move_bc(1, *bc_control, *ballx, *bally, *chainx, *chainy);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/bones.c nethack-3.4.3-nao-osx/src/bones.c
--- nethack-3.4.3/src/bones.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/bones.c	2014-12-20 12:08:36.000000000 -0800
@@ -31,6 +31,8 @@ d_level *lev;
 		|| Is_botlevel(lev) || (Is_branchlev(lev) && lev->dlevel > 1)
 		   /* no bones in the invocation level               */
 		|| (In_hell(lev) && lev->dlevel == dunlevs_in_dungeon(lev) - 1)
+		   /* AIS: there was a hangup on the level           */
+		|| (level_info[ledger_no(lev)].flags & HANGUP_HERE)
 		);
 }
 
@@ -82,6 +84,7 @@ boolean restore;
 			otmp->rknown = 0;
 			otmp->invlet = 0;
 			otmp->no_charge = 0;
+                       otmp->was_thrown = 0;
 
 			if (otmp->otyp == SLIME_MOLD) goodfruit(otmp->spe);
 #ifdef MAIL
@@ -387,6 +390,8 @@ getbones()
 		&& !wizard
 #endif
 		) return(0);
+
+	if (!iflags.bones) return(0);
 	if(no_bones_level(&u.uz)) return(0);
 	fd = open_bonesfile(&u.uz, &bonesid);
 	if (fd < 0) return(0);
@@ -446,6 +451,7 @@ getbones()
 			}
 			resetobjs(fobj,TRUE);
 			resetobjs(level.buriedobjlist,TRUE);
+			has_loaded_bones = 1;
 		}
 	}
 	(void) close(fd);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/botl.c nethack-3.4.3-nao-osx/src/botl.c
--- nethack-3.4.3/src/botl.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/botl.c	2014-12-20 12:08:36.000000000 -0800
@@ -20,20 +20,139 @@ STATIC_DCL void NDECL(bot1);
 STATIC_DCL void NDECL(bot2);
 #endif /* OVL0 */
 
-/* MAXCO must hold longest uncompressed status line, and must be larger
- * than COLNO
- *
- * longest practical second status line at the moment is
- *	Astral Plane $:12345 HP:700(700) Pw:111(111) AC:-127 Xp:30/123456789
- *	T:123456 Satiated Conf FoodPois Ill Blind Stun Hallu Overloaded
- * -- or somewhat over 130 characters
- */
-#if COLNO <= 140
-#define MAXCO 160
-#else
-#define MAXCO (COLNO+20)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+
+extern const struct percent_color_option *hp_colors;
+extern const struct percent_color_option *pw_colors;
+extern const struct text_color_option *text_colors;
+
+struct color_option
+text_color_of(text, color_options)
+     const char *text;
+     const struct text_color_option *color_options;
+{
+    if (color_options == NULL) {
+	struct color_option result = {NO_COLOR, 0};
+	return result;
+    }
+    if (strstri(color_options->text, text)
+	|| strstri(text, color_options->text))
+	return color_options->color_option;
+    return text_color_of(text, color_options->next);
+}
+
+struct color_option
+percentage_color_of(value, max, color_options)
+     int value, max;
+     const struct percent_color_option *color_options;
+{
+    if (color_options == NULL) {
+	struct color_option result = {NO_COLOR, 0};
+	return result;
+    }
+    switch (color_options->statclrtype) {
+    default:
+    case STATCLR_TYPE_PERCENT:
+	if (100 * value <= color_options->percentage * max)
+	    return color_options->color_option;
+	break;
+    case STATCLR_TYPE_NUMBER_EQ:
+	if (value == color_options->percentage)
+	    return color_options->color_option;
+	break;
+    case STATCLR_TYPE_NUMBER_LT:
+	if (value < color_options->percentage)
+	    return color_options->color_option;
+	break;
+    case STATCLR_TYPE_NUMBER_GT:
+	if (value > color_options->percentage)
+	    return color_options->color_option;
+	break;
+    }
+    return percentage_color_of(value, max, color_options->next);
+}
+
+void
+start_color_option(color_option)
+     struct color_option color_option;
+{
+#ifdef TTY_GRAPHICS
+    int i;
+    if (color_option.color != NO_COLOR)
+	term_start_color(color_option.color);
+    for (i = 0; (1 << i) <= color_option.attr_bits; ++i)
+	if (i != ATR_NONE && color_option.attr_bits & (1 << i))
+	    term_start_attr(i);
+#endif  /* TTY_GRAPHICS */
+}
+
+void
+end_color_option(color_option)
+     struct color_option color_option;
+{
+#ifdef TTY_GRAPHICS
+    int i;
+    if (color_option.color != NO_COLOR)
+	term_end_color();
+    for (i = 0; (1 << i) <= color_option.attr_bits; ++i)
+	if (i != ATR_NONE && color_option.attr_bits & (1 << i))
+	    term_end_attr(i);
+#endif  /* TTY_GRAPHICS */
+}
+
+static
+void
+apply_color_option(color_option, newbot2, statusline)
+     struct color_option color_option;
+     const char *newbot2;
+     int statusline; /* apply color on this statusline: 1 or 2 */
+{
+    if (!iflags.use_status_colors || !iflags.use_color) return;
+    curs(WIN_STATUS, 1, statusline-1);
+    start_color_option(color_option);
+    putstr(WIN_STATUS, 0, newbot2);
+    end_color_option(color_option);
+}
+
+void
+add_colored_text(text, newbot2)
+     const char *text;
+     char *newbot2;
+{
+    char *nb;
+    struct color_option color_option;
+
+    if (*text == '\0') return;
+
+    /* don't add anything if it can't be displayed.
+     * Otherwise the color of invisible text may bleed into
+     * the statusline. */
+    if (strlen(newbot2) >= min(MAXCO, CO)-1) return;
+
+    if (!iflags.use_status_colors) {
+	Sprintf(nb = eos(newbot2), " %s", text);
+	return;
+    }
+
+    Strcat(nb = eos(newbot2), " ");
+    curs(WIN_STATUS, 1, 1);
+    putstr(WIN_STATUS, 0, newbot2);
+
+    Strcat(nb = eos(nb), text);
+    curs(WIN_STATUS, 1, 1);
+    color_option = text_color_of(text, text_colors);
+    start_color_option(color_option);
+    /* Trim the statusline to always have the end color
+     * to have effect. */
+    newbot2[min(MAXCO, CO)-1] = '\0';
+    putstr(WIN_STATUS, 0, newbot2);
+    end_color_option(color_option);
+}
+
 #endif
 
+
+
 #ifndef OVLB
 STATIC_DCL int mrank_sz;
 #else /* OVLB */
@@ -165,16 +284,38 @@ botl_score()
 }
 #endif
 
+#ifdef DUMP_LOG
+void bot1str(char *newbot1)
+#else
 STATIC_OVL void
 bot1()
+#endif
 {
+#ifndef DUMP_LOG
 	char newbot1[MAXCO];
+#endif
 	register char *nb;
-	register int i,j;
+	register int i=0,j;
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        int save_botlx = flags.botlx;
+#endif
 
-	Strcpy(newbot1, plname);
-	if('a' <= newbot1[0] && newbot1[0] <= 'z') newbot1[0] += 'A'-'a';
-	newbot1[10] = 0;
+        Strcpy(newbot1, "");
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        if (iflags.hitpointbar) {
+	    flags.botlx = 0;
+	    curs(WIN_STATUS, 1, 0);
+	    putstr(WIN_STATUS, 0, newbot1);
+	    Strcat(newbot1, "[");
+	    i = 1; /* don't overwrite the string in front */
+	    curs(WIN_STATUS, 1, 0);
+	    putstr(WIN_STATUS, 0, newbot1);
+        }
+#endif
+
+	Strcat(newbot1, plname);
+	if('a' <= newbot1[i] && newbot1[i] <= 'z') newbot1[i] += 'A'-'a';
+	newbot1[10] = '\0';
 	Sprintf(nb = eos(newbot1)," the ");
 
 	if (Upolyd) {
@@ -188,9 +329,37 @@ bot1()
 			mbot[k] += 'A' - 'a';
 		    k++;
 		}
-		Sprintf(nb = eos(nb), mbot);
+		Sprintf(nb = eos(nb), "%s", mbot);
 	} else
-		Sprintf(nb = eos(nb), rank());
+	    Sprintf(nb = eos(nb), "%s", rank());
+
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        if (iflags.hitpointbar) {
+	    int bar_length = strlen(newbot1)-1;
+	    char tmp[MAXCO];
+	    char *p = tmp;
+	    int filledbar = ((uhp() < 0) ? 0 : uhp()) * bar_length / uhpmax();
+	    if (filledbar >= MAXCO) { filledbar = MAXCO-1; }
+	    Strcpy(tmp, newbot1);
+	    p++;
+
+	    /* draw hp bar */
+	    if (iflags.use_inverse) term_start_attr(ATR_INVERSE);
+	    p[filledbar] = '\0';
+	    if (iflags.use_color) {
+		/* draw in color mode */
+		apply_color_option(percentage_color_of(uhp(), uhpmax(), hp_colors), tmp, 1);
+	    } else {
+		/* draw in inverse mode */
+		curs(WIN_STATUS, 1, 0);
+		putstr(WIN_STATUS, 0, tmp);
+	    }
+	    term_end_color();
+	    if (iflags.use_inverse) term_end_attr(ATR_INVERSE);
+
+	    Strcat(newbot1, "]");
+        }
+#endif
 
 	Sprintf(nb = eos(nb),"  ");
 	i = mrank_sz + 15;
@@ -215,8 +384,19 @@ bot1()
 	if (flags.showscore)
 	    Sprintf(nb = eos(nb), " S:%ld", botl_score());
 #endif
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot1()
+{
+	char newbot1[MAXCO];
+
+	int save_botlx = flags.botlx;
+	bot1str(newbot1);
+#endif
 	curs(WIN_STATUS, 1, 0);
 	putstr(WIN_STATUS, 0, newbot1);
+	flags.botlx = save_botlx;
 }
 
 /* provide the name of the current level for display by various ports */
@@ -242,28 +422,59 @@ char *buf;
 	return ret;
 }
 
+#ifdef DUMP_LOG
+void bot2str(newbot2)
+char* newbot2;
+#else
 STATIC_OVL void
 bot2()
+#endif
 {
+#ifndef DUMP_LOG
 	char  newbot2[MAXCO];
+#endif
 	register char *nb;
 	int hp, hpmax;
 	int cap = near_capacity();
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        int save_botlx = flags.botlx;
+#endif
 
 	hp = Upolyd ? u.mh : u.uhp;
 	hpmax = Upolyd ? u.mhmax : u.uhpmax;
 
-	if(hp < 0) hp = 0;
-	(void) describe_level(newbot2);
-	Sprintf(nb = eos(newbot2),
-		"%c:%-2ld HP:%d(%d) Pw:%d(%d) AC:%-2d", oc_syms[COIN_CLASS],
+        if(hp < 0) hp = 0;
+        (void) describe_level(newbot2);
+        Sprintf(nb = eos(newbot2), "%c:%-2ld", oc_syms[COIN_CLASS],
 #ifndef GOLDOBJ
-		u.ugold,
+                u.ugold
+#else
+                money_cnt(invent)
+#endif
+		);
+
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        Strcat(nb = eos(newbot2), " HP:");
+        curs(WIN_STATUS, 1, 1);
+        putstr(WIN_STATUS, 0, newbot2);
+        flags.botlx = 0;
+
+        Sprintf(nb = eos(nb), "%d(%d)", hp, hpmax);
+        apply_color_option(percentage_color_of(hp, hpmax, hp_colors), newbot2, 2);
 #else
-		money_cnt(invent),
+        Sprintf(nb = eos(nb), " HP:%d(%d)", hp, hpmax);
 #endif
-		hp, hpmax, u.uen, u.uenmax, u.uac);
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        Strcat(nb = eos(nb), " Pw:");
+        curs(WIN_STATUS, 1, 1);
+        putstr(WIN_STATUS, 0, newbot2);
 
+        Sprintf(nb = eos(nb), "%d(%d)", u.uen, u.uenmax);
+        apply_color_option(percentage_color_of(u.uen, u.uenmax, pw_colors), newbot2, 2);
+#else
+        Sprintf(nb = eos(nb), " Pw:%d(%d)", u.uen, u.uenmax);
+#endif
+        Sprintf(nb = eos(nb), " AC:%-2d", u.uac);
 	if (Upolyd)
 		Sprintf(nb = eos(nb), " HD:%d", mons[u.umonnum].mlevel);
 #ifdef EXP_ON_BOTL
@@ -275,33 +486,104 @@ bot2()
 
 	if(flags.time)
 	    Sprintf(nb = eos(nb), " T:%ld", moves);
-	if(strcmp(hu_stat[u.uhs], "        ")) {
-		Sprintf(nb = eos(nb), " ");
-		Strcat(newbot2, hu_stat[u.uhs]);
-	}
-	if(Confusion)	   Sprintf(nb = eos(nb), " Conf");
-	if(Sick) {
-		if (u.usick_type & SICK_VOMITABLE)
-			   Sprintf(nb = eos(nb), " FoodPois");
-		if (u.usick_type & SICK_NONVOMITABLE)
-			   Sprintf(nb = eos(nb), " Ill");
-	}
-	if(Blind)	   Sprintf(nb = eos(nb), " Blind");
-	if(Stunned)	   Sprintf(nb = eos(nb), " Stun");
-	if(Hallucination)  Sprintf(nb = eos(nb), " Hallu");
-	if(Slimed)         Sprintf(nb = eos(nb), " Slime");
-	if(cap > UNENCUMBERED)
-		Sprintf(nb = eos(nb), " %s", enc_stat[cap]);
+
+#ifdef REALTIME_ON_BOTL
+  if(iflags.showrealtime) {
+    time_t currenttime = get_realtime();
+    Sprintf(nb = eos(nb), " %d:%2.2d", currenttime / 3600, 
+                                       (currenttime % 3600) / 60);
+  }
+#endif
+
+  if(strcmp(hu_stat[u.uhs], "        "))
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text(hu_stat[u.uhs], newbot2);
+#else
+  Sprintf(nb = eos(nb), " %s", hu_stat[u.uhs]);
+#endif
+  if(Confusion)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text("Conf", newbot2);
+#else
+  Strcat(nb = eos(nb), " Conf");
+#endif
+  if(Sick) {
+      if (u.usick_type & SICK_VOMITABLE)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+	  add_colored_text("FoodPois", newbot2);
+#else
+      Strcat(nb = eos(nb), " FoodPois");
+#endif
+      if (u.usick_type & SICK_NONVOMITABLE)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+	  add_colored_text("Ill", newbot2);
+#else
+      Strcat(nb = eos(nb), " Ill");
+#endif
+  }
+  if(Blind)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text("Blind", newbot2);
+#else
+  Strcat(nb = eos(nb), " Blind");
+#endif
+  if(Stunned)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text("Stun", newbot2);
+#else
+  Strcat(nb = eos(nb), " Stun");
+#endif
+  if(Hallucination)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text("Hallu", newbot2);
+#else
+  Strcat(nb = eos(nb), " Hallu");
+#endif
+  if(Slimed)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text("Slime", newbot2);
+#else
+  Strcat(nb = eos(nb), " Slime");
+#endif
+  if(cap > UNENCUMBERED)
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+      add_colored_text(enc_stat[cap], newbot2);
+#else
+  Sprintf(nb = eos(nb), " %s", enc_stat[cap]);
+#endif
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot2()
+{
+	char newbot2[MAXCO];
+	bot2str(newbot2);
+	int save_botlx = flags.botlx;
+#endif
 	curs(WIN_STATUS, 1, 1);
 	putstr(WIN_STATUS, 0, newbot2);
+	flags.botlx = save_botlx;
 }
 
 void
 bot()
 {
+	if (!iflags.botl_updates) {
+	  flags.botl = flags.botlx = 0;
+	  return;
+	}
+	bot1();
+	bot2();
+	flags.botl = flags.botlx = 0;
+}
+
+int
+force_bot()
+{
 	bot1();
 	bot2();
 	flags.botl = flags.botlx = 0;
+	return 0;
 }
 
 #endif /* OVL0 */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/cmd.c nethack-3.4.3-nao-osx/src/cmd.c
--- nethack-3.4.3/src/cmd.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/cmd.c	2014-12-20 12:08:36.000000000 -0800
@@ -2,6 +2,8 @@
 /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
 /* NetHack may be freely redistributed.  See license for details. */
 
+#include <ctype.h>
+
 #include "hack.h"
 #include "func_tab.h"
 /* #define DEBUG */	/* uncomment for debugging */
@@ -38,6 +40,7 @@ extern int NDECL(donull); /**/
 extern int NDECL(dowipe); /**/
 extern int NDECL(do_mname); /**/
 extern int NDECL(ddocall); /**/
+extern void FDECL(do_oname, (struct obj *));
 extern int NDECL(dotakeoff); /**/
 extern int NDECL(doremring); /**/
 extern int NDECL(dowear); /**/
@@ -109,6 +112,7 @@ STATIC_PTR int NDECL(doextcmd);
 STATIC_PTR int NDECL(domonability);
 STATIC_PTR int NDECL(dotravel);
 # ifdef WIZARD
+STATIC_PTR int NDECL(wiz_mk_mapglyphdump);
 STATIC_PTR int NDECL(wiz_wish);
 STATIC_PTR int NDECL(wiz_identify);
 STATIC_PTR int NDECL(wiz_map);
@@ -123,6 +127,10 @@ STATIC_PTR int NDECL(wiz_show_seenv);
 STATIC_PTR int NDECL(wiz_show_vision);
 STATIC_PTR int NDECL(wiz_mon_polycontrol);
 STATIC_PTR int NDECL(wiz_show_wmodes);
+STATIC_PTR int NDECL(wiz_showkills);	/* showborn patch */
+#ifdef SHOW_BORN
+extern void FDECL(list_vanquished, (int, BOOLEAN_P)); /* showborn patch */
+#endif /* SHOW_BORN */
 #if defined(__BORLANDC__) && !defined(_WIN32)
 extern void FDECL(show_borlandc_stats, (winid));
 #endif
@@ -144,6 +152,13 @@ STATIC_PTR int NDECL(doattributes);
 STATIC_PTR int NDECL(doconduct); /**/
 STATIC_PTR boolean NDECL(minimal_enlightenment);
 
+static void FDECL(bind_key, (unsigned char, char*));
+static void NDECL(init_bind_list);
+static void NDECL(change_bind_list);
+#ifdef WIZARD
+static void NDECL(add_debug_extended_commands);
+#endif /* WIZARD */
+
 #ifdef OVLB
 STATIC_DCL void FDECL(enlght_line, (const char *,const char *,const char *));
 STATIC_DCL char *FDECL(enlght_combatinc, (const char *,int,int,char *));
@@ -153,6 +168,7 @@ static void NDECL(end_of_input);
 #endif /* OVLB */
 
 static const char* readchar_queue="";
+static char last_cmd_char='\0';
 
 STATIC_DCL char *NDECL(parse);
 STATIC_DCL boolean FDECL(help_dir, (CHAR_P,const char *));
@@ -314,16 +330,22 @@ doextlist()	/* here after #? - now list 
 	putstr(datawin, 0, "");
 
 	for(efp = extcmdlist; efp->ef_txt; efp++) {
-		Sprintf(buf, "    %-15s - %s.", efp->ef_txt, efp->ef_desc);
+		/* Show name and text for each command.  Autocompleted
+		 * commands are marked with an asterisk ('*'). */
+		Sprintf(buf, "  %c %-15s - %s.",
+			efp->autocomplete ? '*' : ' ',
+			efp->ef_txt, efp->ef_desc);
 		putstr(datawin, 0, buf);
 	}
+	putstr(datawin, 0, "");
+	putstr(datawin, 0, "    Commands marked with a * will be autocompleted.");
 	display_nhwindow(datawin, FALSE);
 	destroy_nhwindow(datawin);
 	return 0;
 }
 
-#ifdef TTY_GRAPHICS
-#define MAX_EXT_CMD 40		/* Change if we ever have > 40 ext cmds */
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
+#define MAX_EXT_CMD 200		/* Change if we ever have more ext cmds */
 /*
  * This is currently used only by the tty port and is
  * controlled via runtime option 'extmenu'
@@ -478,9 +500,29 @@ domonability()
 STATIC_PTR int
 enter_explore_mode()
 {
+#ifdef PARANOID
+	char buf[BUFSZ];
+	int really_xplor = FALSE;
+#endif
+	pline("Explore mode is for local games, not public servers.");
+	return 0;
+
 	if(!discover && !wizard) {
 		pline("Beware!  From explore mode there will be no return to normal game.");
+#ifdef PARANOID
+		if (iflags.paranoid_quit) {
+		  getlin ("Do you want to enter explore mode? [yes/no]?",buf);
+		  (void) lcase (buf);
+		  if (!(strcmp (buf, "yes"))) really_xplor = TRUE;
+		} else {
+		  if (yn("Do you want to enter explore mode?") == 'y') {
+		    really_xplor = TRUE;
+		  }
+		}
+		if (really_xplor) {
+#else
 		if (yn("Do you want to enter explore mode?") == 'y') {
+#endif
 			clear_nhwindow(WIN_MESSAGE);
 			You("are now in non-scoring explore mode.");
 			discover = TRUE;
@@ -495,6 +537,15 @@ enter_explore_mode()
 
 #ifdef WIZARD
 
+STATIC_PTR int
+wiz_mk_mapglyphdump()
+{
+#ifdef MAPDUMP_FN
+    mk_mapdump(MAPDUMP_FN);
+#endif
+    return 0;
+}
+
 /* ^W command - wish for something */
 STATIC_PTR int
 wiz_wish()	/* Unlimited wishes for debug mode by Paul Polderman */
@@ -756,6 +807,13 @@ wiz_show_wmodes()
 	return 0;
 }
 
+/* #showkills command */
+STATIC_PTR int wiz_showkills()		/* showborn patch */
+{
+	list_vanquished('y', FALSE);
+	return 0;
+}
+
 #endif /* WIZARD */
 
 
@@ -1126,6 +1184,305 @@ int final;	/* 0 => still in progress; 1 
 	return;
 }
 
+#ifdef DUMP_LOG
+void
+dump_enlightenment(final)
+int final;
+{
+	int ltmp;
+	char buf[BUFSZ];
+	char buf2[BUFSZ];
+	const char *enc_stat[] = { /* copied from botl.c */
+	     "",
+	     "burdened",
+	     "stressed",
+	     "strained",
+	     "overtaxed",
+	     "overloaded"
+	};
+	char *youwere = "  You were ";
+	char *youhave = "  You have ";
+	char *youhad  = "  You had ";
+	char *youcould = "  You could ";
+
+	dump("", "Final attributes");
+
+#ifdef ELBERETH
+	if (u.uevent.uhand_of_elbereth) {
+	    static const char * const hofe_titles[3] = {
+				"the Hand of Elbereth",
+				"the Envoy of Balance",
+				"the Glory of Arioch"
+	    };
+	    dump(youwere,
+		(char *)hofe_titles[u.uevent.uhand_of_elbereth - 1]);
+	}
+#endif
+
+	if (u.ualign.record >= 20)
+		dump(youwere, "piously aligned");
+	else if (u.ualign.record > 13)
+	    dump(youwere, "devoutly aligned");
+	else if (u.ualign.record > 8)
+	    dump(youwere, "fervently aligned");
+	else if (u.ualign.record > 3)
+	    dump(youwere, "stridently aligned");
+	else if (u.ualign.record == 3)
+	    dump(youwere, "aligned");
+	else if (u.ualign.record > 0)
+	    dump(youwere, "haltingly aligned");
+	else if (u.ualign.record == 0)
+	    dump(youwere, "nominally aligned");
+	else if (u.ualign.record >= -3)	dump(youhave, "strayed");
+	else if (u.ualign.record >= -8)	dump(youhave, "sinned");
+	else dump("  You have ", "transgressed");
+	Sprintf(buf, " %d", u.ualign.record);
+	dump("  Your alignment was ", buf);
+
+
+	/*** Resistances to troubles ***/
+	if (Fire_resistance) dump(youwere, "fire resistant");
+	if (Cold_resistance) dump(youwere, "cold resistant");
+	if (Sleep_resistance) dump(youwere, "sleep resistant");
+	if (Disint_resistance) dump(youwere, "disintegration-resistant");
+	if (Shock_resistance) dump(youwere, "shock resistant");
+	if (Poison_resistance) dump(youwere, "poison resistant");
+	if (Drain_resistance) dump(youwere, "level-drain resistant");
+	if (Sick_resistance) dump(youwere, "immune to sickness");
+	if (Antimagic) dump(youwere, "magic-protected");
+	if (Acid_resistance) dump(youwere, "acid resistant");
+	if (Stone_resistance) dump(youwere, "petrification resistant");
+	if (Invulnerable) dump(youwere, "invulnerable");
+	if (u.uedibility) dump(youcould, "recognize detrimental food");
+
+	/*** Troubles ***/
+	if (Halluc_resistance) 	dump("  ", "You resisted hallucinations");
+	if (Hallucination) dump(youwere, "hallucinating");
+	if (Stunned) dump(youwere, "stunned");
+	if (Confusion) dump(youwere, "confused");
+	if (Blinded) dump(youwere, "blinded");
+	if (Sick) {
+		if (u.usick_type & SICK_VOMITABLE)
+			dump(youwere, "sick from food poisoning");
+		if (u.usick_type & SICK_NONVOMITABLE)
+			dump(youwere, "sick from illness");
+	}
+	if (Stoned) dump(youwere, "turning to stone");
+	if (Slimed) dump(youwere, "turning into slime");
+	if (Strangled)
+		dump(youwere, (u.uburied) ? "buried" : "being strangled");
+	if (Glib) {
+		Sprintf(buf, "slippery %s", makeplural(body_part(FINGER)));
+		dump(youhad, buf);
+	}
+	if (Fumbling) dump("  ", "You fumbled");
+	if (Wounded_legs
+#ifdef STEED
+	    && !u.usteed
+#endif
+			  ) {
+		Sprintf(buf, "wounded %s", makeplural(body_part(LEG)));
+		dump(youhad, buf);
+	}
+#ifdef STEED
+	if (Wounded_legs && u.usteed) {
+	    Strcpy(buf, x_monnam(u.usteed, ARTICLE_YOUR, (char *)0, 
+		    SUPPRESS_SADDLE | SUPPRESS_HALLUCINATION, FALSE));
+	    *buf = highc(*buf);
+	    Strcat(buf, " had wounded legs");
+	    dump("  ", buf);
+	}
+#endif
+	if (Sleeping) dump("  ", "You fell asleep");
+	if (Hunger) dump("  ", "You hungered rapidly");
+
+	/*** Vision and senses ***/
+	if (See_invisible) dump("  ", "You saw invisible");
+	if (Blind_telepat) dump(youwere, "telepathic");
+	if (Warning) dump(youwere, "warned");
+	if (Warn_of_mon && flags.warntype) {
+		Sprintf(buf, "aware of the presence of %s",
+			(flags.warntype & M2_ORC) ? "orcs" :
+			(flags.warntype & M2_DEMON) ? "demons" :
+			something); 
+		dump(youwere, buf);
+	}
+	if (Undead_warning) dump(youwere, "warned of undead");
+	if (Searching) dump(youhad, "automatic searching");
+	if (Clairvoyant) dump(youwere, "clairvoyant");
+	if (Infravision) dump(youhad, "infravision");
+	if (Detect_monsters)
+	  dump(youwere, "sensing the presence of monsters");
+	if (u.umconf) dump(youwere, "going to confuse monsters");
+
+	/*** Appearance and behavior ***/
+	if (Adornment) {
+	    int adorn = 0;
+	    if(uleft && uleft->otyp == RIN_ADORNMENT) adorn += uleft->spe;
+	    if(uright && uright->otyp == RIN_ADORNMENT) adorn += uright->spe;
+	    if (adorn < 0)
+		dump(youwere, "poorly adorned");
+	    else
+		dump(youwere, "adorned");
+	}
+	if (Invisible) dump(youwere, "invisible");
+	else if (Invis) dump(youwere, "invisible to others");
+	/* ordinarily "visible" is redundant; this is a special case for
+	   the situation when invisibility would be an expected attribute */
+	else if ((HInvis || EInvis || pm_invisible(youmonst.data)) && BInvis)
+	    dump(youwere, "visible");
+	if (Displaced) dump(youwere, "displaced");
+	if (Stealth) dump(youwere, "stealthy");
+	if (Aggravate_monster) dump("  ", "You aggravated monsters");
+	if (Conflict) dump("  ", "You caused conflict");
+
+	/*** Transportation ***/
+	if (Jumping) dump(youcould, "jump");
+	if (Teleportation) dump(youcould, "teleport");
+	if (Teleport_control) dump(youhad, "teleport control");
+	if (Lev_at_will) dump(youwere, "levitating, at will");
+	else if (Levitation)
+	  dump(youwere, "levitating");	/* without control */
+	else if (Flying) dump(youcould, "fly");
+	if (Wwalking) dump(youcould, "walk on water");
+	if (Swimming) dump(youcould, "swim");
+	if (Breathless) dump(youcould, "survive without air");
+	else if (Amphibious) dump(youcould, "breathe water");
+	if (Passes_walls) dump(youcould, "walk through walls");
+#ifdef STEED
+	if (u.usteed && (final < 2 || strcmp(killer, "riding accident"))) {
+	    Sprintf(buf, "riding %s", y_monnam(u.usteed));
+	    dump(youwere, buf);
+	}
+#endif
+	if (u.uswallow) {
+	    Sprintf(buf, "swallowed by %s", a_monnam(u.ustuck));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%u)", u.uswldtim);
+#endif
+	    dump(youwere, buf);
+	} else if (u.ustuck) {
+	    Sprintf(buf, "%s %s",
+		    (Upolyd && sticks(youmonst.data)) ? "holding" : "held by",
+		    a_monnam(u.ustuck));
+	    dump(youwere, buf);
+	}
+
+	/*** Physical attributes ***/
+	if (u.uhitinc)
+	    dump(youhad,
+		enlght_combatinc("to hit", u.uhitinc, final, buf));
+	if (u.udaminc)
+	    dump(youhad,
+		enlght_combatinc("damage", u.udaminc, final, buf));
+	if (Slow_digestion) dump(youhad, "slower digestion");
+	if (Regeneration) dump("  ", "You regenerated");
+	if (u.uspellprot || Protection) {
+	    int prot = 0;
+
+	    if(uleft && uleft->otyp == RIN_PROTECTION) prot += uleft->spe;
+	    if(uright && uright->otyp == RIN_PROTECTION) prot += uright->spe;
+	    if (HProtection & INTRINSIC) prot += u.ublessed;
+	    prot += u.uspellprot;
+	    
+	    if (prot < 0)
+		dump(youwere, "ineffectively protected");
+	    else
+		dump(youwere, "protected");
+	}
+	if (Protection_from_shape_changers)
+		dump(youwere, "protected from shape changers");
+	if (Polymorph) dump(youwere, "polymorphing");
+	if (Polymorph_control) dump(youhad, "polymorph control");
+	if (u.ulycn >= LOW_PM) {
+		Strcpy(buf, an(mons[u.ulycn].mname));
+		dump(youwere, buf);
+	}
+	if (Upolyd) {
+	    if (u.umonnum == u.ulycn) Strcpy(buf, "in beast form");
+	    else Sprintf(buf, "polymorphed into %s",
+			 an(youmonst.data->mname));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.mtimedone);
+#endif
+	    dump(youwere, buf);
+	}
+	if (Unchanging)
+	  dump(youcould, "not change from your current form");
+	if (Fast) dump(youwere, Very_fast ? "very fast" : "fast");
+	if (Reflecting) dump(youhad, "reflection");
+	if (Free_action) dump(youhad, "free action");
+	if (Fixed_abil) dump(youhad, "fixed abilities");
+	if (Lifesaved)
+		dump("  ", "Your life would have been saved");
+	if (u.twoweap) dump(youwere, "wielding two weapons at once");
+
+	/*** Miscellany ***/
+	if (Luck) {
+	    ltmp = abs((int)Luck);
+	    Sprintf(buf, "%s%slucky (%d)",
+		    ltmp >= 10 ? "extremely " : ltmp >= 5 ? "very " : "",
+		    Luck < 0 ? "un" : "", Luck);
+	    dump(youwere, buf);
+	}
+#ifdef WIZARD
+	 else if (wizard) dump("  ", "Your luck was zero");
+#endif
+	if (u.moreluck > 0) dump(youhad, "extra luck");
+	else if (u.moreluck < 0) dump(youhad, "reduced luck");
+	if (carrying(LUCKSTONE) || stone_luck(TRUE)) {
+	    ltmp = stone_luck(FALSE);
+	    if (ltmp <= 0)
+		dump("  ", "Bad luck did not time out for you");
+	    if (ltmp >= 0)
+		dump("  ", "Good luck did not time out for you");
+	}
+
+	if (u.ugangr) {
+	    Sprintf(buf, " %sangry with you",
+		u.ugangr > 6 ? "extremely " : u.ugangr > 3 ? "very " : "");
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.ugangr);
+#endif
+	    Sprintf(buf2, "%s was %s", u_gname(), buf);
+	    dump("  ", buf2);
+	}
+
+    {
+	const char *p;
+
+	buf[0] = '\0';
+	if (final < 2) {    /* quit/escaped/ascended */
+	    p = "survived after being killed ";
+	    switch (u.umortality) {
+	    case 0:  p = "survived";  break;
+	    case 1:  Strcpy(buf, "once");  break;
+	    case 2:  Strcpy(buf, "twice");  break;
+	    case 3:  Strcpy(buf, "thrice");  break;
+	    default: Sprintf(buf, "%d times", u.umortality);
+		     break;
+	    }
+	} else {		/* game ended in character's death */
+	    p = "are dead";
+	    switch (u.umortality) {
+	    case 0:  impossible("dead without dying?");
+	    case 1:  break;			/* just "are dead" */
+	    default: Sprintf(buf, " (%d%s time!)", u.umortality,
+			     ordin(u.umortality));
+		     break;
+	    }
+	}
+	if (p) {
+	  Sprintf(buf2, "You %s %s", p, buf);
+	  dump("  ", buf2);
+	}
+    }
+	dump("", "");
+	return;
+
+} /* dump_enlightenment */
+#endif
+
 /*
  * Courtesy function for non-debug, non-explorer mode players
  * to help refresh them about who/what they are.
@@ -1230,6 +1587,94 @@ minimal_enlightenment()
 	return (n != -1);
 }
 
+int
+do_naming(typ)
+int typ;
+{
+    winid win;
+    anything any;
+    menu_item *pick_list = NULL;
+    int n;
+    register struct obj *obj;
+    char allowall[2];
+    static NEARDATA const char callable[] = {
+	SCROLL_CLASS, POTION_CLASS, WAND_CLASS, RING_CLASS, AMULET_CLASS,
+	GEM_CLASS, SPBOOK_CLASS, ARMOR_CLASS, TOOL_CLASS, 0 };
+
+    if (!typ) {
+      any.a_void = 0;
+      win = create_nhwindow(NHW_MENU);
+      start_menu(win);
+
+      any.a_int = 1;
+      add_menu(win, NO_GLYPH, &any, 'a', 'C', ATR_NONE, "Name a monster", MENU_UNSELECTED);
+
+      any.a_int = 2;
+      add_menu(win, NO_GLYPH, &any, 'b', 'y', ATR_NONE, "Name an individual item", MENU_UNSELECTED);
+
+      any.a_int = 3;
+      add_menu(win, NO_GLYPH, &any, 'c', 'n', ATR_NONE, "Name all items of a certain type", MENU_UNSELECTED);
+
+      any.a_int = 4;
+      add_menu(win, NO_GLYPH, &any, 'd', 0, ATR_NONE, "View discoveries", MENU_UNSELECTED);
+
+      any.a_int = 0;
+      add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
+
+      end_menu(win, "What do you wish to do?");
+      n = select_menu(win, PICK_ONE, &pick_list);
+      destroy_nhwindow(win);
+
+      if (pick_list) {
+	n = (pick_list[0].item.a_int - 1);
+	free((genericptr_t) pick_list);
+      } else return 0;
+    } else {
+      n = (typ - 1);
+    }
+    switch (n) {
+    default: break;
+    case 0: do_mname(); break;
+	/* cases 1 & 2 duplicated from ddocall() */
+    case 1:
+	allowall[0] = ALL_CLASSES; allowall[1] = '\0';
+	obj = getobj(allowall, "name");
+	if(obj) do_oname(obj);
+	break;
+    case 2:
+	obj = getobj(callable, "call");
+	if (obj) {
+	    /* behave as if examining it in inventory;
+                           this might set dknown if it was picked up
+                           while blind and the hero can now see */
+	    (void) xname(obj);
+
+	    if (!obj->dknown) {
+		You("would never recognize another one.");
+		return 0;
+	    }
+	    docall(obj);
+	}
+	break;
+    case 3: dodiscovered(); break;
+    }
+    return 0;
+}
+
+int
+do_naming_mname()
+{
+  if (iflags.old_C_behaviour) return do_naming(1);
+  return do_naming(0);
+}
+
+int
+do_naming_ddocall()
+{
+  return do_naming(0);
+}
+
+
 STATIC_PTR int
 doattributes()
 {
@@ -1341,9 +1786,108 @@ int final;
 	destroy_nhwindow(en_win);
 }
 
+#ifdef DUMP_LOG
+void
+dump_conduct(final)
+int final;
+{
+	char buf[BUFSZ];
+	int ngenocided;
+
+	dump("", "Voluntary challenges");
+
+	if (!u.uconduct.food)
+	    dump("", "  You went without food");
+	    /* But beverages are okay */
+	else if (!u.uconduct.unvegan)
+	    dump("", "  You followed a strict vegan diet");
+	else if (!u.uconduct.unvegetarian)
+	    dump("", "  You were a vegetarian");
+	else if (Role_if(PM_MONK) && u.uconduct.unvegetarian < 10) {
+	    sprintf(buf, "  You ate non-vegetarian food %ld time%s.", 
+		u.uconduct.unvegetarian, plur(u.uconduct.unvegetarian));
+	    dump("", buf);
+	}
+
+	if (!u.uconduct.gnostic)
+	    dump("", "  You were an atheist");
+
+	if (!u.uconduct.weaphit)
+	    dump("", "  You never hit with a wielded weapon");
+	else if (Role_if(PM_MONK) && u.uconduct.weaphit < 10) {
+	    Sprintf(buf, "  You hit with a wielded weapon %ld time%s",
+		    u.uconduct.weaphit, plur(u.uconduct.weaphit));
+	    dump("", buf);
+	}
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "hit with a wielded weapon %ld time%s",
+		    u.uconduct.weaphit, plur(u.uconduct.weaphit));
+	    dump("  You ", buf);
+	}
+#endif
+	if (!u.uconduct.killer)
+	    dump("", "  You were a pacifist");
+
+	if (!u.uconduct.literate)
+	    dump("", "  You were illiterate");
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "read items or engraved %ld time%s",
+		    u.uconduct.literate, plur(u.uconduct.literate));
+	    dump("  You ", buf);
+	}
+#endif
+
+	ngenocided = num_genocides();
+	if (ngenocided == 0) {
+	    dump("", "  You never genocided any monsters");
+	} else {
+	    Sprintf(buf, "genocided %d type%s of monster%s",
+		    ngenocided, plur(ngenocided), plur(ngenocided));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polypiles)
+	    dump("", "  You never polymorphed an object");
+	else {
+	    Sprintf(buf, "polymorphed %ld item%s",
+		    u.uconduct.polypiles, plur(u.uconduct.polypiles));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polyselfs)
+	    dump("", "  You never changed form");
+	else {
+	    Sprintf(buf, "changed form %ld time%s",
+		    u.uconduct.polyselfs, plur(u.uconduct.polyselfs));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.wishes)
+	    dump("", "  You used no wishes");
+	else {
+	    Sprintf(buf, "used %ld wish%s",
+		    u.uconduct.wishes, (u.uconduct.wishes > 1L) ? "es" : "");
+	    dump("  You ", buf);
+
+	    if (!u.uconduct.wisharti)
+		dump("", "  You did not wish for any artifacts");
+	}
+
+	dump("", "");
+}
+#endif /* DUMP_LOG */
+
 #endif /* OVLB */
 #ifdef OVL1
 
+/* Macros for meta and ctrl modifiers:
+ *   M and C return the meta/ctrl code for the given character;
+ *     e.g., (C('c') is ctrl-c
+ *   ISMETA and ISCTRL return TRUE iff the code is a meta/ctrl code
+ *   UNMETA and UNCTRL are the opposite of M/C and return the key for a given
+ *     meta/ctrl code. */
 #ifndef M
 # ifndef NHSTDC
 #  define M(c)		(0x80 | (c))
@@ -1351,209 +1895,354 @@ int final;
 #  define M(c)		((c) - 128)
 # endif /* NHSTDC */
 #endif
+#define ISMETA(c) (((c) & 0x80) != 0)
+#define UNMETA(c) ((c) & 0x7f)
+
 #ifndef C
 #define C(c)		(0x1f & (c))
 #endif
+#define ISCTRL(c) ((uchar)(c) < 0x20)
+#define UNCTRL(c) (ISCTRL(c) ? (0x60 | (c)) : (c))
 
-static const struct func_tab cmdlist[] = {
-	{C('d'), FALSE, dokick}, /* "D" is for door!...?  Msg is in dokick.c */
-#ifdef WIZARD
-	{C('e'), TRUE, wiz_detect},
-	{C('f'), TRUE, wiz_map},
-	{C('g'), TRUE, wiz_genesis},
-	{C('i'), TRUE, wiz_identify},
-#endif
-	{C('l'), TRUE, doredraw}, /* if number_pad is set */
-#ifdef WIZARD
-	{C('o'), TRUE, wiz_where},
-#endif
-	{C('p'), TRUE, doprev_message},
-	{C('r'), TRUE, doredraw},
-	{C('t'), TRUE, dotele},
-#ifdef WIZARD
-	{C('v'), TRUE, wiz_level_tele},
-	{C('w'), TRUE, wiz_wish},
-#endif
-	{C('x'), TRUE, doattributes},
+/* maps extended ascii codes for key presses to extended command entries in extcmdlist */
+static struct key_tab cmdlist[256];
+
+/* list built upon option loading; holds list of keys to be rebound later
+ * see "crappy hack" below */
+static struct binding_list_tab *bindinglist = NULL;
+
+#define AUTOCOMPLETE TRUE
+#define IFBURIED TRUE
+
+#define EXTCMDLIST_SIZE (sizeof(extcmdlist) / sizeof(extcmdlist[1]))
+
+struct ext_func_tab extcmdlist[] = {
+	{"apply", "apply (use) a tool (pick-axe, key, lamp...)", doapply, !IFBURIED},
+	{"attributes", "show your attributes (intrinsic ones included in debug or explore mode)", doattributes, IFBURIED},
+	{"close", "close a door", doclose, !IFBURIED},
+	{"cast", "zap (cast) a spell", docast, IFBURIED},
+	{"discoveries", "show what object types have been discovered", dodiscovered, IFBURIED},
+	{"down", "go down a staircase", dodown, !IFBURIED},
+	{"drop", "drop an item", dodrop, !IFBURIED},
+	{"dropall", "drop specific item types", doddrop, !IFBURIED},
+	{"takeoffall", "remove all armor", doddoremarm, !IFBURIED},
+	{"inventory", "show your inventory", ddoinv, IFBURIED},
+	{"quaff", "quaff (drink) something", dodrink, !IFBURIED},
+	{"#", "perform an extended command", doextcmd, IFBURIED},
+	{"updatestatus", "update status lines", force_bot, IFBURIED},
+	{"travel", "Travel to a specific location", dotravel, !IFBURIED},
+	{"eat", "eat something", doeat, !IFBURIED},
+	{"engrave", "engrave writing on the floor", doengrave, !IFBURIED},
+	{"fire", "fire ammunition from quiver", dofire, !IFBURIED},
+	{"history", "show long version and game history", dohistory, IFBURIED},
+	{"help", "give a help message", dohelp, IFBURIED},
+	{"seetrap", "show the type of a trap", doidtrap, IFBURIED},
+	{"kick", "kick something", dokick, !IFBURIED},
+	{"look", "look at what is here", dolook, IFBURIED},
+	{"call", "call (name) a particular monster", do_naming_mname, IFBURIED},
+	{"callold", "call (name) a particular monster (vanilla)", do_mname, IFBURIED},
+	{"wait", "rest one move while doing nothing", donull, IFBURIED},
+	{"previous", "toggle through previously displayed game messages", doprev_message, IFBURIED},
+	{"open", "open a door", doopen, !IFBURIED},
+	{"pickup", "pick up things at the current location", dopickup, !IFBURIED},
+	{"pay", "pay your shopping bill", dopay, !IFBURIED},
+	{"puton", "put on an accessory (ring amulet, etc)", doputon, !IFBURIED},
+	{"seeweapon", "show the weapon currently wielded", doprwep, IFBURIED},
+	{"seearmor", "show the armor currently worn", doprarm, IFBURIED},
+	{"seerings", "show the ring(s) currently worn", doprring, IFBURIED},
+	{"seeamulet", "show the amulet currently worn", dopramulet, IFBURIED},
+	{"seetools", "show the tools currently in use", doprtool, IFBURIED},
+	{"seeall", "show all equipment in use (generally, ),[,=,\",( commands", doprinuse, IFBURIED},
+	{"seegold", "count your gold", doprgold, IFBURIED},
+	{"glance", "show what type of thing a map symbol on the level corresponds to", doquickwhatis, IFBURIED},
+	{"remove", "remove an accessory (ring, amulet, etc)", doremring, !IFBURIED},
+	{"read", "read a scroll or spellbook", doread, !IFBURIED},
+	{"redraw", "redraw screen", doredraw, IFBURIED},
 #ifdef SUSPEND
-	{C('z'), TRUE, dosuspend},
-#endif
-	{'a', FALSE, doapply},
-	{'A', FALSE, doddoremarm},
-	{M('a'), TRUE, doorganize},
-/*	'b', 'B' : go sw */
-	{'c', FALSE, doclose},
-	{'C', TRUE, do_mname},
-	{M('c'), TRUE, dotalk},
-	{'d', FALSE, dodrop},
-	{'D', FALSE, doddrop},
-	{M('d'), FALSE, dodip},
-	{'e', FALSE, doeat},
-	{'E', FALSE, doengrave},
-	{M('e'), TRUE, enhance_weapon_skill},
-	{'f', FALSE, dofire},
-/*	'F' : fight (one time) */
-	{M('f'), FALSE, doforce},
-/*	'g', 'G' : multiple go */
-/*	'h', 'H' : go west */
-	{'h', TRUE, dohelp}, /* if number_pad is set */
-	{'i', TRUE, ddoinv},
-	{'I', TRUE, dotypeinv},		/* Robert Viduya */
-	{M('i'), TRUE, doinvoke},
-/*	'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N' : move commands */
-	{'j', FALSE, dojump}, /* if number_pad is on */
-	{M('j'), FALSE, dojump},
-	{'k', FALSE, dokick}, /* if number_pad is on */
-	{'l', FALSE, doloot}, /* if number_pad is on */
-	{M('l'), FALSE, doloot},
-/*	'n' prefixes a count if number_pad is on */
-	{M('m'), TRUE, domonability},
-	{'N', TRUE, ddocall}, /* if number_pad is on */
-	{M('n'), TRUE, ddocall},
-	{M('N'), TRUE, ddocall},
-	{'o', FALSE, doopen},
-	{'O', TRUE, doset},
-	{M('o'), FALSE, dosacrifice},
-	{'p', FALSE, dopay},
-	{'P', FALSE, doputon},
-	{M('p'), TRUE, dopray},
-	{'q', FALSE, dodrink},
-	{'Q', FALSE, dowieldquiver},
-	{M('q'), TRUE, done2},
-	{'r', FALSE, doread},
-	{'R', FALSE, doremring},
-	{M('r'), FALSE, dorub},
-	{'s', TRUE, dosearch, "searching"},
-	{'S', TRUE, dosave},
-	{M('s'), FALSE, dosit},
-	{'t', FALSE, dothrow},
-	{'T', FALSE, dotakeoff},
-	{M('t'), TRUE, doturn},
-/*	'u', 'U' : go ne */
-	{'u', FALSE, dountrap}, /* if number_pad is on */
-	{M('u'), FALSE, dountrap},
-	{'v', TRUE, doversion},
-	{'V', TRUE, dohistory},
-	{M('v'), TRUE, doextversion},
-	{'w', FALSE, dowield},
-	{'W', FALSE, dowear},
-	{M('w'), FALSE, dowipe},
-	{'x', FALSE, doswapweapon},
-	{'X', TRUE, enter_explore_mode},
-/*	'y', 'Y' : go nw */
-	{'z', FALSE, dozap},
-	{'Z', TRUE, docast},
-	{'<', FALSE, doup},
-	{'>', FALSE, dodown},
-	{'/', TRUE, dowhatis},
-	{'&', TRUE, dowhatdoes},
-	{'?', TRUE, dohelp},
-	{M('?'), TRUE, doextlist},
+	{"suspend", "suspend game (only if defined)", dosuspend, IFBURIED},
+#endif /* SUSPEND */
+	{"setoptions", "show option settings, possibly change them", doset, IFBURIED},
+	{"search", "search for traps and secret doors", dosearch, IFBURIED, !AUTOCOMPLETE, "searching"},
+	{"save", "save the game", dosave, IFBURIED},
+	{"swap", "swap wielded and secondary weapons", doswapweapon, !IFBURIED},
 #ifdef SHELL
-	{'!', TRUE, dosh},
+	{"shell", "do a shell escape (only if defined)", dosh, IFBURIED},
 #endif
-	{'.', TRUE, donull, "waiting"},
-	{' ', TRUE, donull, "waiting"},
-	{',', FALSE, dopickup},
-	{':', TRUE, dolook},
-	{';', TRUE, doquickwhatis},
-	{'^', TRUE, doidtrap},
-	{'\\', TRUE, dodiscovered},		/* Robert Viduya */
-	{'@', TRUE, dotogglepickup},
-	{M('2'), FALSE, dotwoweapon},
-	{WEAPON_SYM,  TRUE, doprwep},
-	{ARMOR_SYM,  TRUE, doprarm},
-	{RING_SYM,  TRUE, doprring},
-	{AMULET_SYM, TRUE, dopramulet},
-	{TOOL_SYM, TRUE, doprtool},
-	{'*', TRUE, doprinuse},	/* inventory of all equipment in use */
-	{GOLD_SYM, TRUE, doprgold},
-	{SPBOOK_SYM, TRUE, dovspell},			/* Mike Stephenson */
-	{'#', TRUE, doextcmd},
-	{'_', TRUE, dotravel},
-	{0,0,0,0}
-};
-
-struct ext_func_tab extcmdlist[] = {
-	{"adjust", "adjust inventory letters", doorganize, TRUE},
-	{"chat", "talk to someone", dotalk, TRUE},	/* converse? */
-	{"conduct", "list which challenges you have adhered to", doconduct, TRUE},
-	{"dip", "dip an object into something", dodip, FALSE},
-	{"enhance", "advance or check weapons skills", enhance_weapon_skill,
-							TRUE},
-	{"force", "force a lock", doforce, FALSE},
-	{"invoke", "invoke an object's powers", doinvoke, TRUE},
-	{"jump", "jump to a location", dojump, FALSE},
-	{"loot", "loot a box on the floor", doloot, FALSE},
-	{"monster", "use a monster's special ability", domonability, TRUE},
-	{"name", "name an item or type of object", ddocall, TRUE},
-	{"offer", "offer a sacrifice to the gods", dosacrifice, FALSE},
-	{"pray", "pray to the gods for help", dopray, TRUE},
-	{"quit", "exit without saving current game", done2, TRUE},
+	{"throw", "throw something", dothrow, !IFBURIED},
+	{"takeoff", "take off one piece of armor", dotakeoff, !IFBURIED},
+	{"teleport", "teleport around level", dotele, IFBURIED},
+	{"inventoryall", "inventory specific item types", dotypeinv, IFBURIED},
+	{"autopickup", "toggle the pickup option on/off", dotogglepickup, IFBURIED},
+	{"up", "go up a staircase", doup, !IFBURIED},
+	{"version", "show version", doversion, IFBURIED},
+	{"seespells", "list known spells", dovspell, IFBURIED},
+	{"quiver", "select ammunition for quiver", dowieldquiver, !IFBURIED},
+	{"whatis", "show what type of thing a symbol corresponds to", dowhatis, IFBURIED},
+	{"whatdoes", "tell what a command does", dowhatdoes, IFBURIED},
+	{"wield", "wield (put in use) a weapon", dowield, !IFBURIED},
+	{"wear", "wear a piece of armor", dowear, !IFBURIED},
+	{"zap", "zap a wand", dozap, !IFBURIED},
+	{"explore_mode", "enter explore (discovery) mode (only if defined)", enter_explore_mode, IFBURIED},
+
+	{"adjust", "adjust inventory letters", doorganize, IFBURIED, AUTOCOMPLETE},
+	{"chat", "talk to someone", dotalk, IFBURIED, AUTOCOMPLETE},	/* converse? */
+	{"conduct", "list which challenges you have adhered to", doconduct, IFBURIED, AUTOCOMPLETE},
+	{"dip", "dip an object into something", dodip, !IFBURIED, AUTOCOMPLETE},
+	{"enhance", "advance or check weapons skills", enhance_weapon_skill, IFBURIED, AUTOCOMPLETE},
+	{"force", "force a lock", doforce, !IFBURIED, AUTOCOMPLETE},
+	{"invoke", "invoke an object's powers", doinvoke, IFBURIED, AUTOCOMPLETE},
+	{"jump", "jump to a location", dojump, !IFBURIED, AUTOCOMPLETE},
+	{"loot", "loot a box on the floor", doloot, !IFBURIED, AUTOCOMPLETE},
+	{"monster", "use a monster's special ability", domonability, IFBURIED, AUTOCOMPLETE},
+	{"name", "name an item or type of object", do_naming_ddocall, IFBURIED, AUTOCOMPLETE},
+	{"nameold", "name an item or type of object (vanilla)", ddocall, IFBURIED},
+	{"offer", "offer a sacrifice to the gods", dosacrifice, !IFBURIED, AUTOCOMPLETE},
+	{"pray", "pray to the gods for help", dopray, IFBURIED, AUTOCOMPLETE},
+	{"quit", "exit without saving current game", done2, IFBURIED, AUTOCOMPLETE},
 #ifdef STEED
-	{"ride", "ride (or stop riding) a monster", doride, FALSE},
+	{"ride", "ride (or stop riding) a monster", doride, !IFBURIED, AUTOCOMPLETE},
 #endif
-	{"rub", "rub a lamp or a stone", dorub, FALSE},
-	{"sit", "sit down", dosit, FALSE},
-	{"turn", "turn undead", doturn, TRUE},
-	{"twoweapon", "toggle two-weapon combat", dotwoweapon, FALSE},
-	{"untrap", "untrap something", dountrap, FALSE},
-	{"version", "list compile time options for this version of NetHack",
-		doextversion, TRUE},
-	{"wipe", "wipe off your face", dowipe, FALSE},
-	{"?", "get this list of extended commands", doextlist, TRUE},
+	{"rub", "rub a lamp", dorub, !IFBURIED, AUTOCOMPLETE},
+	{"sit", "sit down", dosit, !IFBURIED, AUTOCOMPLETE},
+	{"turn", "turn undead", doturn, IFBURIED, AUTOCOMPLETE},
+	{"twoweapon", "toggle two-weapon combat", dotwoweapon, !IFBURIED, AUTOCOMPLETE},
+	{"untrap", "untrap something", dountrap, !IFBURIED, AUTOCOMPLETE},
+	{"versionext", "list compile time options for this version of NetHack",
+		doextversion, IFBURIED, AUTOCOMPLETE},
+	{"wipe", "wipe off your face", dowipe, !IFBURIED, AUTOCOMPLETE},
+	{"?", "get this list of extended commands", doextlist, IFBURIED, AUTOCOMPLETE},
 #if defined(WIZARD)
-	/*
-	 * There must be a blank entry here for every entry in the table
-	 * below.
-	 */
-	{(char *)0, (char *)0, donull, TRUE},
-	{(char *)0, (char *)0, donull, TRUE},
+ 	/*
+ 	 * There must be a blank entry here for every entry in the table
+ 	 * below.
+ 	 */
+	{(char *)0, (char *)0, donull, TRUE}, /* #levelchange */
+	{(char *)0, (char *)0, donull, TRUE}, /* #lightsources */
 #ifdef DEBUG_MIGRATING_MONS
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #migratemons */
 #endif
-	{(char *)0, (char *)0, donull, TRUE},
-	{(char *)0, (char *)0, donull, TRUE},
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #monpolycontrol */
+	{(char *)0, (char *)0, donull, TRUE}, /* #panic */
+	{(char *)0, (char *)0, donull, TRUE}, /* #polyself */
 #ifdef PORT_DEBUG
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #portdebug */
 #endif
-	{(char *)0, (char *)0, donull, TRUE},
-        {(char *)0, (char *)0, donull, TRUE},
-	{(char *)0, (char *)0, donull, TRUE},
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #seenv */
+	{(char *)0, (char *)0, donull, TRUE}, /* #showkills (showborn patch) */
+	{(char *)0, (char *)0, donull, TRUE}, /* #stats */
+	{(char *)0, (char *)0, donull, TRUE}, /* #timeout */
+	{(char *)0, (char *)0, donull, TRUE}, /* #vision */
+	{(char *)0, (char *)0, donull, TRUE}, /* #dump_map */
 #ifdef DEBUG
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #wizdebug */
 #endif
-	{(char *)0, (char *)0, donull, TRUE},
+	{(char *)0, (char *)0, donull, TRUE}, /* #wmode */
+	{(char *)0, (char *)0, donull, TRUE}, /* #detect */
+	{(char *)0, (char *)0, donull, TRUE}, /* #map */
+	{(char *)0, (char *)0, donull, TRUE}, /* #genesis */
+	{(char *)0, (char *)0, donull, TRUE}, /* #identify */
+	{(char *)0, (char *)0, donull, TRUE}, /* #levelport */
+	{(char *)0, (char *)0, donull, TRUE}, /* #wish */
+	{(char *)0, (char *)0, donull, TRUE}, /* #where */
 #endif
 	{(char *)0, (char *)0, donull, TRUE}	/* sentinel */
 };
 
 #if defined(WIZARD)
-static const struct ext_func_tab debug_extcmdlist[] = {
-	{"levelchange", "change experience level", wiz_level_change, TRUE},
-	{"lightsources", "show mobile light sources", wiz_light_sources, TRUE},
+static struct ext_func_tab debug_extcmdlist[] = {
+	{"levelchange", "change experience level", wiz_level_change, IFBURIED, AUTOCOMPLETE},
+	{"lightsources", "show mobile light sources", wiz_light_sources, IFBURIED, AUTOCOMPLETE},
 #ifdef DEBUG_MIGRATING_MONS
-	{"migratemons", "migrate n random monsters", wiz_migrate_mons, TRUE},
+	{"migratemons", "migrate n random monsters", wiz_migrate_mons, IFBURIED, AUTOCOMPLETE},
 #endif
-	{"monpolycontrol", "control monster polymorphs", wiz_mon_polycontrol, TRUE},
-	{"panic", "test panic routine (fatal to game)", wiz_panic, TRUE},
-	{"polyself", "polymorph self", wiz_polyself, TRUE},
+	{"monpolycontrol", "control monster polymorphs", wiz_mon_polycontrol, IFBURIED, AUTOCOMPLETE},
+	{"panic", "test panic routine (fatal to game)", wiz_panic, IFBURIED, AUTOCOMPLETE},
+	{"polyself", "polymorph self", wiz_polyself, IFBURIED, AUTOCOMPLETE},
 #ifdef PORT_DEBUG
-	{"portdebug", "wizard port debug command", wiz_port_debug, TRUE},
+	{"portdebug", "wizard port debug command", wiz_port_debug, IFBURIED, AUTOCOMPLETE},
 #endif
-	{"seenv", "show seen vectors", wiz_show_seenv, TRUE},
-	{"stats", "show memory statistics", wiz_show_stats, TRUE},
-	{"timeout", "look at timeout queue", wiz_timeout_queue, TRUE},
-	{"vision", "show vision array", wiz_show_vision, TRUE},
+	{"seenv", "show seen vectors", wiz_show_seenv, IFBURIED, AUTOCOMPLETE},
+	{"stats", "show memory statistics", wiz_show_stats, IFBURIED, AUTOCOMPLETE},
+	{"timeout", "look at timeout queue", wiz_timeout_queue, IFBURIED, AUTOCOMPLETE},
+	{"vision", "show vision array", wiz_show_vision, IFBURIED, AUTOCOMPLETE},
+	{"showkills", "show list of monsters killed", wiz_showkills, IFBURIED, AUTOCOMPLETE},
+	{"dump_map", "dump map glyphs into a file", wiz_mk_mapglyphdump, IFBURIED, AUTOCOMPLETE},
 #ifdef DEBUG
-	{"wizdebug", "wizard debug command", wiz_debug_cmd, TRUE},
+	{"wizdebug", "wizard debug command", wiz_debug_cmd, IFBURIED, AUTOCOMPLETE},
 #endif
-	{"wmode", "show wall modes", wiz_show_wmodes, TRUE},
-	{(char *)0, (char *)0, donull, TRUE}
+	{"wmode", "show wall modes", wiz_show_wmodes, IFBURIED, AUTOCOMPLETE},
+	{"detect", "detect secret doors and traps", wiz_detect, IFBURIED},
+	{"map", "do magic mapping", wiz_map, IFBURIED},
+	{"genesis", "create monster", wiz_genesis, IFBURIED},
+	{"identify", "identify items in pack", wiz_identify, IFBURIED},
+	{"levelport", "to trans-level teleport", wiz_level_tele, IFBURIED},
+	{"wish", "make wish", wiz_wish, IFBURIED},
+	{"where", "tell locations of special levels", wiz_where, IFBURIED},
+	{(char *)0, (char *)0, donull, IFBURIED}
 };
 
+static void
+bind_key(key, command)
+     unsigned char key;
+     char* command;
+{
+	struct ext_func_tab * extcmd;
+
+	/* special case: "nothing" is reserved for unbinding */
+	if (!strcmp(command, "nothing")) {
+		cmdlist[key].bind_cmd = NULL;
+		return;
+	}
+
+	for(extcmd = extcmdlist; extcmd->ef_txt; extcmd++) {
+		if (strcmp(command, extcmd->ef_txt)) continue;
+		cmdlist[key].bind_cmd = extcmd;
+		return;
+	}
+
+	pline("Bad command %s matched with key %c (ASCII %i). "
+	      "Ignoring command.\n", command, key, key);
+}
+
+static void
+init_bind_list(void)
+{
+	bind_key(C('d'), "kick" ); /* "D" is for door!...?  Msg is in dokick.c */
+#ifdef WIZARD
+	if (wizard) {
+		bind_key(C('e'), "detect" );
+		bind_key(C('f'), "map" );
+		bind_key(C('g'), "genesis" );
+		bind_key(C('i'), "identify" );
+		bind_key(C('o'), "where" );
+		bind_key(C('v'), "levelport" );
+		bind_key(C('w'), "wish" );
+	}
+#endif
+	bind_key(C('l'), "redraw" ); /* if number_pad is set */
+	bind_key(C('p'), "previous" );
+	bind_key(C('r'), "redraw" );
+	bind_key(C('t'), "teleport" );
+	bind_key(C('x'), "attributes" );
+#ifdef SUSPEND
+	bind_key(C('z'), "suspend" );
+#endif
+	bind_key('a',    "apply" );
+	bind_key('A',    "takeoffall" );
+	bind_key(M('a'), "adjust" );
+	/*       'b', 'B' : go sw */
+	bind_key('c',    "close" );
+	bind_key('C',    "call" );
+	bind_key(M('c'), "chat" );
+	bind_key('d',    "drop" );
+	bind_key('D',    "dropall" );
+	bind_key(M('d'), "dip" );
+	bind_key('e',    "eat" );
+	bind_key('E',    "engrave" );
+	bind_key(M('e'), "enhance" );
+	bind_key('f',    "fire" );
+	/*       'F' : fight (one time) */
+	bind_key(M('f'), "force" );
+	/*       'g', 'G' : multiple go */
+	/*       'h', 'H' : go west */
+	bind_key('h',    "help" ); /* if number_pad is set */
+	bind_key('i',    "inventory" );
+	bind_key('I',    "inventoryall" ); /* Robert Viduya */
+	bind_key(M('i'), "invoke" );
+	bind_key('j',    "jump" );
+	/*       'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N' : move commands */
+	bind_key(M('j'), "jump" ); /* if number_pad is on */
+	bind_key('k',    "kick" ); /* if number_pad is on */
+	bind_key('l',    "loot" ); /* if number_pad is on */
+	bind_key(M('l'), "loot" );
+	bind_key(M('m'), "monster" );
+	bind_key('N',    "name" );
+	/*       'n' prefixes a count if number_pad is on */
+	bind_key(M('n'), "name" );
+	bind_key(M('N'), "name" ); /* if number_pad is on */
+	bind_key('o',    "open" );
+	bind_key('O',    "setoptions" );
+	bind_key(M('o'), "offer" );
+	bind_key('p',    "pay" );
+	bind_key('P',    "puton" );
+	bind_key(M('p'), "pray" );
+	bind_key('q',    "quaff" );
+	bind_key('Q',    "quiver" );
+	bind_key(M('q'), "quit" );
+	bind_key('r',    "read" );
+	bind_key('R',    "remove" );
+	bind_key(M('r'), "rub" );
+	bind_key('s',    "search" );
+	bind_key('S',    "save" );
+	bind_key(M('s'), "sit" );
+	bind_key('t',    "throw" );
+	bind_key('T',    "takeoff" );
+	bind_key(M('t'), "turn" );
+	/*        'u', 'U' : go ne */
+	bind_key('u',    "untrap" ); /* if number_pad is on */
+	bind_key(M('u'), "untrap" );
+	bind_key('v',    "version" );
+	bind_key('V',    "history" );
+	bind_key(M('v'), "versionext" );
+	bind_key('w',    "wield" );
+	bind_key('W',    "wear" );
+	bind_key(M('w'), "wipe" );
+	bind_key('x',    "swap" );
+	bind_key('X',    "twoweapon" );
+	/*bind_key('X',    "explore_mode" );*/
+	/*        'y', 'Y' : go nw */
+#ifdef STICKY_COMMAND
+	bind_key(M('y'), "sticky" );
+#endif /* STICKY_COMMAND */
+	bind_key('z',    "zap" );
+	bind_key('Z',    "cast" );
+	bind_key('<',    "up" );
+	bind_key('>',    "down" );
+	bind_key('/',    "whatis" );
+	bind_key('&',    "whatdoes" );
+	bind_key('?',    "help" );
+	bind_key(M('?'), "?" );
+#ifdef SHELL
+	bind_key('!',    "shell" );
+#endif
+	bind_key('.',    "wait" );
+	bind_key(' ',    "wait" );
+	bind_key(',',    "pickup" );
+	bind_key(':',    "look" );
+	bind_key(';',    "glance" );
+	bind_key('^',    "seetrap" );
+	bind_key('\\',   "discoveries" ); /* Robert Viduya */
+	bind_key('@',    "autopickup" );
+	bind_key(M('2'), "twoweapon" );
+	bind_key(WEAPON_SYM, "seeweapon" );
+	bind_key(ARMOR_SYM,  "seearmor" );
+	bind_key(RING_SYM,   "seerings" );
+	bind_key(AMULET_SYM, "seeamulet" );
+	bind_key(TOOL_SYM,   "seetools" );
+	bind_key('*',        "seeall" ); /* inventory of all equipment in use */
+	bind_key(GOLD_SYM,   "seegold" );
+	bind_key(SPBOOK_SYM, "seespells" ); /* Mike Stephenson */
+	bind_key('#', "#");
+	bind_key('_', "travel");
+}
+
+/* takes the list of bindings loaded from the options file, and changes cmdlist
+ * to match it */
+static void
+change_bind_list(void)
+{
+	struct binding_list_tab *binding;
+
+	/* TODO: they must be loaded forward, not backward as they are now */
+	while ((binding = bindinglist)) {
+		bindinglist = bindinglist->next;
+		bind_key(binding->key, binding->extcmd);
+		free(binding->extcmd);
+		free(binding);
+	}
+}
+
+
 /*
  * Insert debug commands into the extended command list.  This function
  * assumes that the last entry will be the help entry.
@@ -1561,27 +2250,141 @@ static const struct ext_func_tab debug_e
  * You must add entries in ext_func_tab every time you add one to the
  * debug_extcmdlist().
  */
-void
+static void
 add_debug_extended_commands()
 {
 	int i, j, k, n;
 
 	/* count the # of help entries */
-	for (n = 0; extcmdlist[n].ef_txt[0] != '?'; n++)
-	    ;
+	for (n = 0; extcmdlist[n].ef_txt; n++) ;
 
 	for (i = 0; debug_extcmdlist[i].ef_txt; i++) {
-	    for (j = 0; j < n; j++)
-		if (strcmp(debug_extcmdlist[i].ef_txt, extcmdlist[j].ef_txt) < 0) break;
-
-	    /* insert i'th debug entry into extcmdlist[j], pushing down  */
-	    for (k = n; k >= j; --k)
-		extcmdlist[k+1] = extcmdlist[k];
-	    extcmdlist[j] = debug_extcmdlist[i];
-	    n++;	/* now an extra entry */
+	    extcmdlist[n + i] = debug_extcmdlist[i];
 	}
 }
 
+/* list all keys and their bindings, like dat/hh but dynamic */
+void
+dokeylist(void)
+{
+	char	buf[BUFSZ], buf2[BUFSZ];
+	uchar	key;
+	boolean keys_used[256] = {0};
+	register const char*	dir_keys;
+	winid	datawin;
+	int	i;
+	char*	dir_desc[10] = {"move west",
+				"move northwest",
+				"move north",
+				"move northeast",
+				"move east",
+				"move southeast",
+				"move south",
+				"move southwest",
+				"move downward",
+				"move upward"};
+	char*	misc_desc[MISC_CMD_COUNT] = 
+		{"rush until something interesting is seen",
+		 "run until something extremely interesting is seen",
+		 "fight even if you don't see a monster",
+		 "move without picking up objects/fighting",
+		 "run without picking up objects/fighting",
+		 "escape from the current query/action"
+#ifdef REDO
+		 , "redo the previous command"
+#endif
+		};
+
+
+	datawin = create_nhwindow(NHW_TEXT);
+	putstr(datawin, 0, "");
+	putstr(datawin, 0, "            Full Current Key Bindings List");
+	putstr(datawin, 0, "");
+
+	/* directional keys */
+	if (iflags.num_pad) dir_keys = ndir;
+	else dir_keys = sdir;
+	putstr(datawin, 0, "Directional keys:");
+	{
+	  Sprintf(buf, "  %c %c %c", dir_keys[1], dir_keys[2], dir_keys[3]);
+	  putstr(datawin, 0, buf);
+	  putstr(datawin, 0, "   \\|/");
+	  Sprintf(buf, "  %c-.-%c", dir_keys[0], dir_keys[4]);
+	  putstr(datawin, 0, buf);
+	  putstr(datawin, 0, "   /|\\");
+	  Sprintf(buf, "  %c %c %c", dir_keys[7], dir_keys[6], dir_keys[5]);
+	  putstr(datawin, 0, buf);
+	  putstr(datawin, 0, "");
+	  Sprintf(buf, "    %c  up", dir_keys[9]);
+	  putstr(datawin, 0, buf);
+	  Sprintf(buf, "    %c  down", dir_keys[8]);
+	  putstr(datawin, 0, buf);
+	  putstr(datawin, 0, "");
+	}
+	for (i = 0; i < 10; i++) {
+		key = dir_keys[i];
+		keys_used[key] = TRUE;
+		if (!iflags.num_pad) {
+			keys_used[toupper(key)] = TRUE;
+			keys_used[C(key)] = TRUE;
+		}
+		/*
+		Sprintf(buf, "%c\t%s", key, dir_desc[i]);
+		putstr(datawin, 0, buf);
+		*/
+	}
+	if (!iflags.num_pad) {
+		putstr(datawin, 0, "Shift-<direction> will move in specified direction until you hit");
+		putstr(datawin, 0, "        a wall or run into something.");
+		putstr(datawin, 0, "Ctrl-<direction> will run in specified direction until something");
+		putstr(datawin, 0, "        very interesting is seen.");
+	}
+	putstr(datawin, 0, "");
+
+	/* special keys -- theoretically modifiable but many are still hard-coded*/
+	putstr(datawin, 0, "Miscellaneous keys:");
+	for (i = 0; i < MISC_CMD_COUNT; i++) {
+		key = misc_cmds[i];
+		keys_used[key] = TRUE;
+		Sprintf(buf, "%s\t%s", key2txt(key, buf2), misc_desc[i]);
+		putstr(datawin, 0, buf);
+	}
+	putstr(datawin, 0, "");
+
+	/* more special keys -- all hard-coded */
+#ifndef NO_SIGNAL
+	putstr(datawin, 0, "^c\tbreak out of nethack (SIGINT)");
+	keys_used[C('c')] = TRUE;
+	if (!iflags.num_pad) putstr(datawin, 0, "");
+#endif
+	if (iflags.num_pad) {
+		putstr(datawin, 0, "-\tforce fight (same as above)");
+		putstr(datawin, 0, "5\trun (same as above)");
+		putstr(datawin, 0, "0\tinventory (as #inventory)");
+		keys_used['-'] = keys_used['5'] = keys_used['0'] = TRUE;
+		putstr(datawin, 0, "");
+	}
+
+	/* command keys - can be rebound or remapped*/
+	putstr(datawin, 0, "Command keys:");
+	for(i=0; i<=255; i++) {
+		struct ext_func_tab * extcmd;
+		char* mapping;
+		key = i;
+		/* JDS: not the most efficient way, perhaps */
+		if (keys_used[i]) continue;
+		if (key == ' ' && !flags.rest_on_space) continue;
+		if ((extcmd = cmdlist[i].bind_cmd)) {
+			Sprintf(buf, "%s\t%s", key2txt(key, buf2),
+				extcmd->ef_desc);
+			putstr(datawin, 0, buf);
+		}
+	}
+	putstr(datawin, 0, "");
+
+	display_nhwindow(datawin, FALSE);
+	destroy_nhwindow(datawin);
+}
 
 static const char template[] = "%-18s %4ld  %6ld";
 static const char count_str[] = "                   count  bytes";
@@ -1796,8 +2599,230 @@ wiz_migrate_mons()
 
 #endif /* WIZARD */
 
-#define unctrl(c)	((c) <= C('z') ? (0x60 | (c)) : (c))
-#define unmeta(c)	(0x7f & (c))
+static int
+compare_commands(_cmd1, _cmd2)
+     /* a wrapper function for strcmp.  Can this be done more simply? */
+     void *_cmd1, *_cmd2;
+{
+	struct ext_func_tab *cmd1 = _cmd1, *cmd2 = _cmd2;
+
+	return strcmp(cmd1->ef_txt, cmd2->ef_txt);
+}
+
+void
+commands_init(void)
+{
+	int count = 0;
+
+#ifdef WIZARD
+	if (wizard) add_debug_extended_commands();
+#endif
+	while(extcmdlist[count].ef_txt) count++;
+
+	qsort(extcmdlist, count, sizeof(struct ext_func_tab),
+	      &compare_commands);
+
+	init_bind_list();	/* initialize all keyboard commands */
+	change_bind_list();	/* change keyboard commands based on options */
+}
+
+/* returns a one-byte character from the text (it may massacre the txt
+ * buffer) */
+char
+txt2key(txt)
+     char* txt;
+{
+	txt = stripspace(txt);
+	if (!*txt) return 0;
+
+	/* simple character */
+	if (!txt[1]) return txt[0];
+
+	/* a few special entries */
+	if (!strcmp(txt, "<enter>")) return '\n';
+	if (!strcmp(txt, "<space>")) return ' ';
+	if (!strcmp(txt, "<esc>"))   return '\033';
+
+	/* control and meta keys */
+	switch (*txt) {
+	    case 'm': /* can be mx, Mx, m-x, M-x */
+	    case 'M':
+		    txt++;
+		    if(*txt == '-' && txt[1]) txt++;
+		    if (txt[1]) return 0;
+		    return M( *txt );
+	    case 'c': /* can be cx, Cx, ^x, c-x, C-x, ^-x */
+	    case 'C':
+	    case '^':
+		    txt++;
+		    if(*txt == '-' && txt[1]) txt++;
+		    if (txt[1]) return 0;
+		    return C( *txt );
+	}
+
+	/* ascii codes: must be three-digit decimal */
+	if (*txt >= '0' && *txt <= '9') {
+		uchar key = 0;
+		int i;
+		for(i = 0; i < 3; i++) {
+			if(txt[i]<'0' || txt[i]>'9') return 0;
+			key = 10 * key + txt[i]-'0';
+		}
+		return key;
+	}
+
+	return 0;
+}
+
+/* returns the text for a one-byte encoding
+ * must be shorter than a tab for proper formatting */
+char*
+key2txt(c, txt)
+     char c;
+     char* txt; /* sufficiently long buffer */
+{
+	if (c == ' ')
+		Sprintf(txt, "<space>");
+	else if (c == '\033')
+		Sprintf(txt, "<esc>");
+	else if (c == '\n')
+		Sprintf(txt, "<enter>");
+	else if (ISCTRL(c))
+		Sprintf(txt, "^%c", UNCTRL(c));
+	else if (ISMETA(c))
+		Sprintf(txt, "M-%c", UNMETA(c));
+	else if (c >= 33 && c <= 126)
+		Sprintf(txt, "%c", c);		/* regular keys: ! through ~ */
+	else
+		Sprintf(txt, "A-%i", c);	/* arbitrary ascii combinations */
+	return txt;
+}
+
+/* returns the text for a string of one-byte encodings */
+char*
+str2txt(s, txt)
+     char* s;
+     char* txt;
+{
+	char* buf = txt;
+	
+	while (*s) {
+		(void) key2txt(*s, buf);
+		buf = eos(buf);
+		*buf = ' ';
+		buf++;
+		*buf = 0;
+		s++;
+      	}
+	return txt;
+}
+
+
+/* strips leading and trailing whitespace */
+char*
+stripspace(txt)
+     char* txt;
+{
+	char* end;
+	while (isspace(*txt)) txt++;
+	end = eos(txt);
+	while (--end >= txt && isspace(*end)) *end = 0;
+	return txt;
+}
+
+void
+parsebindings(bindings)
+     /* closely follows parseoptions in options.c */
+     char* bindings;
+{
+	char *bind;
+	char key;
+	struct binding_list_tab *newbinding = NULL;
+
+	/* break off first binding from the rest; parse the rest */
+	if ((bind = index(bindings, ',')) != 0) {
+		*bind++ = 0;
+		parsebindings(bind);
+	}
+ 
+	/* parse a single binding: first split around : */
+	if (! (bind = index(bindings, ':'))) return; /* it's not a binding */
+	*bind++ = 0;
+
+	/* read the key to be bound */
+	key = txt2key(bindings);
+	if (!key) {
+		raw_printf("Bad binding %s.", bindings);
+		wait_synch();
+		return;
+	}
+	
+	/* JDS: crappy hack because wizard mode information
+	 * isn't read until _after_ key bindings are read,
+	 * and to change this would cause numerous side effects.
+	 * instead, I save a list of rebindings, which are later
+	 * bound. */
+	bind = stripspace(bind);
+	newbinding = (struct binding_list_tab *)alloc(sizeof(*newbinding));
+	newbinding->key = key;
+	newbinding->extcmd = (char *)alloc(strlen(bind)+1);
+	strcpy(newbinding->extcmd, bind);;
+	newbinding->next = bindinglist;
+	bindinglist = newbinding;
+}
+ 
+void
+parseautocomplete(autocomplete,condition)
+     /* closesly follows parsebindings and parseoptions */
+     char* autocomplete;
+     boolean condition;
+{
+	register char *autoc;
+	int i;
+	
+	/* break off first autocomplete from the rest; parse the rest */
+	if ((autoc = index(autocomplete, ','))
+	    || (autoc = index(autocomplete, ':'))) {
+		*autoc++ = 0;
+		parseautocomplete(autoc, condition);
+	}
+
+	/* strip leading and trailing white space */
+	autocomplete = stripspace(autocomplete);
+	
+	if (!*autocomplete) return;
+
+	/* take off negations */
+	while (*autocomplete == '!') {
+		/* unlike most options, a leading "no" might actually be a part of
+		 * the extended command.  Thus you have to use ! */
+		autocomplete++;
+		condition = !condition;
+	}
+
+	/* find and modify the extended command */
+	/* JDS: could be much faster [O(log n) vs O(n)] if done differently */
+	for (i=0; extcmdlist[i].ef_txt; i++) {
+		if (strcmp(autocomplete, extcmdlist[i].ef_txt)) continue;
+		extcmdlist[i].autocomplete = condition;
+		return;
+	}
+
+#ifdef WIZARD
+	/* do the exact same thing with the wizmode list */
+	/* this is a hack because wizard-mode commands haven't been loaded yet when
+	 * this code is run.  See "crappy hack" elsewhere. */
+	for (i=0; debug_extcmdlist[i].ef_txt; i++) {
+		if (strcmp(autocomplete, debug_extcmdlist[i].ef_txt)) continue;
+		debug_extcmdlist[i].autocomplete = condition;
+		return;
+	}
+#endif
+
+	/* not a real extended command */
+	raw_printf ("Bad autocomplete: invalid extended command '%s'.", autocomplete);
+	wait_synch();
+}
 
 
 void
@@ -1812,7 +2837,7 @@ register char *cmd;
 		flags.nopick = 0;
 		cmd = parse();
 	}
-	if (*cmd == '\033') {
+	if (*cmd == DOESCAPE) {
 		flags.move = FALSE;
 		return;
 	}
@@ -1849,74 +2874,67 @@ register char *cmd;
 	/* handle most movement commands */
 	do_walk = do_rush = prefix_seen = FALSE;
 	flags.travel = iflags.travel1 = 0;
-	switch (*cmd) {
-	 case 'g':  if (movecmd(cmd[1])) {
-			flags.run = 2;
-			do_rush = TRUE;
-		    } else
-			prefix_seen = TRUE;
-		    break;
-	 case '5':  if (!iflags.num_pad) break;	/* else FALLTHRU */
-	 case 'G':  if (movecmd(lowc(cmd[1]))) {
-			flags.run = 3;
-			do_rush = TRUE;
-		    } else
-			prefix_seen = TRUE;
-		    break;
-	 case '-':  if (!iflags.num_pad) break;	/* else FALLTHRU */
-	/* Effects of movement commands and invisible monsters:
-	 * m: always move onto space (even if 'I' remembered)
-	 * F: always attack space (even if 'I' not remembered)
-	 * normal movement: attack if 'I', move otherwise
-	 */
-	 case 'F':  if (movecmd(cmd[1])) {
-			flags.forcefight = 1;
-			do_walk = TRUE;
-		    } else
-			prefix_seen = TRUE;
-		    break;
-	 case 'm':  if (movecmd(cmd[1]) || u.dz) {
-			flags.run = 0;
-			flags.nopick = 1;
-			if (!u.dz) do_walk = TRUE;
-			else cmd[0] = cmd[1];	/* "m<" or "m>" */
-		    } else
-			prefix_seen = TRUE;
-		    break;
-	 case 'M':  if (movecmd(lowc(cmd[1]))) {
-			flags.run = 1;
-			flags.nopick = 1;
-			do_rush = TRUE;
-		    } else
-			prefix_seen = TRUE;
-		    break;
-	 case '0':  if (!iflags.num_pad) break;
-		    (void)ddoinv(); /* a convenience borrowed from the PC */
-		    flags.move = FALSE;
-		    multi = 0;
-		    return;
-	 case CMD_TRAVEL:
-		    if (iflags.travelcmd) {
-			    flags.travel = 1;
-			    iflags.travel1 = 1;
-			    flags.run = 8;
-			    flags.nopick = 1;
-			    do_rush = TRUE;
-			    break;
-		    }
-		    /*FALLTHRU*/
-	 default:   if (movecmd(*cmd)) {	/* ordinary movement */
-			flags.run = 0;	/* only matters here if it was 8 */
-			do_walk = TRUE;
-		    } else if (movecmd(iflags.num_pad ?
-				       unmeta(*cmd) : lowc(*cmd))) {
-			flags.run = 1;
-			do_rush = TRUE;
-		    } else if (movecmd(unctrl(*cmd))) {
-			flags.run = 3;
-			do_rush = TRUE;
-		    }
-		    break;
+	if (*cmd == DORUSH) {
+	    if (movecmd(cmd[1])) {
+		flags.run = 2;
+		do_rush = TRUE;
+	    } else
+		prefix_seen = TRUE;
+	} else if ( (*cmd == '5' && iflags.num_pad)
+		    || *cmd == DORUN) {
+	    if (movecmd(lowc(cmd[1]))) {
+		flags.run = 3;
+		do_rush = TRUE;
+	    } else
+		prefix_seen = TRUE;
+	} else if ( (*cmd == '-' && iflags.num_pad)
+		    || *cmd == DOFORCEFIGHT) {
+		/* Effects of movement commands and invisible monsters:
+		 * m: always move onto space (even if 'I' remembered)
+		 * F: always attack space (even if 'I' not remembered)
+		 * normal movement: attack if 'I', move otherwise
+		 */
+	    if (movecmd(cmd[1])) {
+		flags.forcefight = 1;
+		do_walk = TRUE;
+	    } else
+		prefix_seen = TRUE;
+	} else if (*cmd == DONOPICKUP) {
+	    if (movecmd(cmd[1]) || u.dz) {
+		flags.run = 0;
+		flags.nopick = 1;
+		if (!u.dz) do_walk = TRUE;
+		else cmd[0] = cmd[1];	/* "m<" or "m>" */
+	    } else
+		prefix_seen = TRUE;
+	} else if (*cmd == DORUN_NOPICKUP) {
+	    if (movecmd(lowc(cmd[1]))) {
+		flags.run = 1;
+		flags.nopick = 1;
+		do_rush = TRUE;
+	    } else
+		prefix_seen = TRUE;
+	} else if (*cmd == '0' && iflags.num_pad) {
+	    (void)ddoinv(); /* a convenience borrowed from the PC */
+	    flags.move = FALSE;
+	    multi = 0;
+	} else if (*cmd == CMD_TRAVEL && iflags.travelcmd) {
+	  flags.travel = 1;
+	  iflags.travel1 = 1;
+	  flags.run = 8;
+	  flags.nopick = 1;
+	  do_rush = TRUE;
+	} else {
+	    if (movecmd(*cmd)) {	/* ordinary movement */
+		do_walk = TRUE;
+	    } else if (movecmd(iflags.num_pad ?
+			       UNMETA(*cmd) : lowc(*cmd))) {
+		flags.run = 1;
+		do_rush = TRUE;
+	    } else if (movecmd(UNCTRL(*cmd))) {
+		flags.run = 3;
+		do_rush = TRUE;
+	    }
 	}
 
 	/* some special prefix handling */
@@ -1939,29 +2957,28 @@ register char *cmd;
 	    flags.mv = TRUE;
 	    domove();
 	    return;
-	} else if (prefix_seen && cmd[1] == '\033') {	/* <prefix><escape> */
+	} else if (prefix_seen && cmd[1] == DOESCAPE) {	/* <prefix><escape> */
 	    /* don't report "unknown command" for change of heart... */
 	    bad_command = FALSE;
 	} else if (*cmd == ' ' && !flags.rest_on_space) {
 	    bad_command = TRUE;		/* skip cmdlist[] loop */
 
-	/* handle all other commands */
+	/* handle bound commands */
 	} else {
-	    register const struct func_tab *tlist;
-	    int res, NDECL((*func));
+	    const struct key_tab *keytab = &cmdlist[(unsigned char)*cmd];
 
-	    for (tlist = cmdlist; tlist->f_char; tlist++) {
-		if ((*cmd & 0xff) != (tlist->f_char & 0xff)) continue;
+	    if (keytab->bind_cmd != NULL) {
+		struct ext_func_tab *extcmd = keytab->bind_cmd;
+		int res, NDECL((*func));
 
-		if (u.uburied && !tlist->can_if_buried) {
+		if (u.uburied && !extcmd->can_if_buried) {
 		    You_cant("do that while you are buried!");
 		    res = 0;
 		} else {
-		    /* we discard 'const' because some compilers seem to have
-		       trouble with the pointer passed to set_occupation() */
-		    func = ((struct func_tab *)tlist)->f_funct;
-		    if (tlist->f_text && !occupation && multi)
-			set_occupation(func, tlist->f_text, multi);
+		    func = extcmd->ef_funct;
+		    if (extcmd->f_text && !occupation && multi)
+			set_occupation(func, extcmd->f_text, multi);
+		    last_cmd_char = *cmd;	/* remember pressed character */
 		    res = (*func)();		/* perform the command */
 		}
 		if (!res) {
@@ -2080,7 +3097,7 @@ getdir(s)
 const char *s;
 {
 	char dirsym;
-
+	static char saved_dirsym = '\0'; /* saved direction of the previous call of getdir() */
 #ifdef REDO
 	if(in_doagain || *readchar_queue)
 	    dirsym = readchar();
@@ -2091,7 +3108,13 @@ const char *s;
 #ifdef REDO
 	savech(dirsym);
 #endif
-	if(dirsym == '.' || dirsym == 's')
+	if (dirsym == last_cmd_char) {
+	  /* in here dirsym is not representing a direction
+	   * but the same sym used before for calling the
+	   * current cmd */
+	  movecmd(saved_dirsym);
+	  dirsym = saved_dirsym;
+        } else if(dirsym == '.' || dirsym == 's')
 		u.dx = u.dy = u.dz = 0;
 	else if(!movecmd(dirsym) && !u.dz) {
 		boolean did_help = FALSE;
@@ -2104,6 +3127,7 @@ const char *s;
 		}
 		return 0;
 	}
+	saved_dirsym = dirsym;
 	if(!u.dz && (Stunned || (Confusion && !rn2(5)))) confdir();
 	return 1;
 }
@@ -2348,7 +3372,7 @@ parse()
 		} else break;	/* not a digit */
 	    }
 
-	if (foo == '\033') {   /* esc cancels count (TH) */
+	if (foo == DOESCAPE) {   /* esc cancels count (TH) */
 	    clear_nhwindow(WIN_MESSAGE);
 	    multi = last_multi = 0;
 # ifdef REDO
@@ -2369,8 +3393,9 @@ parse()
 	}
 	in_line[0] = foo;
 	in_line[1] = '\0';
-	if (foo == 'g' || foo == 'G' || foo == 'm' || foo == 'M' ||
-	    foo == 'F' || (iflags.num_pad && (foo == '5' || foo == '-'))) {
+	if (foo == DORUSH || foo == DORUN || foo == DOFORCEFIGHT
+	    || foo == DONOPICKUP || foo == DORUN_NOPICKUP
+	    || (iflags.num_pad && (foo == '5' || foo == '-'))) {
 	    foo = readchar();
 #ifdef REDO
 	    savech((char)foo);
@@ -2379,7 +3404,7 @@ parse()
 	    in_line[2] = 0;
 	}
 	clear_nhwindow(WIN_MESSAGE);
-	if (prezero) in_line[0] = '\033';
+	if (prezero) in_line[0] = DOESCAPE;
 	return(in_line);
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/decl.c nethack-3.4.3-nao-osx/src/decl.c
--- nethack-3.4.3/src/decl.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/decl.c	2014-12-20 12:08:36.000000000 -0800
@@ -19,7 +19,12 @@ char *catmore = 0;		/* default pager */
 
 NEARDATA int bases[MAXOCLASSES] = DUMMY;
 
+long has_loaded_bones = 0L;
+
+long last_clear_screen = 0L;
+
 NEARDATA int multi = 0;
+char multi_txt[BUFSZ] = DUMMY;
 #if 0
 NEARDATA int warnlevel = 0;		/* used by movemon and dochugw */
 #endif
@@ -54,6 +59,9 @@ const char *delayed_killer = 0;
 NEARDATA long done_money = 0;
 #endif
 char killer_buf[BUFSZ] = DUMMY;
+
+long killer_flags = 0L;
+
 const char *nomovemsg = 0;
 const char nul[40] = DUMMY;			/* contains zeros */
 NEARDATA char plname[PL_NSIZ] = DUMMY;		/* player name */
@@ -103,6 +111,11 @@ const char ndir[] = "47896321><";	/* num
 const schar xdir[10] = { -1,-1, 0, 1, 1, 1, 0,-1, 0, 0 };
 const schar ydir[10] = {  0,-1,-1,-1, 0, 1, 1, 1, 0, 0 };
 const schar zdir[10] = {  0, 0, 0, 0, 0, 0, 0, 0, 1,-1 };
+char misc_cmds[] = {'g', 'G', 'F', 'm', 'M', '\033'
+#ifdef REDO
+		    , '\001'
+#endif
+};
 
 NEARDATA schar tbx = 0, tby = 0;	/* mthrowu: target */
 
@@ -209,6 +222,15 @@ NEARDATA struct monst *migrating_mons = 
 
 NEARDATA struct mvitals mvitals[NUMMONS];
 
+/* originally from end.c */
+#ifdef DUMP_LOG
+#ifdef DUMP_FN
+char dump_fn[] = DUMP_FN;
+#else
+char dump_fn[PL_PSIZ] = DUMMY;
+#endif
+#endif /* DUMP_LOG */
+
 NEARDATA struct c_color_names c_color_names = {
 	"black", "amber", "golden",
 	"light blue", "red", "green",
@@ -235,6 +257,10 @@ const char *c_obj_colors[] = {
 	"white",		/* CLR_WHITE */
 };
 
+#ifdef MENU_COLOR
+struct menucoloring *menu_colorings = 0;
+#endif
+
 struct c_common_strings c_common_strings = {
 	"Nothing happens.",		"That's enough tries!",
 	"That is a silly thing to %s.",	"shudder for a moment.",
@@ -271,6 +297,30 @@ char *fqn_prefix_names[PREFIX_COUNT] = {
 					"lockdir", "configdir", "troubledir" };
 #endif
 
+#ifdef RECORD_ACHIEVE
+struct u_achieve achieve = DUMMY;
+#endif
+
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+struct realtime_data realtime_data = { 0, 0, 0 };
+#endif
+
+
+struct _plinemsg *pline_msg = NULL;
+
+/* FIXME: These should be integrated into objclass and permonst structs,
+   but that invalidates saves */
+glyph_t objclass_unicode_codepoint[NUM_OBJECTS] = DUMMY;
+glyph_t permonst_unicode_codepoint[NUMMONS] = DUMMY;
+
+/* FIXME: The curses windowport requires this stupid hack, in the
+   case where a game is in progress and the user is asked if he
+   wants to destroy old game.
+   Without this, curses tries to show the yn() question with pline()
+   ...but the message window isn't up yet.
+ */
+boolean curses_stupid_hack = 1;
+
 /* dummy routine used to force linkage */
 void
 decl_init()
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/detect.c nethack-3.4.3-nao-osx/src/detect.c
--- nethack-3.4.3/src/detect.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/detect.c	2014-12-20 12:08:36.000000000 -0800
@@ -861,7 +861,7 @@ struct obj *obj;
 	return;
     }
     You("peer into %s...", the(xname(obj)));
-    nomul(-rnd(10));
+    nomul(-rnd(10), "gazing into a crystal ball");
     nomovemsg = "";
     if (obj->spe <= 0)
 	pline_The("vision is unclear.");
@@ -1191,7 +1191,7 @@ register int aflag;
 			if(rnl(7-fund)) continue;
 			cvt_sdoor_to_door(&levl[x][y]);	/* .typ = DOOR */
 			exercise(A_WIS, TRUE);
-			nomul(0);
+			nomul(0, NULL);
 			if (Blind && !aflag)
 			    feel_location(x,y);	/* make sure it shows up */
 			else
@@ -1201,7 +1201,7 @@ register int aflag;
 			levl[x][y].typ = CORR;
 			unblock_point(x,y);	/* vision */
 			exercise(A_WIS, TRUE);
-			nomul(0);
+			nomul(0, NULL);
 			newsym(x,y);
 		    } else {
 		/* Be careful not to find anything in an SCORR or SDOOR */
@@ -1246,7 +1246,7 @@ register int aflag;
 			}
 
 			if ((trap = t_at(x,y)) && !trap->tseen && !rnl(8)) {
-			    nomul(0);
+			    nomul(0, NULL);
 
 			    if (trap->ttyp == STATUE_TRAP) {
 				if (activate_statue_trap(trap, x, y, FALSE))
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/dig.c nethack-3.4.3-nao-osx/src/dig.c
--- nethack-3.4.3/src/dig.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/dig.c	2014-12-20 12:08:36.000000000 -0800
@@ -916,7 +916,7 @@ struct obj *obj;
 				aobjnam(obj, "become"));
 			    /* you ought to be able to let go; tough luck */
 			    /* (maybe `move_into_trap()' would be better) */
-			    nomul(-d(2,2));
+			    nomul(-d(2,2), "stuck in a spider web");
 			    nomovemsg = "You pull free.";
 			} else if (lev->typ == IRONBARS) {
 			    pline("Clang!");
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/display.c nethack-3.4.3-nao-osx/src/display.c
--- nethack-3.4.3/src/display.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/display.c	2014-12-20 12:08:36.000000000 -0800
@@ -591,13 +591,13 @@ feel_location(x, y)
 	     * not cleared, then when the ball/chain is moved it will drop
 	     * the wrong glyph.
 	     */
-	    if (uchain->ox == x && uchain->oy == y) {
+	    if (uchain && uchain->ox == x && uchain->oy == y) {
 		if (level.objects[x][y] == uchain)
 		    u.bc_felt |= BC_CHAIN;
 		else
 		    u.bc_felt &= ~BC_CHAIN;	/* do not feel the chain */
 	    }
-	    if (!carried(uball) && uball->ox == x && uball->oy == y) {
+	    if (uball && !carried(uball) && uball->ox == x && uball->oy == y) {
 		if (level.objects[x][y] == uball)
 		    u.bc_felt |= BC_BALL;
 		else
@@ -886,7 +886,7 @@ tmp_at(x, y)
 
 	default:	/* do it */
 	    if (tglyph->style == DISP_BEAM) {
-		if (!cansee(x,y)) break;
+		if (!isok(x,y) || !cansee(x,y)) break;
 		/* save pos for later erasing */
 		tglyph->saved[tglyph->sidx].x = x;
 		tglyph->saved[tglyph->sidx].y = y;
@@ -896,6 +896,7 @@ tmp_at(x, y)
 		    newsym(tglyph->saved[0].x, tglyph->saved[0].y);
 		    tglyph->sidx = 0;	/* display is presently up to date */
 		}
+		if (!isok(x,y)) break;
 		if (!cansee(x,y) && tglyph->style != DISP_ALWAYS) break;
 		tglyph->saved[0].x = x;
 		tglyph->saved[0].y = y;
@@ -1152,6 +1153,8 @@ docrt()
     register int x,y;
     register struct rm *lev;
 
+    last_clear_screen = moves;
+
     if (!u.ux) return; /* display isn't ready yet */
 
     if (u.uswallow) {
@@ -1370,6 +1373,127 @@ flush_screen(cursor_on_u)
 
 /* ========================================================================= */
 
+#ifdef DUMP_LOG
+/* D: Added to dump screen to output file */
+STATIC_PTR uchar get_glyph_char(glyph)
+int glyph;
+{
+    uchar   ch;
+    register int offset;
+
+    if (glyph >= NO_GLYPH)
+        return ' ';
+
+    /*
+     *  Map the glyph back to a character.
+     *
+     *  Warning:  For speed, this makes an assumption on the order of
+     *		  offsets.  The order is set in display.h.
+     */
+    if ((offset = (glyph - GLYPH_WARNING_OFF)) >= 0) {	/* a warning flash */
+	ch = def_warnsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {	/* swallow */
+	/* see swallow_to_glyph() in display.c */
+	ch = (uchar) defsyms[S_sw_tl + (offset & 0x7)].sym;
+    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
+	/* see zapdir_to_glyph() in display.c */
+	ch = defsyms[S_vbeam + (offset & 0x3)].sym;
+    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
+	ch = defsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
+	ch = def_oc_syms[(int)objects[offset].oc_class];
+    } else if ((offset = (glyph - GLYPH_RIDDEN_OFF)) >= 0) { /* mon ridden */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
+	ch = def_oc_syms[(int)objects[CORPSE].oc_class];
+    } else if ((offset = (glyph - GLYPH_DETECT_OFF)) >= 0) { /* mon detect */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_INVIS_OFF)) >= 0) {  /* invisible */
+	ch = DEF_INVISIBLE;
+    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else {						    /* a monster */
+	ch = monsyms[(int)mons[glyph].mlet];
+    }
+    return ch;
+}
+
+#ifdef TTY_GRAPHICS
+extern const char * FDECL(compress_str, (const char *));
+#else
+const char*
+compress_str(str) /* copied from win/tty/wintty.c */
+const char *str;
+{
+	static char cbuf[BUFSZ];
+	/* compress in case line too long */
+	if((int)strlen(str) >= 80) {
+		register const char *bp0 = str;
+		register char *bp1 = cbuf;
+
+		do {
+			if(*bp0 != ' ' || bp0[1] != ' ')
+				*bp1++ = *bp0;
+		} while(*bp0++);
+	} else
+	    return str;
+	return cbuf;
+}
+#endif /* TTY_GRAPHICS */
+
+extern short glyph2tile[];
+
+/* Take a screen dump */
+void dump_screen(style)
+int style;
+{
+    register int x,y;
+    int lastc;
+    /* D: botl.c has a closer approximation to the size, but we'll go with
+     *    this */
+    char buf[350], *ptr;
+    if (style == 0) {
+	for (y = 0; y < ROWNO; y++) {
+	    lastc = 0;
+	    ptr = buf;
+	    for (x = 1; x < COLNO; x++) {
+		uchar c = get_glyph_char(gbuf[y][x].glyph);
+		*ptr++ = c;
+		if (c != ' ')
+		    lastc = x;
+	    }
+	    buf[lastc] = '\0';
+	    dump("", buf);
+	}
+	dump("", "");
+	bot1str(buf);
+	ptr = (char *) compress_str((const char *) buf);
+	dump("", ptr);
+	bot2str(buf);
+	dump("", buf);
+	dump("", "");
+	dump("", "");
+    } else {
+	int first;
+	for (y = 0; y < ROWNO; y++) {
+	    first = 1;
+	    buf[0] = '\0';
+	    for (x = 1; x < COLNO; x++) {
+		Sprintf(eos(buf), "%s%i\0", (first ? "" : ","), glyph2tile[gbuf[y][x].glyph]);
+		first = 0;
+	    }
+	    dump("", buf);
+	}
+	dump("", "");
+	bot1str(buf);
+	ptr = (char *) compress_str((const char *) buf);
+	dump("", ptr);
+	bot2str(buf);
+	dump("", buf);
+    }
+}
+#endif /* DUMP_LOG */
+
 /*
  * back_to_glyph()
  *
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/do.c nethack-3.4.3-nao-osx/src/do.c
--- nethack-3.4.3/src/do.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/do.c	2014-12-20 12:08:36.000000000 -0800
@@ -208,7 +208,7 @@ const char *verb;
 		    map_background(x, y, 0);
 		    newsym(x, y);
 		}
-		water_damage(obj, FALSE, FALSE);
+		return water_damage(obj, FALSE, FALSE);
 	} else if (u.ux == x && u.uy == y &&
 		(!u.utrap || u.utraptype != TT_PIT) &&
 		(t = t_at(x,y)) != 0 && t->tseen &&
@@ -968,9 +968,10 @@ boolean at_stairs, falling, portal;
 	if (dunlev(newlevel) > dunlevs_in_dungeon(newlevel))
 		newlevel->dlevel = dunlevs_in_dungeon(newlevel);
 	if (newdungeon && In_endgame(newlevel)) { /* 1st Endgame Level !!! */
-		if (u.uhave.amulet)
-		    assign_level(newlevel, &earth_level);
-		else return;
+	    if (u.uhave.amulet) {
+		livelog_write_string("entered the Planes");
+		assign_level(newlevel, &earth_level);
+	    } else return;
 	}
 	new_ledger = ledger_no(newlevel);
 	if (new_ledger <= 0)
@@ -1283,6 +1284,10 @@ boolean at_stairs, falling, portal;
 #endif
 		You_hear("groans and moans everywhere.");
 	    } else pline("It is hot here.  You smell smoke...");
+
+#ifdef RECORD_ACHIEVE
+            achieve.enter_gehennom = 1;
+#endif
 	}
 
 	if (familiar) {
@@ -1356,6 +1361,10 @@ boolean at_stairs, falling, portal;
 	/* assume this will always return TRUE when changing level */
 	(void) in_out_region(u.ux, u.uy);
 	(void) pickup(1);
+
+#ifdef WHEREIS_FILE
+        touch_whereis();
+#endif
 }
 
 STATIC_OVL void
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/do_name.c nethack-3.4.3-nao-osx/src/do_name.c
--- nethack-3.4.3/src/do_name.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/do_name.c	2014-12-20 12:08:36.000000000 -0800
@@ -6,7 +6,6 @@
 
 #ifdef OVLB
 
-STATIC_DCL void FDECL(do_oname, (struct obj *));
 static void FDECL(getpos_help, (BOOLEAN_P,const char *));
 
 extern const char what_is_an_unknown_object[];		/* from pager.c */
@@ -28,6 +27,8 @@ const char *goal;
     putstr(tmpwin, 0, "Or enter a background symbol (ex. <).");
     /* disgusting hack; the alternate selection characters work for any
        getpos call, but they only matter for dowhatis (and doquickwhatis) */
+    putstr(tmpwin, 0, "Use m and M to select a monster.");
+    putstr(tmpwin, 0, "Use @ to select yourself.");
     doing_what_is = (goal == what_is_an_unknown_object);
     Sprintf(sbuf, "Type a .%s when you are at the right place.",
             doing_what_is ? " or , or ; or :" : "");
@@ -39,6 +40,96 @@ const char *goal;
     destroy_nhwindow(tmpwin);
 }
 
+struct _getpos_monarr {
+    coord pos;
+    long du;
+};
+static int getpos_monarr_len = 0;
+static int getpos_monarr_idx = 0;
+static struct _getpos_monarr *getpos_monarr_pos = NULL;
+
+void
+getpos_freemons()
+{
+    if (getpos_monarr_pos) free(getpos_monarr_pos);
+    getpos_monarr_pos = NULL;
+    getpos_monarr_len = 0;
+}
+
+static int
+getpos_monarr_cmp(a, b)
+     const void *a;
+     const void *b;
+{
+    const struct _getpos_monarr *m1 = (const struct _getpos_monarr *)a;
+    const struct _getpos_monarr *m2 = (const struct _getpos_monarr *)b;
+    return (m1->du - m2->du);
+}
+
+void
+getpos_initmons()
+{
+    struct monst *mtmp = fmon;
+    if (getpos_monarr_pos) getpos_freemons();
+    while (mtmp) {
+	if (!DEADMONSTER(mtmp) && canspotmon(mtmp)) getpos_monarr_len++;
+	mtmp = mtmp->nmon;
+    }
+    if (getpos_monarr_len) {
+	int idx = 0;
+	getpos_monarr_pos = (struct _getpos_monarr *)malloc(sizeof(struct _getpos_monarr) * getpos_monarr_len);
+	mtmp = fmon;
+	while (mtmp) {
+	    if (!DEADMONSTER(mtmp) && canspotmon(mtmp)) {
+		getpos_monarr_pos[idx].pos.x = mtmp->mx;
+		getpos_monarr_pos[idx].pos.y = mtmp->my;
+		getpos_monarr_pos[idx].du = distu(mtmp->mx, mtmp->my);
+		idx++;
+	    }
+	    mtmp = mtmp->nmon;
+	}
+	qsort(getpos_monarr_pos, getpos_monarr_len, sizeof(struct _getpos_monarr), getpos_monarr_cmp);
+    }
+}
+
+struct monst *
+getpos_nextmon()
+{
+    if (!getpos_monarr_pos) {
+	getpos_initmons();
+	if (getpos_monarr_len < 1) return NULL;
+	getpos_monarr_idx = -1;
+    }
+    if (getpos_monarr_idx >= -1 && getpos_monarr_idx < getpos_monarr_len) {
+	struct monst *mon;
+	getpos_monarr_idx = (getpos_monarr_idx + 1) % getpos_monarr_len;
+	mon = m_at(getpos_monarr_pos[getpos_monarr_idx].pos.x,
+		   getpos_monarr_pos[getpos_monarr_idx].pos.y);
+	return mon;
+    }
+    return NULL;
+}
+
+struct monst *
+getpos_prevmon()
+{
+    if (!getpos_monarr_pos) {
+	getpos_initmons();
+	if (getpos_monarr_len < 1) return NULL;
+	getpos_monarr_idx = getpos_monarr_len;
+    }
+    if (getpos_monarr_idx >= 0 && getpos_monarr_idx <= getpos_monarr_len) {
+	struct monst *mon;
+	getpos_monarr_idx = (getpos_monarr_idx - 1);
+	if (getpos_monarr_idx < 0) getpos_monarr_idx = getpos_monarr_len - 1;
+	mon = m_at(getpos_monarr_pos[getpos_monarr_idx].pos.x,
+		   getpos_monarr_pos[getpos_monarr_idx].pos.y);
+	return mon;
+    }
+    return NULL;
+}
+
+
 int
 getpos(cc, force, goal)
 coord *cc;
@@ -124,6 +215,17 @@ const char *goal;
 
 	if(c == '?'){
 	    getpos_help(force, goal);
+	} else if (c == 'm' || c == 'M') {
+	    struct monst *tmpmon = (c == 'm') ? getpos_nextmon() : getpos_prevmon();
+	    if (tmpmon) {
+		cx = tmpmon->mx;
+		cy = tmpmon->my;
+		goto nxtc;
+	    }
+	} else if (c == '@') {
+	    cx = u.ux;
+	    cy = u.uy;
+	    goto nxtc;
 	} else {
 	    if (!index(quitchars, c)) {
 		char matching[MAXPCHARS];
@@ -187,6 +289,7 @@ const char *goal;
     if (msg_given) clear_nhwindow(WIN_MESSAGE);
     cc->x = cx;
     cc->y = cy;
+    getpos_freemons();
     return result;
 }
 
@@ -275,9 +378,13 @@ do_mname()
 	/* strip leading and trailing spaces; unnames monster if all spaces */
 	(void)mungspaces(buf);
 
-	if (mtmp->data->geno & G_UNIQ)
+	if (mtmp->data->geno & G_UNIQ) {
+	  if (mtmp->data == &mons[PM_HIGH_PRIEST] && Is_astralevel(&u.uz)) {
+	    pline_The("high priest%s doesn't like being called names!", mtmp->female ? "ess" : "");
+	  } else {
 	    pline("%s doesn't like being called names!", Monnam(mtmp));
-	else
+	  }
+	} else
 	    (void) christen_monst(mtmp, buf);
 	return(0);
 }
@@ -287,12 +394,11 @@ do_mname()
  * when there might be pointers around in unknown places. For now: only
  * when obj is in the inventory.
  */
-STATIC_OVL
 void
 do_oname(obj)
 register struct obj *obj;
 {
-	char buf[BUFSZ], qbuf[QBUFSZ];
+	char buf[BUFSZ], qbuf[BUFSZ+BUFSZ];
 	const char *aname;
 	short objtyp;
 
@@ -310,7 +416,7 @@ register struct obj *obj;
 	if (obj->oartifact) {
 		pline_The("artifact seems to resist the attempt.");
 		return;
-	} else if (restrict_name(obj, buf) || exist_artifact(obj->otyp, buf)) {
+	} else if (restrict_name(obj, buf, FALSE) || exist_artifact(obj->otyp, buf)) {
 		int n = rn2((int)strlen(buf));
 		register char c1, c2;
 
@@ -898,8 +1004,10 @@ static const char * const bogusmons[] = 
 	"brogmoid", "dornbeast",		/* Quendor (Zork, &c.) */
 	"Ancient Multi-Hued Dragon", "Evil Iggy",
 						/* Moria */
+	"rattlesnake", "ice monster", "phantom",
+	"quagga", "aquator", "griffin",
 	"emu", "kestrel", "xeroc", "venus flytrap",
-						/* Rogue */
+						/* Rogue V5 http://rogue.rogueforge.net/vade-mecum/ */
 	"creeping coins",			/* Wizardry */
 	"hydra", "siren",			/* Greek legend */
 	"killer bunny",				/* Monty Python */
@@ -936,7 +1044,207 @@ static const char * const bogusmons[] = 
 	"Vorlon",				/* Babylon 5 */
 	"questing beast",		/* King Arthur */
 	"Predator",				/* Movie */
-	"mother-in-law"				/* common pest */
+	"mother-in-law",			/* common pest */
+        "one-winged dewinged stab-bat",  /* KoL */
+        "praying mantis",
+        "arch-pedant",
+        "beluga whale",
+        "bluebird of happiness",
+        "bouncing eye", "floating nose", "wandering eye",
+        "buffer overflow", "dangling pointer", "walking disk drive", "floating point",
+        "cacodemon", "scrag",
+        "cardboard golem", "duct tape golem",
+        "chess pawn",
+        "chicken",
+        "chocolate pudding",
+        "coelacanth",
+        "corpulent porpoise",
+        "Crow T. Robot",
+        "diagonally moving grid bug",
+        "dropbear",
+        "Dudley",
+        "El Pollo Diablo",
+        "evil overlord",
+        "existential angst",
+        "figment of your imagination", "flash of insight",
+        "flying pig",
+        "gazebo",
+        "gonzo journalist",
+        "gray goo", "magnetic monopole",
+	"ooblecks",
+        "heisenbug",
+        "lag monster",
+        "loan shark",
+        "Lord British",
+        "newsgroup troll",
+        "ninja pirate zombie robot",
+        "octarine dragon",
+        "particle man",
+        "possessed waffle iron",
+        "poultrygeist",
+        "raging nerd",
+        "roomba",
+        "sea cucumber",
+        "spelling bee",
+        "Strong Bad",
+        "stuffed raccoon puppet",
+        "tapeworm",
+        "liger",
+        "velociraptor",
+        "vermicious knid",
+        "viking",
+        "voluptuous ampersand",
+        "wee green blobbie",
+        "wereplatypus",
+        "zergling",
+	"hag of bolding",
+	"blancmange",
+	"killer beet",
+	"land octopus",
+	"frog prince",
+	"slow loris",
+	"dust speck",
+	"kitten prospecting robot",
+	"angry mariachi",
+	"star-nosed mole",
+	"acid blog",
+	"guillemet",
+	"solidus",
+	"obelus",
+	"miniature blimp",
+	"lungfish",
+
+        "apostrophe golem", "Bob the angry flower",
+        "bonsai-kitten", "Boxxy", "lonelygirl15",
+        "tie-thulu", "Domo-kun",
+        "looooooooooooong cat",                 /* internet memes */
+        "bohrbug", "mandelbug", "schroedinbug", /* bugs */
+        "Gerbenok",                             /* Monty Python killer rabbit */
+        "doenertier",                           /* Erkan & Stefan */
+        "Invisible Pink Unicorn",
+        "Flying Spaghetti Monster",             /* deities */
+        "Bluebear", "Professor Abdullah Nightingale",
+        "Qwerty Uiop", "troglotroll",           /* Zamonien */
+        "wolpertinger", "elwedritsche", "skvader",
+        "Nessie", "tatzelwurm", "dahu",         /* european cryptids */
+        "three-headed monkey",                  /* Monkey Island */
+        "little green man",                     /* modern folklore */
+        "weighted Companion Cube",              /* Portal */
+        "/b/tard",                              /* /b/ */
+        "manbearpig",                           /* South Park */
+        "ceiling cat", "basement cat",
+        "monorail cat",                         /* the Internet is made for cat pix */
+        /*"rape golem",*/                           /* schnippi */
+        "tridude",                              /* POWDER */
+        "orcus cosmicus",                       /* Radomir Dopieralski */
+        "yeek", "quylthulg",
+        "Greater Hell Beast",                   /* Angband */
+        "Vendor of Yizard",                     /* Souljazz */
+        "Sigmund", "lernaean hydra", "Ijyb",
+        "Gloorx Vloq", "Blork the orc",         /* Dungeon Crawl Stone Soup */
+        "unicorn pegasus kitten",               /* Wil Wheaton, John Scalzi */
+
+	"nyan cat",
+	"grind bug",
+	"enderman",
+	"wight supremacist",
+	"Magical Trevor",
+	"first category perpetual motion device",
+
+	"ghoti",
+	"regex engine",
+	"netsplit",
+	"wiki",
+	"peer",
+	"pigasus",
+	"Semigorgon",
+	"meeple",
+	"conventioneer",
+	"terracotta warrior",
+	"large microbat", "small megabat",
+	"uberhulk",
+	"hearse",
+	"COBOL",
+	"tofurkey",
+	"hippocampus",
+	"hippogriff",
+	"kelpie",
+	"womble",  /* The Wombles */
+	"fraggle", /* Fraggle Rock */
+
+	/* soundex and typos of monsters */
+	"gloating eye",
+	"flush golem",
+	"martyr orc",
+	"mortar orc",
+	"acute blob",
+	"aria elemental",
+	"aliasing priest",
+	"aligned parasite",
+	"aligned parquet",
+	"aligned proctor",
+	"baby balky dragon",
+	"baby blues dragon",
+	"baby caricature",
+	"baby crochet",
+	"baby grainy dragon",
+	"baby bong worm",
+	"baby long word",
+	"baby parable worm",
+	"barfed devil",
+	"beer wight",
+	"boor wight",
+	"brawny mold",
+	"rave spider",
+	"clue golem",
+	"bust vortex",
+	"errata elemental",
+	"elastic eel",
+	"electrocardiogram eel",
+	"fir elemental",
+	"tire elemental",
+	"flamingo sphere",
+	"fallacy golem",
+	"frizzed centaur",
+	"forest centerfold",
+	"fierceness sphere",
+	"frosted giant",
+	"geriatric snake",
+	"gnat ant",
+	"giant bath",
+	"grant beetle",
+	"giant mango",
+	"glossy golem",
+	"gnome laureate",
+	"gnome dummy",
+	"gooier ooze",
+	"green slide",
+	"guardian nacho",
+	"hell hound pun",
+	"high purist",
+	"hairnet devil",
+	"ice trowel",
+	"feather golem",
+	"lounge worm",
+	"mountain lymph",
+	"pager golem",
+	"pie fiend",
+	"prophylactic worm",
+	"sock mole",
+	"rogue piercer",
+	"seesawing sphere",
+	"simile mimic",
+	"moldier ant",
+	"stain vortex",
+	"scone giant",
+	"umbrella hulk",
+	"vampire mace",
+	"verbal jabberwock",
+	"water lemon",
+	"water melon",
+	"winged grizzly",
+	"yellow wight"
+
 };
 
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/do_wear.c nethack-3.4.3-nao-osx/src/do_wear.c
--- nethack-3.4.3/src/do_wear.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/do_wear.c	2014-12-20 12:08:36.000000000 -0800
@@ -94,7 +94,9 @@ STATIC_PTR
 int
 Boots_on()
 {
-    long oldprop =
+    long oldprop;
+    if (!uarmf) return 0;
+    oldprop =
 	u.uprops[objects[uarmf->otyp].oc_oprop].extrinsic & ~WORN_BOOTS;
 
     switch(uarmf->otyp) {
@@ -196,7 +198,9 @@ Boots_off()
 STATIC_OVL int
 Cloak_on()
 {
-    long oldprop =
+    long oldprop;
+    if (!uarmc) return 0;
+    oldprop =
 	u.uprops[objects[uarmc->otyp].oc_oprop].extrinsic & ~WORN_CLOAK;
 
     switch(uarmc->otyp) {
@@ -292,6 +296,7 @@ STATIC_PTR
 int
 Helmet_on()
 {
+    if (!uarmh) return 0;
     switch(uarmh->otyp) {
 	case FEDORA:
 	case HELMET:
@@ -392,7 +397,9 @@ STATIC_PTR
 int
 Gloves_on()
 {
-    long oldprop =
+    long oldprop;
+    if (!uarmg) return 0;
+    oldprop =
 	u.uprops[objects[uarmg->otyp].oc_oprop].extrinsic & ~WORN_GLOVES;
 
     switch(uarmg->otyp) {
@@ -577,6 +584,7 @@ Armor_gone()
 STATIC_OVL void
 Amulet_on()
 {
+    if (!uamul) return;
     switch(uamul->otyp) {
 	case AMULET_OF_ESP:
 	case AMULET_OF_LIFE_SAVING:
@@ -1078,7 +1086,11 @@ dotakeoff()
 			  "  Use 'R' command to remove accessories." : "");
 		return 0;
 	}
-	if (armorpieces > 1)
+	if (armorpieces > 1
+#ifdef PARANOID
+	    || iflags.paranoid_remove
+#endif
+	    )
 		otmp = getobj(clothes, "take off");
 	if (otmp == 0) return(0);
 	if (!(otmp->owornmask & W_ARMOR)) {
@@ -1128,7 +1140,11 @@ doremring()
 		      "  Use 'T' command to take off armor." : "");
 		return(0);
 	}
-	if (Accessories != 1) otmp = getobj(accessories, "remove");
+	if (Accessories != 1
+#ifdef PARANOID
+	    || iflags.paranoid_remove
+#endif
+	    ) otmp = getobj(accessories, "remove");
 	if(!otmp) return(0);
 	if(!(otmp->owornmask & (W_RING | W_AMUL | W_TOOL))) {
 		You("are not wearing that.");
@@ -1184,7 +1200,7 @@ register struct obj *otmp;
 
 	if(cursed(otmp)) return(0);
 	if(delay) {
-		nomul(delay);
+		nomul(delay, "disrobing");
 		if (is_helmet(otmp)) {
 			nomovemsg = "You finish taking off your helmet.";
 			afternmv = Helmet_off;
@@ -1441,7 +1457,7 @@ dowear()
 	setworn(otmp, mask);
 	delay = -objects[otmp->otyp].oc_delay;
 	if(delay){
-		nomul(delay);
+		nomul(delay, "dressing up");
 		if(is_boots(otmp)) afternmv = Boots_on;
 		if(is_helmet(otmp)) afternmv = Helmet_on;
 		if(is_gloves(otmp)) afternmv = Gloves_on;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/dokick.c nethack-3.4.3-nao-osx/src/dokick.c
--- nethack-3.4.3/src/dokick.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/dokick.c	2014-12-20 12:08:36.000000000 -0800
@@ -553,7 +553,7 @@ xchar x, y;
 	mon = bhit(u.dx, u.dy, range, KICKED_WEAPON,
 		   (int FDECL((*),(MONST_P,OBJ_P)))0,
 		   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-		   kickobj);
+		   kickobj, NULL);
 
 	if(mon) {
 	    if (mon->isshk &&
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/dothrow.c nethack-3.4.3-nao-osx/src/dothrow.c
--- nethack-3.4.3/src/dothrow.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/dothrow.c	2014-12-20 12:08:36.000000000 -0800
@@ -300,15 +300,19 @@ dofire()
 		if (!flags.autoquiver) {
 			/* Don't automatically fill the quiver */
 			You("have no ammunition readied!");
-			return(dothrow());
-		}
-		autoquiver();
-		if (!uquiver) {
+			if (iflags.quiver_fired)
+			  dowieldquiver(); /* quiver_fired */
+			if (!uquiver)
+			  return(dothrow());
+		} else {
+		  autoquiver();
+		  if (!uquiver) {
 			You("have nothing appropriate for your quiver!");
 			return(dothrow());
-		} else {
+		  } else {
 			You("fill your quiver:");
 			prinv((char *)0, uquiver, 0L);
+		  }
 		}
 	}
 
@@ -608,13 +612,13 @@ hurtle(dx, dy, range, verbose)
      */
     if(Punished && !carried(uball)) {
 	You_feel("a tug from the iron ball.");
-	nomul(0);
+	nomul(0, NULL);
 	return;
     } else if (u.utrap) {
 	You("are anchored by the %s.",
 	    u.utraptype == TT_WEB ? "web" : u.utraptype == TT_LAVA ? "lava" :
 		u.utraptype == TT_INFLOOR ? surface(u.ux,u.uy) : "trap");
-	nomul(0);
+	nomul(0, NULL);
 	return;
     }
 
@@ -624,7 +628,7 @@ hurtle(dx, dy, range, verbose)
 
     if(!range || (!dx && !dy) || u.ustuck) return; /* paranoia */
 
-    nomul(-range);
+    nomul(-range, "moving through the air");
     if (verbose)
 	You("%s in the opposite direction.", range > 1 ? "hurtle" : "float");
     /* if we're in the midst of shooting multiple projectiles, stop */
@@ -867,6 +871,8 @@ boolean twoweap; /* used to restore twow
 	boolean impaired = (Confusion || Stunned || Blind ||
 			   Hallucination || Fumbling);
 
+       obj->was_thrown = 1;
+
 	if ((obj->cursed || obj->greased) && (u.dx || u.dy) && !rn2(7)) {
 	    boolean slipok = TRUE;
 	    if (ammo_and_launcher(obj, uwep))
@@ -980,14 +986,17 @@ boolean twoweap; /* used to restore twow
 
 		if (Underwater) range = 1;
 
+		boolean obj_destroyed = FALSE;
 		mon = bhit(u.dx, u.dy, range, THROWN_WEAPON,
 			   (int FDECL((*),(MONST_P,OBJ_P)))0,
 			   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-			   obj);
+			   obj, &obj_destroyed);
 
 		/* have to do this after bhit() so u.ux & u.uy are correct */
 		if(Is_airlevel(&u.uz) || Levitation)
 		    hurtle(-u.dx, -u.dy, urange, TRUE);
+
+		if (obj_destroyed) return; /* fixes C343-100 */
 	}
 
 	if (mon) {
@@ -1748,7 +1757,7 @@ struct obj *obj;
 			mon = bhit(u.dx, u.dy, range, THROWN_WEAPON,
 				   (int FDECL((*),(MONST_P,OBJ_P)))0,
 				   (int FDECL((*),(OBJ_P,OBJ_P)))0,
-				   obj);
+				   obj, NULL);
 			if(mon) {
 			    if (ghitm(mon, obj))	/* was it caught? */
 				return 1;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/drawing.c nethack-3.4.3-nao-osx/src/drawing.c
--- nethack-3.4.3/src/drawing.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/drawing.c	2014-12-20 12:08:36.000000000 -0800
@@ -20,9 +20,13 @@
 #define g_FILLER(symbol) 0
 
 uchar oc_syms[MAXOCLASSES] = DUMMY; /* the current object  display symbols */
-uchar showsyms[MAXPCHARS]  = DUMMY; /* the current feature display symbols */
+glyph_t showsyms[MAXPCHARS]  = DUMMY; /* the current feature display symbols */
 uchar monsyms[MAXMCLASSES] = DUMMY; /* the current monster display symbols */
 uchar warnsyms[WARNCOUNT]  = DUMMY;  /* the current warning display symbols */
+#ifdef USER_DUNGEONCOLOR
+uchar showsymcolors[MAXPCHARS] = DUMMY; /* current feature display colors */
+#endif
+
 
 /* Default object class symbols.  See objclass.h. */
 const char def_oc_syms[MAXOCLASSES] = {
@@ -314,7 +318,11 @@ const struct symdef defsyms[MAXPCHARS] =
 void NDECL((*ibmgraphics_mode_callback)) = 0;	/* set in tty_start_screen() */
 #endif /* PC9800 */
 
-static uchar ibm_graphics[MAXPCHARS] = {
+#ifdef CURSES_GRAPHICS
+void NDECL((*cursesgraphics_mode_callback)) = 0;
+#endif
+
+static glyph_t ibm_graphics[MAXPCHARS] = {
 /* 0*/	g_FILLER(S_stone),
 	0xb3,	/* S_vwall:	meta-3, vertical rule */
 	0xc4,	/* S_hwall:	meta-D, horizontal rule */
@@ -413,7 +421,7 @@ static uchar ibm_graphics[MAXPCHARS] = {
 #ifdef TERMLIB
 void NDECL((*decgraphics_mode_callback)) = 0;  /* set in tty_start_screen() */
 
-static uchar dec_graphics[MAXPCHARS] = {
+static glyph_t dec_graphics[MAXPCHARS] = {
 /* 0*/	g_FILLER(S_stone),
 	0xf8,	/* S_vwall:	meta-x, vertical rule */
 	0xf1,	/* S_hwall:	meta-q, horizontal rule */
@@ -510,7 +518,7 @@ static uchar dec_graphics[MAXPCHARS] = {
 #endif  /* TERMLIB */
 
 #ifdef MAC_GRAPHICS_ENV
-static uchar mac_graphics[MAXPCHARS] = {
+static glyph_t mac_graphics[MAXPCHARS] = {
 /* 0*/	g_FILLER(S_stone),
 	0xba,	/* S_vwall */
 	0xcd,	/* S_hwall */
@@ -606,6 +614,105 @@ static uchar mac_graphics[MAXPCHARS] = {
 };
 #endif	/* MAC_GRAPHICS_ENV */
 
+#ifdef UTF8_GLYPHS
+/* Probably best to only use characters from this list
+ * http://en.wikipedia.org/wiki/WGL4 */
+static glyph_t utf8_graphics[MAXPCHARS] = {
+/* 0*/	g_FILLER(S_stone),
+	0x2502,	/* S_vwall:	BOX DRAWINGS LIGHT VERTICAL */
+	0x2500,	/* S_hwall:	BOX DRAWINGS LIGHT HORIZONTAL */
+	0x250c,	/* S_tlcorn:	BOX DRAWINGS LIGHT DOWN AND RIGHT */
+	0x2510,	/* S_trcorn:	BOX DRAWINGS LIGHT DOWN AND LEFT */
+	0x2514,	/* S_blcorn:	BOX DRAWINGS LIGHT UP AND RIGHT */
+	0x2518,	/* S_brcorn:	BOX DRAWINGS LIGHT UP AND LEFT */
+	0x253c,	/* S_crwall:	BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+	0x2534,	/* S_tuwall:	BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+	0x252c,	/* S_tdwall:	BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+	0x2524,	/* S_tlwall:	BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+	0x251c,	/* S_trwall:	BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+	0x00b7,	/* S_ndoor:	MIDDLE DOT */
+	0x2592,	/* S_vodoor:	MEDIUM SHADE */
+	0x2592,	/* S_hodoor:	MEDIUM SHADE */
+	g_FILLER(S_vcdoor),
+	g_FILLER(S_hcdoor),
+	0x2261,	/* S_bars:	IDENTICAL TO */
+	0x03a8,	/* S_tree:	GREEK CAPITAL LETTER PSI */
+	0x00b7,	/* S_room:	MIDDLE DOT */
+	g_FILLER(S_corr),
+	g_FILLER(S_litcorr),
+	g_FILLER(S_upstair),
+	g_FILLER(S_dnstair),
+	0x2264,	/* S_upladder:	LESS-THAN OR EQUAL TO */
+	0x2265,	/* S_dnladder:	GREATER-THAN OR EQUAL TO */
+	0x03A9,	/* S_altar:	GREEK CAPITAL LETTER OMEGA */
+	0x2020,	/* S_grave:	DAGGER */
+	g_FILLER(S_throne),
+	g_FILLER(S_sink),
+	0x00b6,	/* S_fountain:	PILCROW SIGN */
+	0x224b,	/* S_pool:	TRIPLE TILDE */
+	0x00b7,	/* S_ice:	MIDDLE DOT */
+	0x224b,	/* S_lava:	TRIPLE TILDE */
+	0x00b7,	/* S_vodbridge:	MIDDLE DOT */
+	0x00b7,	/* S_hodbridge:	MIDDLE DOT */
+	g_FILLER(S_vcdbridge),
+	g_FILLER(S_hcdbridge),
+	g_FILLER(S_air),
+	g_FILLER(S_cloud),
+	0x2248,	/* S_water:	ALMOST EQUAL TO */
+	g_FILLER(S_arrow_trap),
+	g_FILLER(S_dart_trap),
+	g_FILLER(S_falling_rock_trap),
+	g_FILLER(S_squeaky_board),
+	g_FILLER(S_bear_trap),
+	g_FILLER(S_land_mine),
+	g_FILLER(S_rolling_boulder_trap),
+	g_FILLER(S_sleeping_gas_trap),
+	g_FILLER(S_rust_trap),
+	g_FILLER(S_fire_trap),
+	g_FILLER(S_pit),
+	g_FILLER(S_spiked_pit),
+	g_FILLER(S_hole),
+	g_FILLER(S_trap_door),
+	g_FILLER(S_teleportation_trap),
+	g_FILLER(S_level_teleporter),
+	g_FILLER(S_magic_portal),
+	0x00A4,	/* S_web:	CURRENCY SIGN */
+	g_FILLER(S_statue_trap),
+	g_FILLER(S_magic_trap),
+	g_FILLER(S_anti_magic_trap),
+	g_FILLER(S_polymorph_trap),
+	0x2502,	/* S_vbeam:	BOX DRAWINGS LIGHT VERTICAL */
+	0x2500,	/* S_hbeam:	BOX DRAWINGS LIGHT HORIZONTAL */
+	g_FILLER(S_lslant),
+	g_FILLER(S_rslant),
+	g_FILLER(S_digbeam),
+	g_FILLER(S_flashbeam),
+	g_FILLER(S_boomleft),
+	g_FILLER(S_boomright),
+	g_FILLER(S_ss1),
+	g_FILLER(S_ss2),
+	g_FILLER(S_ss3),
+	g_FILLER(S_ss4),
+	g_FILLER(S_sw_tl),
+	0x2594,	/* S_sw_tc:	UPPER ONE EIGHTH BLOCK */
+	g_FILLER(S_sw_tr),
+	0x258f,	/* S_sw_ml:	LEFT ONE EIGHTH BLOCK */
+	0x2595,	/* S_sw_mr:	RIGHT ONE EIGHTH BLOCK */
+	g_FILLER(S_sw_bl),
+	0x2581,	/* S_sw_bc:	LOWER ONE EIGHTH BLOCK */
+	g_FILLER(S_sw_br),
+	g_FILLER(S_explode1),
+	0x2594,	/* S_explode2:	UPPER ONE EIGHTH BLOCK */
+	g_FILLER(S_explode3),
+	0x258f,	/* S_explode4:	LEFT ONE EIGHTH BLOCK */
+	g_FILLER(S_explode5),
+	0x2595,	/* S_explode6:	RIGHT ONE EIGHTH BLOCK */
+	g_FILLER(S_explode7),
+	0x2581,	/* S_explode8:	LOWER ONE EIGHTH BLOCK */
+	g_FILLER(S_explode9)
+};
+#endif
+
 #ifdef PC9800
 void NDECL((*ascgraphics_mode_callback)) = 0;	/* set in tty_start_screen() */
 #endif
@@ -641,7 +748,7 @@ def_char_to_monclass(ch)
 
 void
 assign_graphics(graph_chars, glth, maxlen, offset)
-register uchar *graph_chars;
+register glyph_t *graph_chars;
 int glth, maxlen, offset;
 {
     register int i;
@@ -651,14 +758,32 @@ int glth, maxlen, offset;
 		       graph_chars[i] : defsyms[i+offset].sym);
 }
 
+#ifdef USER_DUNGEONCOLOR
+void
+assign_colors(graph_colors, glth, maxlen, offset)
+register uchar *graph_colors;
+int glth, maxlen, offset;
+{
+    register int i;
+
+    for (i = 0; i < maxlen; i++)
+	showsymcolors[i+offset] =
+	    (((i < glth) && (graph_colors[i] < CLR_MAX)) ?
+	     graph_colors[i] : defsyms[i+offset].color);
+}
+#endif
+
 void
 switch_graphics(gr_set_flag)
 int gr_set_flag;
 {
+    iflags.IBMgraphics = FALSE;
+    iflags.DECgraphics = FALSE;
+    iflags.UTF8graphics = FALSE;
     switch (gr_set_flag) {
 	default:
 	case ASCII_GRAPHICS:
-	    assign_graphics((uchar *)0, 0, MAXPCHARS, 0);
+	    assign_graphics((glyph_t *)0, 0, MAXPCHARS, 0);
 #ifdef PC9800
 	    if (ascgraphics_mode_callback) (*ascgraphics_mode_callback)();
 #endif
@@ -674,6 +799,9 @@ int gr_set_flag;
  */
 	    iflags.IBMgraphics = TRUE;
 	    iflags.DECgraphics = FALSE;
+#ifdef CURSES_GRAPHICS
+        iflags.cursesgraphics = FALSE;
+#endif
 	    assign_graphics(ibm_graphics, SIZE(ibm_graphics), MAXPCHARS, 0);
 #ifdef PC9800
 	    if (ibmgraphics_mode_callback) (*ibmgraphics_mode_callback)();
@@ -687,6 +815,9 @@ int gr_set_flag;
  */
 	    iflags.DECgraphics = TRUE;
 	    iflags.IBMgraphics = FALSE;
+#ifdef CURSES_GRAPHICS
+        iflags.cursesgraphics = FALSE;
+#endif
 	    assign_graphics(dec_graphics, SIZE(dec_graphics), MAXPCHARS, 0);
 	    if (decgraphics_mode_callback) (*decgraphics_mode_callback)();
 	    break;
@@ -696,10 +827,41 @@ int gr_set_flag;
 	    assign_graphics(mac_graphics, SIZE(mac_graphics), MAXPCHARS, 0);
 	    break;
 #endif
+#ifdef UTF8_GLYPHS
+	case UTF8_GRAPHICS:
+	    assign_graphics(utf8_graphics, SIZE(utf8_graphics), MAXPCHARS, 0);
+	    iflags.UTF8graphics = TRUE;
+	    break;
+#endif
+#ifdef CURSES_GRAPHICS
+    case CURS_GRAPHICS:
+	    assign_graphics((glyph_t *)0, 0, MAXPCHARS, 0);
+        iflags.cursesgraphics = TRUE;
+	    iflags.IBMgraphics = FALSE;
+	    iflags.DECgraphics = FALSE;
+        break;
+#endif
 	}
     return;
 }
 
+/** Change the UTF8graphics symbol at position with codepoint "value". */
+void
+assign_utf8graphics_symbol(position, value)
+int position;
+glyph_t value;
+{
+#ifdef UTF8_GLYPHS
+	if (position < MAXPCHARS) {
+		utf8_graphics[position] = value;
+		/* need to update showsym */
+		if (iflags.UTF8graphics) {
+			switch_graphics(UTF8_GRAPHICS);
+		}
+	}
+#endif
+}
+
 
 #ifdef REINCARNATION
 
@@ -707,10 +869,10 @@ int gr_set_flag;
  * saved display symbols for objects & features.
  */
 static uchar save_oc_syms[MAXOCLASSES] = DUMMY;
-static uchar save_showsyms[MAXPCHARS]  = DUMMY;
+static glyph_t save_showsyms[MAXPCHARS]  = DUMMY;
 static uchar save_monsyms[MAXPCHARS]   = DUMMY;
 
-static const uchar r_oc_syms[MAXOCLASSES] = {
+static const glyph_t r_oc_syms[MAXOCLASSES] = {
 /* 0*/	'\0',
 	ILLOBJ_SYM,
 	WEAPON_SYM,
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/dungeon.c nethack-3.4.3-nao-osx/src/dungeon.c
--- nethack-3.4.3/src/dungeon.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/dungeon.c	2014-12-20 12:08:36.000000000 -0800
@@ -632,6 +632,10 @@ struct level_map {
 	{ "wizard1",	&wiz1_level },
 	{ "wizard2",	&wiz2_level },
 	{ "wizard3",	&wiz3_level },
+#ifdef RECORD_ACHIEVE
+        { "minend",     &mineend_level },
+        { "soko1",      &sokoend_level },
+#endif
 	{ X_START,	&qstart_level },
 	{ X_LOCATE,	&qlocate_level },
 	{ X_GOAL,	&nemesis_level },
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/eat.c nethack-3.4.3-nao-osx/src/eat.c
--- nethack-3.4.3/src/eat.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/eat.c	2014-12-20 12:08:36.000000000 -0800
@@ -862,7 +862,7 @@ register int pm;
                     /* A pile of gold can't ride. */
 		    if (u.usteed) dismount_steed(DISMOUNT_FELL);
 #endif
-		    nomul(-tmp);
+		    nomul(-tmp, "pretending to be a pile of gold");
 		    Sprintf(buf, Hallucination ?
 			"You suddenly dread being peeled and mimic %s again!" :
 			"You now prefer mimicking %s again.",
@@ -1224,7 +1224,7 @@ struct obj *obj;
 			   surface(u.ux,u.uy);
 		pline_The("world spins and %s %s.", what, where);
 		flags.soundok = 0;
-		nomul(-rnd(10));
+		nomul(-rnd(10), "unconscious from rotten food");
 		nomovemsg = "You are conscious again.";
 		afternmv = Hear_again;
 		return(1);
@@ -2244,7 +2244,7 @@ is_fainted()
 void
 reset_faint()	/* call when a faint must be prematurely terminated */
 {
-	if(is_fainted()) nomul(0);
+	if(is_fainted()) nomul(0, NULL);
 }
 
 #if 0
@@ -2255,7 +2255,7 @@ sync_hunger()
 	if(is_fainted()) {
 
 		flags.soundok = 0;
-		nomul(-10+(u.uhunger/10));
+		nomul(-10+(u.uhunger/10), "fainted from lack of food");
 		nomovemsg = "You regain consciousness.";
 		afternmv = unfaint;
 	}
@@ -2320,7 +2320,7 @@ boolean incr;
 				stop_occupation();
 				You("faint from lack of food.");
 				flags.soundok = 0;
-				nomul(-10+(u.uhunger/10));
+				nomul(-10+(u.uhunger/10), "fainted from lack of food");
 				nomovemsg = "You regain consciousness.";
 				afternmv = unfaint;
 				newhs = FAINTED;
@@ -2489,7 +2489,7 @@ void
 vomit()		/* A good idea from David Neves */
 {
 	make_sick(0L, (char *) 0, TRUE, SICK_VOMITABLE);
-	nomul(-2);
+	nomul(-2, "vomiting");
 }
 
 int
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/end.c nethack-3.4.3-nao-osx/src/end.c
--- nethack-3.4.3/src/end.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/end.c	2014-12-20 12:08:36.000000000 -0800
@@ -10,6 +10,10 @@
 #include <signal.h>
 #endif
 #include "dlb.h"
+#ifdef UNIX /* DUMP-patch dump filename chmod() */
+#include <sys/types.h>
+#include <sys/stat.h>
+#endif
 
 	/* these probably ought to be generated by makedefs, like LAST_GEM */
 #define FIRST_GEM    DILITHIUM_CRYSTAL
@@ -39,8 +43,16 @@ STATIC_DCL void FDECL(get_valuables, (st
 STATIC_DCL void FDECL(sort_valuables, (struct valuable_data *,int));
 STATIC_DCL void FDECL(artifact_score, (struct obj *,BOOLEAN_P,winid));
 STATIC_DCL void FDECL(savelife, (int));
-STATIC_DCL void FDECL(list_vanquished, (CHAR_P,BOOLEAN_P));
+void FDECL(list_vanquished, (CHAR_P,BOOLEAN_P));
+#ifdef DUMP_LOG
+extern char msgs[][BUFSZ];
+extern int lastmsg;
+extern void NDECL(dump_spells);
+void FDECL(do_vanquished, (int, BOOLEAN_P, BOOLEAN_P));
+STATIC_DCL void FDECL(list_genocided, (int, BOOLEAN_P, BOOLEAN_P));
+#else
 STATIC_DCL void FDECL(list_genocided, (CHAR_P,BOOLEAN_P));
+#endif /* DUMP_LOG */
 STATIC_DCL boolean FDECL(should_query_disclose_option, (int,char *));
 
 #if defined(__BEOS__) || defined(MICRO) || defined(WIN32) || defined(OS2)
@@ -86,6 +98,177 @@ static NEARDATA const char *ends[] = {		
 
 extern const char * const killed_by_prefix[];	/* from topten.c */
 
+char *
+dump_format_str(char *str)
+{
+    static char buf[512];
+    char *f, *p, *end;
+    int ispercent = 0;
+
+    buf[0] = '\0';
+
+    if (!str) return NULL;
+
+    f = str;
+    p = buf;
+    end = buf + sizeof(buf) - 10;
+
+    while (*f) {
+      if (ispercent) {
+	switch (*f) {
+	case 't':
+	  snprintf (p, end + 1 - p, "%ld", u.ubirthday);
+	  while (*p != '\0')
+	    p++;
+	  break;
+        case 'N':
+          *p = plname[0];
+	  p++;
+	  *p = '\0';
+	  break;
+	case 'n':
+	  snprintf (p, end + 1 - p, "%s", plname);
+	  while (*p != '\0')
+	    p++;
+	  break;
+	default:
+	  *p = *f;
+	  if (p < end)
+	    p++;
+	}
+	ispercent = 0;
+      } else {
+	if (*f == '%')
+	  ispercent = 1;
+	else {
+	  *p = *f;
+	  if (p < end)
+	    p++;
+	}
+      }
+      f++;
+    }
+    *p = '\0';
+
+    return buf;
+}
+
+
+
+#ifdef DUMP_LOG
+FILE *dump_fp = (FILE *)0;  /* file pointer for dumps */
+/* functions dump_init, dump_exit and dump are from the dump patch */
+
+void
+dump_init ()
+{
+  if (dump_fn[0]) {
+#ifdef UNIX
+    mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+#endif
+    char new_dump_fn[512];
+    Sprintf(new_dump_fn, "%s", dump_format_str(dump_fn));
+
+    dump_fp = fopen(new_dump_fn, "w");
+#ifdef UNIX
+    chmod(new_dump_fn, dumpmode);
+#endif
+    if (!dump_fp) {
+      pline("Can't open %s for output.", new_dump_fn);
+      pline("Dump file not created.");
+    }
+  }
+}
+
+void
+dump_exit ()
+{
+  if (dump_fp)
+    fclose (dump_fp);
+}
+
+
+void
+mk_dgl_extrainfo()
+{
+#ifdef EXTRAINFO_FN
+    FILE *extrai = (FILE *)0;
+#ifdef UNIX
+    mode_t eimode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+#endif
+    char new_fn[512];
+
+    Sprintf(new_fn, "%s", dump_format_str(EXTRAINFO_FN));
+
+    extrai = fopen(new_fn, "w");
+    if (!extrai) {
+    } else {
+	int sortval = 0;
+	char tmpdng[16];
+	sortval += (u.uhave.amulet ? 1024 : 0);
+	if (Is_knox(&u.uz)) {
+	    Sprintf(tmpdng, "%s", "Knx");
+	    sortval += 245;
+	} else if (In_quest(&u.uz)) {
+	    Sprintf(tmpdng, "%s%i", "Q", dunlev(&u.uz));
+	    sortval += 250+(dunlev(&u.uz));
+	} else if (In_endgame(&u.uz)) {
+	    Sprintf(tmpdng, "%s", "End");
+	    sortval += 256;
+	} else if (In_tower(&u.uz)) {
+	    Sprintf(tmpdng, "T%i", dunlev(&u.uz));
+	    sortval += 235+(depth(&u.uz));
+	} else if (In_sokoban(&u.uz)) {
+	    Sprintf(tmpdng, "S%i", dunlev(&u.uz));
+	    sortval += 225+(depth(&u.uz));
+	} else if (In_mines(&u.uz)) {
+	    Sprintf(tmpdng, "M%i", dunlev(&u.uz));
+	    sortval += 215+(dunlev(&u.uz));
+	} else {
+	    Sprintf(tmpdng, "D%i", depth(&u.uz));
+	    sortval += (depth(&u.uz));
+	}
+#ifdef UNIX
+	chmod(new_fn, eimode);
+#endif
+	fprintf(extrai, "%i|%c %s", sortval, (u.uhave.amulet ? 'A' : ' '), tmpdng);
+	fclose(extrai);
+    }
+#endif /* EXTRAINFO_FN */
+}
+
+void
+mk_mapdump(char *fname)
+{
+  if (fname[0]) {
+#ifdef UNIX
+    mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+#endif
+    char new_dump_fn[512];
+    Sprintf(new_dump_fn, "%s", dump_format_str(fname));
+
+    dump_fp = fopen(new_dump_fn, "w");
+    if (!dump_fp) {
+      pline("Can't open %s for output.", new_dump_fn);
+      pline("Dump file not created.");
+    } else {
+#ifdef UNIX
+	chmod(new_dump_fn, dumpmode);
+#endif
+	dump_screen(1);
+	dump_exit();
+    }
+  }
+}
+
+void dump (pre, str)
+     char *pre, *str;
+{
+  if (dump_fp)
+    fprintf (dump_fp, "%s%s\n", pre, str);
+}
+#endif  /* DUMP_LOG */
+
 /*ARGSUSED*/
 void
 done1(sig_unused)   /* called as signal() handler, so sent at least one arg */
@@ -101,7 +284,7 @@ int sig_unused;
 		clear_nhwindow(WIN_MESSAGE);
 		curs_on_u();
 		wait_synch();
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0, NULL);
 	} else {
 		(void)done2();
 	}
@@ -112,14 +295,28 @@ int sig_unused;
 int
 done2()
 {
+#ifdef PARANOID
+	char buf[BUFSZ];
+	int really_quit = FALSE;
+
+	if (iflags.paranoid_quit) {
+	  getlin ("Really quit [yes/no]?",buf);
+	  (void) lcase (buf);
+	  if (!(strcmp (buf, "yes"))) really_quit = TRUE;
+	} else {
+	  if(yn("Really quit?") == 'y') really_quit = TRUE;
+	}
+	if (!really_quit) {
+#else /* PARANOID */
 	if(yn("Really quit?") == 'n') {
+#endif /* PARANOID */
 #ifndef NO_SIGNAL
 		(void) signal(SIGINT, (SIG_RET_TYPE) done1);
 #endif
 		clear_nhwindow(WIN_MESSAGE);
 		curs_on_u();
 		wait_synch();
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0, NULL);
 		if(multi == 0) {
 		    u.uinvulnerable = FALSE;	/* avoid ctrl-C bug -dlc */
 		    u.usleep = 0;
@@ -224,7 +421,12 @@ register struct monst *mtmp;
 		    Sprintf(eos(buf), " called %s", NAME(mtmp));
 	}
 
-	if (multi) Strcat(buf, ", while helpless");
+	if (multi) {
+	    if (strlen(multi_txt) > 0)
+		Sprintf(eos(buf), ", while %s", multi_txt);
+	    else
+		Strcat(buf, ", while helpless");
+	}
 	killer = buf;
 	if (mtmp->data->mlet == S_WRAITH)
 		u.ugrave_arise = PM_WRAITH;
@@ -366,18 +568,30 @@ boolean taken;
 	    ask = should_query_disclose_option('i', &defquery);
 	    if (!done_stopprint) {
 		c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
-		if (c == 'y') {
+	    } else {
+		c = 'n';
+	    }
+		{
+#ifdef DUMP_LOG
+			boolean want_disp = (c == 'y')? TRUE: FALSE;
+#endif
 			struct obj *obj;
 
 			for (obj = invent; obj; obj = obj->nobj) {
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
 			}
+#ifdef DUMP_LOG
+			(void) dump_inventory((char *)0, TRUE, want_disp);
+			do_containerconts(invent, TRUE, TRUE, TRUE, want_disp);
+#else
+			if (c == 'y') {
 			(void) display_inventory((char *)0, TRUE);
 			container_contents(invent, TRUE, TRUE);
 		}
-		if (c == 'q')  done_stopprint++;
+#endif /* DUMP_LOG */
 	    }
+		if (c == 'q')  done_stopprint++;
 	}
 
 	ask = should_query_disclose_option('a', &defquery);
@@ -388,14 +602,28 @@ boolean taken;
 		enlightenment(how >= PANICKED ? 1 : 2); /* final */
 	    if (c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	  dump_enlightenment((int) (how >= PANICKED ? 1 : 2));
+	  dump_spells();
+	}
+#endif
 
 	ask = should_query_disclose_option('v', &defquery);
+#ifdef DUMP_LOG
+	do_vanquished(defquery, ask, TRUE);
+#else
 	if (!done_stopprint)
 	    list_vanquished(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('g', &defquery);
 	if (!done_stopprint)
+#ifdef DUMP_LOG
+	    list_genocided(defquery, ask,TRUE);
+#else
 	    list_genocided(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('c', &defquery);
 	if (!done_stopprint) {
@@ -405,6 +633,12 @@ boolean taken;
 		show_conduct(how >= PANICKED ? 1 : 2);
 	    if (c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	    dump_conduct(how >= PANICKED ? 1 : 2);
+	    dump_weapon_skill();
+	}
+#endif
 }
 
 /* try to get the player back in a viable state after being killed */
@@ -523,6 +757,11 @@ winid endwin;
 			otmp->oartifact ? artifact_name(xname(otmp), &dummy) :
 				OBJ_NAME(objects[otmp->otyp]),
 			value, currency(value), points);
+#ifdef DUMP_LOG
+		if (dump_fp)
+		  dump("", pbuf);
+		if (endwin != WIN_ERR)
+#endif
 		putstr(endwin, 0, pbuf);
 	    }
 	}
@@ -536,12 +775,17 @@ void
 done(how)
 int how;
 {
+#if defined(WIZARD) && defined(PARANOID)
+	char paranoid_buf[BUFSZ];
+	int really_bon = TRUE;
+#endif
 	boolean taken;
 	char kilbuf[BUFSZ], pbuf[BUFSZ];
 	winid endwin = WIN_ERR;
 	boolean bones_ok, have_windows = iflags.window_inited;
 	struct obj *corpse = (struct obj *)0;
 	long umoney;
+	int i;
 
 	if (how == TRICKED) {
 	    if (killer) {
@@ -588,6 +832,7 @@ int how;
 		else {
 			killer = 0;
 			killer_format = 0;
+			livelog_write_string("averted death");
 			return;
 		}
 	}
@@ -614,12 +859,39 @@ die:
 	program_state.gameover = 1;
 	/* in case of a subsequent panic(), there's no point trying to save */
 	program_state.something_worth_saving = 0;
+#ifdef DUMP_LOG
+	/* D: Grab screen dump right here */
+	if (dump_fn[0]) {
+	  dump_init();
+	  Sprintf(pbuf, "%s, %s %s %s %s", plname,
+		  aligns[1 - u.ualign.type].adj,
+		  genders[flags.female].adj,
+		  urace.adj,
+		  (flags.female && urole.name.f)?
+		   urole.name.f : urole.name.m);
+	  dump("", pbuf);
+	  /* D: Add a line for clearance from the screen dump */
+	  dump("", "");
+	  dump_screen(0);
+	}
+#endif /* DUMP_LOG */
+
+#ifdef WHEREIS_FILE
+	delete_whereis();
+#endif
+
 	/* render vision subsystem inoperative */
 	iflags.vision_inited = 0;
 	/* might have been killed while using a disposable item, so make sure
 	   it's gone prior to inventory disclosure and creation of bones data */
 	inven_inuse(TRUE);
 
+#ifdef RECORD_REALTIME
+        /* Update the realtime counter to reflect the playtime of the current
+         * game. */
+        realtime_data.realtime = get_realtime();
+#endif /* RECORD_REALTIME */
+
 	/* Sometimes you die on the first move.  Life's not fair.
 	 * On those rare occasions you get hosed immediately, go out
 	 * smiling... :-)  -3.
@@ -692,8 +964,23 @@ die:
 
 	if (have_windows) display_nhwindow(WIN_MESSAGE, FALSE);
 
-	if (strcmp(flags.end_disclose, "none") && how != PANICKED)
+	if (strcmp(flags.end_disclose, "none") && how != PANICKED) {
 		disclose(how, taken);
+#if defined(DUMP_LOG) && defined(DUMPMSGS)
+		if (lastmsg >= 0) {
+		  dump ("", "Latest messages");
+		  for (i = lastmsg + 1; i < DUMPMSGS; i++) {
+		    if (msgs[i] && strcmp(msgs[i], "") )
+		      dump ("  ", msgs[i]);
+		  } 
+		  for (i = 0; i <= lastmsg; i++) {
+		    if (msgs[i] && strcmp(msgs[i], "") )
+		      dump ("  ", msgs[i]);
+		  } 
+		  dump ("","");
+		}
+#endif
+	}
 	/* finish_paybill should be called after disclosure but before bones */
 	if (bones_ok && taken) finish_paybill();
 
@@ -725,14 +1012,31 @@ die:
 
 	if (bones_ok) {
 #ifdef WIZARD
+# ifdef PARANOID
+	    if(wizard) {
+		getlin("Save WIZARD MODE bones? [no/yes]", paranoid_buf);
+		(void) lcase (paranoid_buf);
+		if (strcmp (paranoid_buf, "yes"))
+		  really_bon = FALSE;
+            }
+            if(really_bon)
+# else
 	    if (!wizard || yn("Save bones?") == 'y')
-#endif
+#endif /* PARANOID */
+#endif /* WIZARD */
 		savebones(corpse);
 	    /* corpse may be invalid pointer now so
 		ensure that it isn't used again */
 	    corpse = (struct obj *)0;
 	}
 
+	/* AIS: don't leak info about whether bones were left */
+	else if (u.ugrave_arise >= LOW_PM && u.ugrave_arise != (NON_PM - 1)
+		 && how < GENOCIDED) {
+	    Your("body rises from the dead as %s...",
+		    an(mons[u.ugrave_arise].mname));
+	}
+
 	/* update gold for the rip output, which can't use hidden_gold()
 	   (containers will be gone by then if bones just got saved...) */
 #ifndef GOLDOBJ
@@ -761,24 +1065,33 @@ die:
 /* changing kilbuf really changes killer. we do it this way because
    killer is declared a (const char *)
 */
-	if (u.uhave.amulet) Strcat(kilbuf, " (with the Amulet)");
+	if (u.uhave.amulet) {
+	    Strcat(kilbuf, " (with the Amulet)");
+	    killer_flags |= 0x1;
+	}
 	else if (how == ESCAPED) {
-	    if (Is_astralevel(&u.uz))	/* offered Amulet to wrong deity */
+	    if (Is_astralevel(&u.uz)) {	/* offered Amulet to wrong deity */
 		Strcat(kilbuf, " (in celestial disgrace)");
-	    else if (carrying(FAKE_AMULET_OF_YENDOR))
+		killer_flags |= 0x2;
+	    } else if (carrying(FAKE_AMULET_OF_YENDOR)) {
 		Strcat(kilbuf, " (with a fake Amulet)");
+		killer_flags |= 0x4;
+	    }
 		/* don't bother counting to see whether it should be plural */
 	}
 
-	if (!done_stopprint) {
 	    Sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
 		   how != ASCENDED ?
 		      (const char *) ((flags.female && urole.name.f) ?
 		         urole.name.f : urole.name.m) :
 		      (const char *) (flags.female ? "Demigoddess" : "Demigod"));
+	if (!done_stopprint) {
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) dump("", pbuf);
+#endif
 
 	if (how == ESCAPED || how == ASCENDED) {
 	    register struct monst *mtmp;
@@ -805,31 +1118,39 @@ die:
 	    keepdogs(TRUE);
 	    viz_array[0][0] |= IN_SIGHT; /* need visibility for naming */
 	    mtmp = mydogs;
-	    if (!done_stopprint) Strcpy(pbuf, "You");
+	    Strcpy(pbuf, "You");
 	    if (mtmp) {
 		while (mtmp) {
-		    if (!done_stopprint)
 			Sprintf(eos(pbuf), " and %s", mon_nam(mtmp));
 		    if (mtmp->mtame)
 			u.urexp += mtmp->mhp;
 		    mtmp = mtmp->nmon;
 		}
 		if (!done_stopprint) putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+		if (dump_fp) dump("", pbuf);
+#endif
 		pbuf[0] = '\0';
 	    } else {
 		if (!done_stopprint) Strcat(pbuf, " ");
 	    }
-	    if (!done_stopprint) {
 		Sprintf(eos(pbuf), "%s with %ld point%s,",
 			how==ASCENDED ? "went to your reward" :
 					"escaped from the dungeon",
 			u.urexp, plur(u.urexp));
+#ifdef DUMP_LOG
+	    if (dump_fp) dump("", pbuf);
+#endif
+	    if (!done_stopprint) {
 		putstr(endwin, 0, pbuf);
 	    }
 
 	    if (!done_stopprint)
 		artifact_score(invent, FALSE, endwin);	/* list artifacts */
-
+#ifdef DUMP_LOG
+	    else
+		artifact_score(invent, FALSE, WIN_ERR);
+#endif
 	    /* list valuables here */
 	    for (val = valuables; val->list; val++) {
 		sort_valuables(val->list, val->size);
@@ -855,10 +1176,13 @@ die:
 				count, plur(count));
 		    }
 		    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+		    if (dump_fp) dump("", pbuf);
+#endif
 		}
 	    }
 
-	} else if (!done_stopprint) {
+	} else {
 	    /* did not escape or ascend */
 	    if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
 		/* level teleported out of the dungeon; `how' is DIED,
@@ -878,21 +1202,32 @@ die:
 
 	    Sprintf(eos(pbuf), " with %ld point%s,",
 		    u.urexp, plur(u.urexp));
-	    putstr(endwin, 0, pbuf);
+	    if (!done_stopprint) putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fp) dump("", pbuf);
+#endif
 	}
 
-	if (!done_stopprint) {
 	    Sprintf(pbuf, "and %ld piece%s of gold, after %ld move%s.",
 		    umoney, plur(umoney), moves, plur(moves));
-	    putstr(endwin, 0, pbuf);
+	if (!done_stopprint)  putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	if (dump_fp) {
+	  dump("", pbuf);
+	  Sprintf(pbuf, "Killer: %s", killer);
+	  dump("", pbuf);
 	}
-	if (!done_stopprint) {
+#endif
 	    Sprintf(pbuf,
 	     "You were level %d with a maximum of %d hit point%s when you %s.",
 		    u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
+	if (!done_stopprint) {
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
 	}
+#ifdef DUMP_LOG
+	    if (dump_fp) dump("", pbuf);
+#endif
 	if (!done_stopprint)
 	    display_nhwindow(endwin, TRUE);
 	if (endwin != WIN_ERR)
@@ -909,6 +1244,9 @@ die:
 		exit_nhwindows((char *)0);
 	    topten(how);
 	}
+#ifdef DUMP_LOG
+	if (dump_fp) dump_exit();
+#endif
 
 	if(done_stopprint) { raw_print(""); raw_print(""); }
 	terminate(EXIT_SUCCESS);
@@ -919,8 +1257,23 @@ void
 container_contents(list, identified, all_containers)
 struct obj *list;
 boolean identified, all_containers;
+#ifdef DUMP_LOG
+{
+	do_containerconts(list, identified, all_containers, FALSE, TRUE);
+}
+
+void do_containerconts(list, identified, all_containers, want_dump, want_disp)
+struct obj *list;
+boolean identified, all_containers, want_dump, want_disp;
+#endif
+/* The original container_contents function */
 {
 	register struct obj *box, *obj;
+#ifdef SORTLOOT
+	struct obj **oarray;
+	int i,j,n;
+	char *invlet;
+#endif /* SORTLOOT */
 	char buf[BUFSZ];
 
 	for (box = list; box; box = box->nobj) {
@@ -928,25 +1281,101 @@ boolean identified, all_containers;
 		if (box->otyp == BAG_OF_TRICKS) {
 		    continue;	/* wrong type of container */
 		} else if (box->cobj) {
-		    winid tmpwin = create_nhwindow(NHW_MENU);
+		    winid tmpwin;
+#ifdef DUMP_LOG
+		    if (want_disp)
+#endif
+		    tmpwin = create_nhwindow(NHW_MENU);
+#ifdef SORTLOOT
+		    /* count the number of items */
+		    for (n = 0, obj = box->cobj; obj; obj = obj->nobj) n++;
+		    /* Make a temporary array to store the objects sorted */
+		    oarray = (struct obj **) alloc(n*sizeof(struct obj*));
+
+		    /* Add objects to the array */
+		    i = 0;
+		    invlet = flags.inv_order;
+		nextclass:
+		    for (obj = box->cobj; obj; obj = obj->nobj) {
+                      if (!flags.sortpack || obj->oclass == *invlet) {
+			if (iflags.sortloot == 'f'
+			    || iflags.sortloot == 'l') {
+			  /* Insert object at correct index */
+			  for (j = i; j; j--) {
+			    if (sortloot_cmp(obj, oarray[j-1])>0
+			    || (flags.sortpack &&
+				oarray[j-1]->oclass != obj->oclass))
+			      break;
+			    oarray[j] = oarray[j-1];
+			  }
+			  oarray[j] = obj;
+			  i++;
+			} else {
+			  /* Just add it to the array */
+			  oarray[i++] = obj;
+			}
+		      }
+		    } /* for loop */
+		    if (flags.sortpack) {
+		      if (*++invlet) goto nextclass;
+		    }
+#endif /* SORTLOOT */
 		    Sprintf(buf, "Contents of %s:", the(xname(box)));
+#ifdef DUMP_LOG
+		    if (want_disp) {
+#endif
 		    putstr(tmpwin, 0, buf);
 		    putstr(tmpwin, 0, "");
+#ifdef DUMP_LOG
+		    }
+		    if (dump_fp) dump("", buf);
+#endif
+#ifdef SORTLOOT
+		    for (i = 0; i < n; i++) {
+		      obj = oarray[i];
+#else
 		    for (obj = box->cobj; obj; obj = obj->nobj) {
+#endif
 			if (identified) {
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown =
 			    obj->dknown = obj->rknown = 1;
 			}
+#ifdef DUMP_LOG
+			if (want_dump)  dump("  ", doname(obj));
+			if (want_disp)
+#endif
 			putstr(tmpwin, 0, doname(obj));
 		    }
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("","");
+		    if (want_disp) {
+#endif
 		    display_nhwindow(tmpwin, TRUE);
 		    destroy_nhwindow(tmpwin);
-		    if (all_containers)
+#ifdef DUMP_LOG
+		    }
+		    if (all_containers) {
+			do_containerconts(box->cobj, identified, TRUE,
+					  want_dump, want_disp);
+#else
+		    if (all_containers) {
 			container_contents(box->cobj, identified, TRUE);
+#endif /* DUMP_LOG */
+		    }
 		} else {
+#ifdef DUMP_LOG
+		    if (want_disp) {
+#endif
 		    pline("%s empty.", Tobjnam(box, "are"));
 		    display_nhwindow(WIN_MESSAGE, FALSE);
+#ifdef DUMP_LOG
+		    }
+		    if (want_dump) {
+		      dump(The(xname(box)), " is empty.");
+		      dump("", "");
+		    }
+#endif
 		}
 	    }
 	    if (!all_containers)
@@ -973,10 +1402,21 @@ int status;
 	nethack_exit(status);
 }
 
-STATIC_OVL void
+void		/* showborn patch */
 list_vanquished(defquery, ask)
 char defquery;
 boolean ask;
+#ifdef DUMP_LOG
+{
+  do_vanquished(defquery, ask, FALSE);
+}
+
+void
+do_vanquished(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#endif
 {
     register int i, lev;
     int ntypes = 0, max_lev = 0, nkilled;
@@ -996,13 +1436,22 @@ boolean ask;
      * includes all dead monsters, not just those killed by the player
      */
     if (ntypes != 0) {
-	c = ask ? yn_function("Do you want an account of creatures vanquished?",
+#ifdef DUMP_LOG
+	c = done_stopprint ? 'n': ask ?
+#else
+	c = ask ?
+#endif
+	  yn_function("Do you want an account of creatures vanquished?",
 			      ynqchars, defquery) : defquery;
 	if (c == 'q') done_stopprint++;
 	if (c == 'y') {
 	    klwin = create_nhwindow(NHW_MENU);
 	    putstr(klwin, 0, "Vanquished creatures:");
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	} /* the original end of block removed by the patch */
+	    if (want_dump)  dump("", "Vanquished creatures");
+#endif
 
 	    /* countdown by monster "toughness" */
 	    for (lev = max_lev; lev >= 0; lev--)
@@ -1029,21 +1478,38 @@ boolean ask;
 			else
 			    Sprintf(buf, "%d %s",
 				    nkilled, makeplural(mons[i].mname));
+#ifdef SHOW_BORN
+			if (iflags.show_born && nkilled != mvitals[i].born)
+			    Sprintf(buf + strlen(buf), " (%d created)",
+				    (int) mvitals[i].born);
+#endif
 		    }
-		    putstr(klwin, 0, buf);
+		    if (c == 'y') putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("  ", buf);
+#endif
 		}
 	    /*
 	     * if (Hallucination)
 	     *     putstr(klwin, 0, "and a partridge in a pear tree");
 	     */
 	    if (ntypes > 1) {
-		putstr(klwin, 0, "");
+		if (c == 'y') putstr(klwin, 0, "");
 		Sprintf(buf, "%ld creatures vanquished.", total_killed);
-		putstr(klwin, 0, buf);
+		if (c == 'y') putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		if (want_dump)  dump("  ", buf);
+#endif
 	    }
+	    if (c == 'y') {
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
 	}
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("", "");
+#else
+	} /* the original end of if (c == 'y') */
+#endif
     }
 }
 
@@ -1059,43 +1525,112 @@ num_genocides()
     return n;
 }
 
+#ifdef DUMP_LOG
+STATIC_OVL void
+list_genocided(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#else
 STATIC_OVL void
 list_genocided(defquery, ask)
 char defquery;
 boolean ask;
+#endif
 {
     register int i;
-    int ngenocided;
+    int ngenocided=0;
+#ifdef SHOW_EXTINCT
+    int nextincted=0;
+#endif
     char c;
     winid klwin;
     char buf[BUFSZ];
 
+    /* get totals first */
+#ifdef SHOW_EXTINCT
+    for (i = LOW_PM; i < NUMMONS; i++) {
+	if (mvitals[i].mvflags & G_GENOD)
+	    ngenocided++;
+	else if ( (mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ) )
+	    nextincted++;
+    }
     ngenocided = num_genocides();
+#endif
 
     /* genocided species list */
-    if (ngenocided != 0) {
+    if (ngenocided != 0
+#ifdef SHOW_EXTINCT
+      || nextincted != 0
+#endif
+    ) {
+#ifdef SHOW_EXTINCT
+	if (nextincted != 0)
+	  c = ask ?
+	  yn_function("Do you want a list of species genocided or extinct?",
+		      ynqchars, defquery) : defquery;
+       else
+#endif
 	c = ask ? yn_function("Do you want a list of species genocided?",
 			      ynqchars, defquery) : defquery;
 	if (c == 'q') done_stopprint++;
 	if (c == 'y') {
 	    klwin = create_nhwindow(NHW_MENU);
-	    putstr(klwin, 0, "Genocided species:");
+#ifdef SHOW_EXTINCT
+	    Sprintf(buf, "Genocided or extinct species:");
+#else
+	    Sprintf(buf, "Genocided species:");
+#endif
+	    putstr(klwin, 0, buf);
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	    if (want_dump)  dump("", buf);
+#endif
 
 	    for (i = LOW_PM; i < NUMMONS; i++)
+#ifdef SHOW_EXTINCT
+	      if (mvitals[i].mvflags & G_GONE && !(mons[i].geno & G_UNIQ) ){
+#else
 		if (mvitals[i].mvflags & G_GENOD) {
+#endif
 		    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
 			Sprintf(buf, "%s%s",
 				!type_is_pname(&mons[i]) ? "" : "the ",
 				mons[i].mname);
 		    else
 			Strcpy(buf, makeplural(mons[i].mname));
+#ifdef SHOW_EXTINCT
+		    if( !(mvitals[i].mvflags & G_GENOD) )
+			Strcat(buf, " (extinct)");
+#endif
 		    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)  dump("  ", buf);
+#endif
 		}
 
 	    putstr(klwin, 0, "");
-	    Sprintf(buf, "%d species genocided.", ngenocided);
-	    putstr(klwin, 0, buf);
+#ifdef SHOW_EXTINCT
+	    if (ngenocided>0) {
+#endif
+	      Sprintf(buf, "%d species genocided.", ngenocided);
+	      putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+	      if (want_dump)  dump("  ", buf);
+#endif
+#ifdef SHOW_EXTINCT
+	    }
+	    if (nextincted>0) {
+	      Sprintf(buf, "%d species extinct.", nextincted);
+	      putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+	      if (want_dump) dump(" ", buf);
+#endif
+            }
+#endif /* SHOW_EXTINCT */
+#ifdef DUMP_LOG
+	      if (want_dump)  dump("", "");
+#endif
 
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/engrave.c nethack-3.4.3-nao-osx/src/engrave.c
--- nethack-3.4.3/src/engrave.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/engrave.c	2014-12-20 12:08:36.000000000 -0800
@@ -33,6 +33,26 @@ static const char *random_mesg[] = {
 	"You've got mail!", /* AOL */
 #endif
 	"As if!", /* Clueless */
+        "Arooo!  Werewolves of Yendor!", /* gang tag */
+        "Dig for Victory here", /* pun, duh */
+        "Don't go this way",
+        "Gaius Julius Primigenius was here.  Why are you late?", /* pompeii */
+        "Go left --->", "<--- Go right",
+        "Haermund Hardaxe carved these runes", /* viking graffiti */
+        "Here be dragons",
+        "Need a light?  Come visit the Minetown branch of Izchak's Lighting Store!",
+        "Save now, and do your homework!",
+        "Snakes on the Astral Plane - Soon in a dungeon near you",
+        "There was a hole here.  It's gone now.",
+        "The Vibrating Square",
+        "This is a pit!",
+        "This is not the dungeon you are looking for.",
+        "This square deliberately left blank.",
+        "Warning, Exploding runes!",
+        "Watch out, there's a gnome with a wand of death behind that door!",
+        "X marks the spot",
+        "X <--- You are here.",
+        "You are the one millionth visitor to this place!  Please wait 200 turns for your wand of wishing.",
 };
 
 char *
@@ -343,7 +363,7 @@ register int x,y;
 			et = ep->engr_txt;
 		You("%s: \"%s\".",
 		      (Blind) ? "feel the words" : "read",  et);
-		if(flags.run > 1) nomul(0);
+		if(flags.run > 1) nomul(0, NULL);
 	    }
 	}
 }
@@ -1229,7 +1249,371 @@ static const char *epitaphs[] = {
 	"I made an ash of myself",
 	"Soon ripe. Soon rotten. Soon gone. But not forgotten.",
 	"Here lies the body of Jonathan Blake. Stepped on the gas instead of the brake.",
-	"Go away!"
+	"Go away!",
+        "Alas fair Death, 'twas missed in life - some peace and quiet from my wife",
+        "Applaud, my friends, the comedy is finished.",
+        "At last... a nice long sleep.",
+        "Audi Partem Alteram",
+        "Basil, assaulted by bears",
+        "Burninated",
+        "Confusion will be my epitaph",
+        "Do not open until Christmas",
+        "Don't be daft, they couldn't hit an elephant at this dist-",
+        "Don't forget to stop and smell the roses",
+        "Don't let this happen to you!",
+        "Dulce et decorum est pro patria mori",
+        "Et in Arcadia ego",
+        "Fatty and skinny went to bed.  Fatty rolled over and skinny was dead.  Skinny Smith 1983-2000.",
+        "Finally I am becoming stupider no more",
+        "Follow me to hell",
+        "...for famous men have the whole earth as their memorial",
+        "Game over, man.  Game over.",
+        "Go away!  I'm trying to take a nap in here!  Bloody adventurers...",
+        "Gone fishin'",
+        "Good night, sweet prince: And flights of angels sing thee to thy rest!",
+        "Go Team Ant!",
+        "He farmed his way here",
+        "Here lies a programmer.  Killed by a fatal error.",
+        "Here lies Bob - decided to try an acid blob",
+        "Here lies Dudley, killed by another %&#@#& newt.",
+        "Here lies Gregg, choked on an egg",
+        "Here lies Lies. It's True",
+        "Here lies The Lady's maid, died of a Vorpal Blade",
+        "Here lies the left foot of Jack, killed by a land mine.  Let us know if you find any more of him",
+        "He waited too long",
+        "I'd rather be sailing",
+        "If a man's deeds do not outlive him, of what value is a mark in stone?",
+        "I'm gonna make it!",
+        "I took both pills!",
+        "I will survive!",
+        "Killed by a black dragon -- This grave is empty",
+        "Let me out of here!",
+        "Lookin' good, Medusa.",
+        "Mrs. Smith, choked on an apple.  She left behind grieving husband, daughter, and granddaughter.",
+        "Nobody believed her when she said her feet were killing her",
+        "No!  I don't want to see my damn conduct!",
+        "One corpse, sans head",
+        "On the whole, I'd rather be in Minetown",
+        "On vacation",
+        "Oops.",
+        "Out to Lunch",
+        "SOLD",
+        "Someone set us up the bomb!",
+        "Take my stuff, I don't need it anymore",
+        "Taking a year dead for tax reasons",
+        "The reports of my demise are completely accurate",
+        "(This space for sale)",
+        "This was actually just a pit, but since there was a corpse, we filled it",
+        "This way to the crypt",
+        "Tu quoque, Brute?",
+        "VACANCY",
+        "Welcome!",
+        "Wish you were here!",
+        "Yea, it got me too",
+        "You should see the other guy",
+        "...and they made me engrave my own headstone too!",
+        "...but the blood has stopped pumping and I am left to decay...",
+        "<Expletive Deleted>",
+        "A masochist is never satisfied.",
+        "Ach, 'twas a wee monster in the loch",
+        "Adapt.  Enjoy.  Survive.",
+        "Adventure, hah!  Excitement, hah!",
+        "After all, what are friends for...",
+        "After this, nothing will shock me",
+        "After three days, fish and guests stink",
+        "Age and treachery will always overcome youth and skill",
+        "Ageing is not so bad.  The real killer is when you stop.",
+        "Ain't I a stinker?",
+        "Algernon",
+        "All else failed...",
+        "All hail RNG",
+        "All right, we'll call it a draw!",
+        "All's well that end well",
+        "Alone at last!",
+        "Always attack a floating eye from behind!",
+        "Am I having fun yet?",
+        "And I can still crawl, I'm not dead yet!",
+        "And all I wanted was a free lunch",
+        "And all of the signs were right there on your face",
+        "And don't give me that innocent look either!",
+        "And everyone died.  Boo hoo hoo.",
+        "And here I go again...",
+        "And nobody cares until somebody famous dies...",
+        "And so it ends?",
+        "And so... it begins.",
+        "And sometimes the bear eats you.",
+        "And then 'e nailed me 'ead to the floor!",
+        "And they said it couldn't be done!",
+        "And what do I look like?  The living?",
+        "And yes, it was ALL his fault!",
+        "And you said it was pretty here...",
+        "Another lost soul",
+        "Any day above ground is a good day!",
+        "Any more of this and I'll die of a stroke before I'm 30.",
+        "Anybody seen my head?",
+        "Anyone for deathmatch?",
+        "Anything for a change.",
+        "Anything that kills you makes you ... well, dead",
+        "Anything worth doing is worth overdoing.",
+        "Are unicorns supposedly peaceful if you're a virgin?  Hah!",
+        "Are we all being disintegrated, or is it just me?",
+        "At least I'm good at something",
+        "Attempted suicide",
+	"Auri sacra fames",
+        "Auribus teneo lupum",
+        "Be prepared",
+        "Beauty survives",
+        "Been Here. Now Gone. Had a Good Time.",
+        "Been through Hell, eh?  What did you bring me?",
+        "Beg your pardon, didn't recognize you, I've changed a lot.",
+        "Being dead builds character",
+        "Beloved daughter, a treasure, buried here.",
+        "Best friends come and go...  Mine just die.",
+        "Better be dead than a fat slave",
+        "Better luck next time",
+        "Beware of Discordians bearing answers",
+        "Beware the ...",
+        "Bloody Hell...",
+        "Bloody barbarians!",
+        "Blown upward out of sight: He sought the leak by candlelight",
+        "Brains... Brains... Fresh human brains...",
+        "Buried the cat.  Took an hour.  Damn thing kept fighting.",
+        "But I disarmed the trap!",
+        "CONNECT 1964 - NO CARRIER 1994",
+        "Call me if you need my phone number!",
+        "Can YOU fly?",
+        "Can you believe that thing is STILL moving?",
+        "Can you come up with some better ending for this?",
+        "Can you feel anything when I do this?",
+        "Can you give me mouth to mouth, you just took my breath away.",
+        "Can't I just have a LITTLE peril?",
+        "Can't eat, can't sleep, had to bury the husband here.",
+        "Can't you hit me?!",
+        "Chaos, panic and disorder.  My work here is done.",
+        "Check enclosed.",
+        "Check this out!  It's my brain!",
+        "Chivalry is only reasonably dead",
+        "Coffin for sale.  Lifetime guarantee.",
+        "Come Monday, I'll be all right.",
+        "Come and see the violence inherent in the system",
+        "Come back here!  I'll bite your bloody knees off!",
+        "Commodore Business Machines, Inc.   Died for our sins.",
+        "Complain to one who can help you",
+        "Confess my sins to god?  Which one?",
+        "Confusion will be my epitaph",
+        "Cooties?  Ain't no cooties on me!",
+        "Could somebody get this noose off me?",
+        "Could you check again?  My name MUST be there.",
+        "Could you please take a breath mint?",
+        "Couldn't I be sedated for this?",
+        "Courage is looking at your setbacks with serenity",
+        "Cover me, I'm going in!",
+        "Crash course in brain surgery",
+        "Cross my fingers for me.",
+        "Curse god and die",
+        "Cut to fit",
+        "De'Ath",
+        "Dead Again?  Pardon me for not getting it right the first time!",
+        "Dead and loving every moment!",
+        "Dear wife of mine. Died of a broken heart, after I took it out of her.",
+        "Don't tread on me!",
+        "Dragon? What dragon?",
+        "Drawn and quartered",
+        "Either I'm dead or my watch has stopped.",
+        "Eliza -- Was I really alive, or did I just think I was?",
+        "Elvis",
+        "Enter not into the path of the wicked",
+        "Eris?  I don't need Eris",
+        "Eternal Damnation, Come and stay a long while!",
+        "Even The Dead pay taxes (and they aren't Grateful).",
+        "Even a tomb stone will say good things when you're down!",
+        "Ever notice that live is evil backwards?",
+        "Every day is starting to look like Monday",
+        "Every day, in every way, I am getting better and better.",
+        "Every survival kit should include a sense of humor",
+        "Evil I did dwell;  lewd did I live",
+        "Ex post fucto",
+        "Excellent day to have a rotten day.",
+        "Excuse me for not standing up.",
+        "Experience isn't everything. First, You've got to survive",
+        "First shalt thou pull out the Holy Pin",
+        "For a Breath, I Tarry...",
+        "For recreational use only.",
+        "For sale: One soul, slightly used. Asking for 3 wishes.",
+        "For some moments in life, there are no words.",
+        "Forget Disney World, I'm going to Hell!",
+        "Forget about the dog, Beware of my wife.",
+        "Funeral - Real fun.",
+        "Gawd, it's depressing in here, isn't it?",
+        "Genuine Exploding Gravestone.  (c)Acme Gravestones Inc.",
+        "Get back here!  I'm not finished yet...",
+        "Go ahead, I dare you to!",
+        "Go ahead, it's either you or him.",
+        "Goldilocks -- This casket is just right",
+        "Gone But Not Forgotten",
+        "Gone Underground For Good",
+        "Gone away owin' more than he could pay.",
+        "Gone, but not forgiven",
+        "Got a life. Didn't know what to do with it.",
+        "Grave?  But I was cremated!",
+        "Greetings from Hell - Wish you were here.",
+        "HELP! It's dark in here... Oh, my eyes are closed - sorry",
+        "Ha! I NEVER pay income tax!",
+        "Have you come to raise the dead?",
+        "Having a good time can be deadly.",
+        "Having a great time. Where am I exactly??",
+        "He died of the flux.",
+        "He died today... May we rest in peace!",
+        "He got the upside, I got the downside.",
+        "He lost his face when he was beheaded.",
+        "He missed me first.",
+        "He's not dead, he just smells that way.",
+        "Help! I've fallen and I can't get up!",
+        "Help, I can't wake up!",
+        "Here lies Pinocchio",
+        "Here lies the body of John Round. Lost at sea and never found.",
+        "Here there be dragons",
+        "Hey, I didn't write this stuff!",
+	"Hodie mihi, cras tibi",
+        "Hold my calls",
+        "Home Sweet Hell",
+        "Humpty Dumpty, a Bad Egg.  He was pushed off the wall.",
+        "I KNEW this would happen if I lived long enough.",
+        "I TOLD you I was sick!",
+        "I ain't broke but I am badly bent.",
+        "I ain't old. I'm chronologically advantaged.",
+        "I am NOT a vampire. I just like to bite..nibble, really!",
+        "I am here. Wish you were fine.",
+        "I am not dead yet, but watch for further reports.",
+        "I believe them bones are me.",
+        "I broke his brain.",
+        "I can feel it.  My mind.  It's going.  I can feel it.",
+        "I can't go to Hell. They're afraid I'm gonna take over!",
+        "I can't go to hell, they don't want me.",
+        "I didn't believe in reincarnation the last time, either.",
+        "I didn't mean it when I said 'Bite me'",
+        "I died laughing",
+        "I disbelieved in reincarnation in my last life, too.",
+        "I hacked myself to death",
+        "I have all the time in the world",
+        "I knew I'd find a use for this gravestone!",
+        "I know my mind. And it's around here someplace.",
+        "I lied!  I'll never be alright!",
+        "I like it better in the dark.",
+        "I like to be here when I can.",
+        "I may rise but I refuse to shine.",
+        "I never get any either.",
+        "I said hit HIM with the fireball, not me!",
+        "I told you I would never say goodbye.",
+        "I used to be amusing. Now I'm just disgusting.",
+        "I used up all my sick days, so now I'm calling in dead.",
+        "I was killed by <illegible scrawl>",
+        "I was somebody. Who, is no business of yours.",
+        "I will not go quietly.",
+        "I'd give you a piece of my mind... but I can't find it.",
+        "I'd rather be breathing",
+        "I'll be back!",
+        "I'll be mellow when I'm dead. For now, let's PARTY!",
+        "I'm doing this only for tax purposes.",
+        "I'm not afraid of Death!  What's he gonna do? Kill me?",
+        "I'm not getting enough money, so I'm not going to engrave anything useful here.",
+        "I'm not saying anything.",
+        "I'm weeth stupeed --->",
+        "If you thought you had problems...",
+        "Ignorance kills daily.",
+        "Ignore me... I'm just here for my looks!",
+        "Ilene Toofar -- Fell off a cliff",
+        "Is that all?",
+        "Is there life before Death?",
+        "Is this a joke, or a grave matter?",
+        "It happens sometimes. People just explode.",
+        "It must be Thursday. I never could get the hang of Thursdays.",
+        "It wasn't a fair fight",
+        "It wasn't so easy.",
+        "It's Loot, Pillage and THEN Burn...",
+        "Just doing my job here",
+        "Killed by diarrhea of mouth and constipation of brain.",
+        "Let her RIP",
+        "Let it be; I am dead.",
+        "Let's play Hide the Corpse",
+        "Life is NOT a dream",
+        "Madge Ination -- It wasn't all in my head",
+        "Meet me in Heaven",
+        "Move on, there's nothing to see here.",
+        "Mr. Flintstone -- Yabba-dabba-done",
+        "My heart is not in this",
+        "No one ever died from it",
+        "No, you want room 12A, next door.",
+        "Nope.  No trap on that chest.  I swear.",
+        "Not again!",
+        "Not every soil can bear all things",
+        "Now I have a life",
+        "Now I lay thee down to sleep... wanna join me?",
+        "OK, here is a question: Where ARE your tanlines?",
+        "Obesa Cantavit",
+        "Oh! An untimely death.",
+        "Oh, by the way, how was my funeral?",
+        "Oh, honey..I missed you! She said, and fired again.",
+        "Ok, so the light does go off. Now let me out of here.",
+        "One stone brain",
+        "Ooh! Somebody STOP me!",
+        "Oops!",
+        "Out for the night.  Leave a message.",
+        "Ow!  Do that again!",
+        "Pardon my dust.",
+        "Part of me still works.",
+        "Please, not in front of those orcs!",
+        "Prepare to meet me in Heaven",
+        "R2D2 -- Rest, Tin Piece",
+        "Relax.  Nothing ever happens on the first level.",
+        "Res omnia mea culpa est",
+        "Rest In Pieces",
+        "Rest, rest, perturbed spirit.",
+        "Rip Torn",
+        "She always said her feet were killing her but nobody believed her.",
+        "She died of a chest cold.",
+        "So let it be written, so let it be done!",
+        "So then I says, How do I know you're the real angel of death?",
+        "Some patients insist on dying.",
+        "Some people have it dead easy, don't they?",
+        "Some things are better left buried.",
+        "Sure, trust me, I'm a lawyer...",
+        "Thank God I wore my corset, because I think my sides have split.",
+        "That is all",
+        "The Gods DO have a sense of humor: I'm living proof!",
+        "The frog's dead. He Kermitted suicide.",
+        "This dungeon is a pushover",
+        "This elevator doesn't go to Heaven",
+        "This gravestone is shareware. To register, please send me 10 zorkmids",
+        "This gravestone provided by The Yendorian Grave Services Inc.",
+        "This is not an important part of my life.",
+        "This one's on me.",
+        "This side up",
+        "Tim Burr -- Smashed by a tree",
+        "Tone it down a bit, I'm trying to get some rest here.",
+        "Virtually Alive",
+        "We Will Meet Again.",
+        "Weep not, he is at rest",
+        "Welcome to Dante's.  What level please?",
+        "Well, at least they listened to my sermon...",
+        "Went to be an angel.",
+        "What are you doing over there?",
+        "What are you smiling at?",
+        "What can you say, Death's got appeal...!",
+        "What health care?",
+        "What pit?",
+        "When the gods want to punish you, they answer your prayers.",
+        "Where e'er you be let your wind go free. Keeping it in was the death of me!",
+        "Where's my refund?",
+        "Will let you know for sure in a day or two...",
+        "Wizards are wimps",
+        "Worms at work, do not disturb!",
+        "Would you mind moving a bit?  I'm short of breath down here.",
+        "Would you quit being evil over my shoulder?",
+        "Ya really had me going baby, but now I'm gone.",
+        "Yes Dear, just a few more minutes...",
+        "You said it wasn't poisonous!",
+        "You set my heart aflame. You gave me heartburn."
 };
 
 /* Create a headstone at the given location.
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/explode.c nethack-3.4.3-nao-osx/src/explode.c
--- nethack-3.4.3/src/explode.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/explode.c	2014-12-20 12:08:36.000000000 -0800
@@ -513,7 +513,7 @@ struct obj *obj;			/* only scatter this 
 				if (scflags & MAY_HITYOU) {
 				    int hitvalu, hitu;
 
-				    if (multi) nomul(0);
+				    if (multi) nomul(0, NULL);
 				    hitvalu = 8 + stmp->obj->spe;
 				    if (bigmonst(youmonst.data)) hitvalu++;
 				    hitu = thitu(hitvalu,
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/files.c nethack-3.4.3-nao-osx/src/files.c
--- nethack-3.4.3/src/files.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/files.c	2014-12-20 12:08:36.000000000 -0800
@@ -9,9 +9,13 @@
 #include "wintty.h" /* more() */
 #endif
 
+#if defined(WHEREIS_FILE) && defined(UNIX)
+#include <sys/types.h> /* whereis-file chmod() */
+#endif
+
 #include <ctype.h>
 
-#if !defined(MAC) && !defined(O_WRONLY) && !defined(AZTEC_C)
+#if (!defined(MAC) && !defined(O_WRONLY) && !defined(AZTEC_C)) || defined(USE_FCNTL)
 #include <fcntl.h>
 #endif
 
@@ -534,6 +538,9 @@ clearlocks()
 	/* can't access maxledgerno() before dungeons are created -dlc */
 	for (x = (n_dgns ? maxledgerno() : 0); x >= 0; x--)
 		delete_levelfile(x);	/* not all levels need be present */
+#  ifdef WHEREIS_FILE
+	delete_whereis();
+#  endif
 #endif
 }
 
@@ -598,6 +605,77 @@ int fd;
 }
 #endif
 	
+#ifdef WHEREIS_FILE
+void
+touch_whereis()
+{
+  /* Write out our current level and branch to name.whereis
+   *
+   *      Could eventually bolt on all kinds of info, but this way
+   *      at least something which wants to can scan for the games.
+   *
+   * For now this only works on Win32 and UNIX.  I'm too lazy
+   * to sort out all the proper other-OS stuff.
+   */
+
+  FILE* fp;
+  char whereis_file[255];
+  char whereis_work[255];
+
+  Sprintf(whereis_file,"%s",dump_format_str(WHEREIS_FILE));
+  Sprintf(whereis_work,
+	  "depth=%d:dnum=%d:hp=%d:maxhp=%d:turns=%d:score=%ld:role=%s:race=%s:gender=%s:align=%s:conduct=0x%lx:amulet=%d\n",
+	  depth(&u.uz),
+	  u.uz.dnum,
+	  u.uhp,
+	  u.uhpmax,
+	  moves,
+	  botl_score(),
+	  urole.filecode,
+	  urace.filecode,
+	  genders[flags.female].filecode,
+	  aligns[1-u.ualign.type].filecode,
+	  encodeconduct(),
+	  u.uhave.amulet ? 1 : 0
+	  );
+  /*
+  Sprintf(whereis_work,"%d,%d,%d,%d,%d,0,0,%s,%s,%s,%d,%d\n",
+	  depth(&u.uz), u.uz.dnum, u.uhp, u.uhpmax, moves,
+	  urole.name.m,urace.adj,u.mfemale ? "F" : "M",u.ualign.type + 2,
+	  u.uhave.amulet ? 1 : 0);*/
+  fp = fopen_datafile(whereis_file,"w",LEVELPREFIX);
+  if (fp) {
+#ifdef UNIX
+    mode_t whereismode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;
+    chmod(fqname(whereis_file, LEVELPREFIX, 2), whereismode);
+#endif
+    fwrite(whereis_work,strlen(whereis_work),1,fp);
+    fclose(fp);
+  }
+
+}
+
+
+/* Changed over to write out where the player last was when they
+ * left the game; including possibly 'dead' :) */
+void
+delete_whereis()
+{
+    /*FILE* fp;*/
+  char whereis_file[255];
+  /*char whereis_work[255];*/
+  Sprintf(whereis_file,"%s",dump_format_str(WHEREIS_FILE));
+  (void) unlink(fqname(whereis_file, LEVELPREFIX, 2));
+  /*
+  fp = fopen_datafile(whereis_file,"w",LEVELPREFIX);
+  if (fp) {
+    fwrite(whereis_work,strlen(whereis_work),1,fp);
+    fclose(fp);
+  }
+  */
+}
+#endif /* WHEREIS_FILE */
+
 /* ----------  END LEVEL FILE HANDLING ----------- */
 
 
@@ -611,20 +689,25 @@ set_bonesfile_name(file, lev)
 char *file;
 d_level *lev;
 {
+	static char bonesid[16];
 	s_level *sptr;
 	char *dptr;
 
-	Sprintf(file, "bon%c%s", dungeons[lev->dnum].boneid,
+	Sprintf(bonesid, "%c%s", dungeons[lev->dnum].boneid,
 			In_quest(lev) ? urole.filecode : "0");
-	dptr = eos(file);
+	dptr = eos(bonesid);
 	if ((sptr = Is_special(lev)) != 0)
 	    Sprintf(dptr, ".%c", sptr->boneid);
 	else
 	    Sprintf(dptr, ".%d", lev->dlevel);
+	Sprintf(file, "bon%s", bonesid);
+#ifdef BONES_POOL
+	Sprintf(eos(file), ".%d", (u.ubirthday % 10));
+#endif
 #ifdef VMS
-	Strcat(dptr, ";1");
+	Strcat(file, ";1");
 #endif
-	return(dptr-2);
+	return(bonesid);
 }
 
 /* set up temporary file name for writing bones, to avoid another game's
@@ -1243,9 +1326,12 @@ const char *filename;
 
 static int nesting = 0;
 
-#ifdef NO_FILE_LINKS	/* implies UNIX */
+#if defined(NO_FILE_LINKS) || defined(USE_FCNTL) 	/* implies UNIX */
 static int lockfd;	/* for lock_file() to pass to unlock_file() */
 #endif
+#ifdef USE_FCNTL
+struct flock sflock; /* for unlocking, same as above */
+#endif
 
 #define HUP	if (!program_state.done_hup)
 
@@ -1283,7 +1369,6 @@ char *lockname;
 #endif
 }
 
-
 /* lock a file */
 boolean
 lock_file(filename, whichprefix, retryct)
@@ -1303,18 +1388,51 @@ int retryct;
 	    return TRUE;
 	}
 
+#ifndef USE_FCNTL
 	lockname = make_lockname(filename, locknambuf);
-	filename = fqname(filename, whichprefix, 0);
-#ifndef NO_FILE_LINKS	/* LOCKDIR should be subsumed by LOCKPREFIX */
+# ifndef NO_FILE_LINKS	/* LOCKDIR should be subsumed by LOCKPREFIX */
 	lockname = fqname(lockname, LOCKPREFIX, 2);
+# endif
+#endif
+	filename = fqname(filename, whichprefix, 0);
+
+#ifdef USE_FCNTL
+	lockfd = open(filename,O_RDWR);
+	if (lockfd == -1) {
+		HUP raw_printf("Cannot open file %s. This is a program bug.",
+			filename);
+	}
+	sflock.l_type = F_WRLCK;
+	sflock.l_whence = SEEK_SET;
+	sflock.l_start = 0;
+	sflock.l_len = 0;
 #endif
 
 #if defined(UNIX) || defined(VMS)
-# ifdef NO_FILE_LINKS
+# ifdef USE_FCNTL
+	while (fcntl(lockfd,F_SETLK,&sflock) == -1) {
+# else 
+#  ifdef NO_FILE_LINKS
 	while ((lockfd = open(lockname, O_RDWR|O_CREAT|O_EXCL, 0666)) == -1) {
-# else
+#  else
 	while (link(filename, lockname) == -1) {
-# endif
+#  endif
+# endif 
+
+#ifdef USE_FCNTL
+		if (retryct--) {
+			HUP raw_printf(
+				"Waiting for release of fcntl lock on %s. (%d retries left).",
+				filename, retryct);
+			sleep(1);
+		} else {
+		    HUP (void) raw_print("I give up.  Sorry.");
+		    HUP raw_printf("Some other process has an unnatural grip on %s.",
+					filename);
+		    nesting--;
+		    return FALSE;
+		}
+#else
 	    register int errnosv = errno;
 
 	    switch (errnosv) {	/* George Barbanis */
@@ -1360,11 +1478,11 @@ int retryct;
 		nesting--;
 		return FALSE;
 	    }
-
+#endif /* USE_FCNTL */
 	}
 #endif  /* UNIX || VMS */
 
-#if defined(AMIGA) || defined(WIN32) || defined(MSDOS)
+#if (defined(AMIGA) || defined(WIN32) || defined(MSDOS)) && !defined(USE_FCNTL)
 # ifdef AMIGA
 #define OPENFAILURE(fd) (!fd)
     lockptr = 0;
@@ -1418,25 +1536,33 @@ const char *filename;
 	const char *lockname;
 
 	if (nesting == 1) {
+#ifdef USE_FCNTL
+		sflock.l_type = F_UNLCK;
+		if (fcntl(lockfd,F_SETLK,&sflock) == -1) {
+			HUP raw_printf("Can't remove fcntl lock on %s.", filename);
+			(void) close(lockfd);
+		}
+# else
 		lockname = make_lockname(filename, locknambuf);
-#ifndef NO_FILE_LINKS	/* LOCKDIR should be subsumed by LOCKPREFIX */
+# ifndef NO_FILE_LINKS	/* LOCKDIR should be subsumed by LOCKPREFIX */
 		lockname = fqname(lockname, LOCKPREFIX, 2);
-#endif
+# endif
 
-#if defined(UNIX) || defined(VMS)
+# if defined(UNIX) || defined(VMS)
 		if (unlink(lockname) < 0)
 			HUP raw_printf("Can't unlink %s.", lockname);
-# ifdef NO_FILE_LINKS
+#  ifdef NO_FILE_LINKS
 		(void) close(lockfd);
-# endif
+#  endif
 
-#endif  /* UNIX || VMS */
+# endif  /* UNIX || VMS */
 
-#if defined(AMIGA) || defined(WIN32) || defined(MSDOS)
+# if defined(AMIGA) || defined(WIN32) || defined(MSDOS)
 		if (lockptr) Close(lockptr);
 		DeleteFile(lockname);
 		lockptr = 0;
-#endif /* AMIGA || WIN32 || MSDOS */
+# endif /* AMIGA || WIN32 || MSDOS */
+#endif /* USE_FCNTL */
 	}
 
 	nesting--;
@@ -1650,6 +1776,82 @@ gi_error:
     /*NOTREACHED*/
 }
 
+/*
+ * Retrieve a list of integers from a file into a longint array.
+ *
+ * Accepts decimals, hexadecimals (0x1234) or unicode codepoints (U+1234)
+ *
+ * NOTE: zeros are inserted unless modlist is TRUE, in which case the list
+ *  location is unchanged.  Callers must handle zeros if modlist is FALSE.
+ */
+STATIC_OVL int
+get_longs(fp, buf, bufp, list, modlist, size, name)
+    FILE *fp;		/* input file pointer */
+    char *buf;		/* read buffer, must be of size BUFSZ */
+    char *bufp;		/* current pointer */
+    long *list;		/* return list */
+    boolean modlist;	/* TRUE: list is being modified in place */
+    int  size;		/* return list size */
+    const char *name;		/* name of option for error message */
+{
+    long num = 0;
+    int count = 0;
+    boolean havenum = FALSE;
+    char tmpnum[16];
+    int tmpnumpos = 0;
+
+    memset(tmpnum, 0, 16);
+
+    while (1) {
+	switch(*bufp) {
+	    case ' ':  case '\0':
+	    case '\t': case '\n':
+		if (havenum) {
+		    num = parse_codepoint(tmpnum);
+		    /* if modifying in place, don't insert zeros */
+		    if (num || !modlist) list[count] = num;
+		    count++;
+		    havenum = FALSE;
+		}
+		if (count == size || !*bufp) return count;
+		bufp++;
+		memset(tmpnum, 0, 16);
+		tmpnumpos = 0;
+		break;
+
+	    case '0': case '1': case '2': case '3':
+	    case '4': case '5': case '6': case '7':
+	    case '8': case '9': /* decimals */
+	    case 'a': case 'A': case 'b': case 'B':
+	    case 'c': case 'C': case 'd': case 'D':
+	    case 'e': case 'E': case 'f': case 'F': /* hexadecimals */
+	    case 'x': case 'X': case 'u': case 'U': case '+': /* see parse_codepoint() */
+		havenum = TRUE;
+		if (tmpnumpos >= 16) goto gi_error;
+		tmpnum[tmpnumpos++] = *bufp;
+		bufp++;
+		break;
+
+	    case '\\':
+		if (fp == (FILE *)0)
+		    goto gi_error;
+		do  {
+		    if (!fgets(buf, BUFSZ, fp)) goto gi_error;
+		} while (buf[0] == '#');
+		bufp = buf;
+		break;
+
+	    default:
+gi_error:
+		raw_printf("Syntax error in %s", name);
+		wait_synch();
+		return count;
+	}
+    }
+    /*NOTREACHED*/
+}
+
+
 #ifdef NOCWD_ASSUMPTIONS
 STATIC_OVL void
 adjust_prefix(bufp, prefixid)
@@ -1720,6 +1922,10 @@ char		*tmp_levels;
 	} else if (match_varname(buf, "AUTOPICKUP_EXCEPTION", 5)) {
 		add_autopickup_exception(bufp);
 #endif
+	} else if (match_varname(buf, "BINDINGS", 4)) {
+		parsebindings(bufp);
+	} else if (match_varname(buf, "AUTOCOMPLETE", 5)) {
+		parseautocomplete(bufp, TRUE);
 #ifdef NOCWD_ASSUMPTIONS
 	} else if (match_varname(buf, "HACKDIR", 4)) {
 		adjust_prefix(bufp, HACKPREFIX);
@@ -1782,6 +1988,20 @@ char		*tmp_levels;
 	} else if (match_varname(buf, "NAME", 4)) {
 	    (void) strncpy(plname, bufp, PL_NSIZ-1);
 	    plnamesuffix();
+	} else if (match_varname(buf, "MSGTYPE", 7)) {
+	    char pattern[256];
+	    char msgtype[11];
+	    if (sscanf(bufp, "%10s \"%255[^\"]\"", msgtype, pattern) == 2) {
+		int typ = MSGTYP_NORMAL;
+		if (!strcasecmp("norep", msgtype)) typ = MSGTYP_NOREP;
+		else if (!strcasecmp("hide", msgtype)) typ = MSGTYP_NOSHOW;
+		else if (!strcasecmp("noshow", msgtype)) typ = MSGTYP_NOSHOW;
+		else if (!strcasecmp("more", msgtype)) typ = MSGTYP_STOP;
+		else if (!strcasecmp("stop", msgtype)) typ = MSGTYP_STOP;
+		if ((typ != MSGTYP_NORMAL) || !strcasecmp("show", msgtype)) {
+		    msgpline_add(typ, pattern);
+		}
+	    }
 	} else if (match_varname(buf, "ROLE", 4) ||
 		   match_varname(buf, "CHARACTER", 4)) {
 	    if ((len = str2role(bufp)) >= 0)
@@ -1794,22 +2014,53 @@ char		*tmp_levels;
 	} else if (match_varname(buf, "BOULDER", 3)) {
 	    (void) get_uchars(fp, buf, bufp, &iflags.bouldersym, TRUE,
 			      1, "BOULDER");
+	} else if (match_varname(buf, "MENUCOLOR", 9)) {
+#ifdef MENU_COLOR
+	    (void) add_menu_coloring(bufp);
+#endif
+	} else if (match_varname(buf, "MONSTERCOLOR", 12)) {
+	    return parse_monster_color(bufp);
+	} else if (match_varname(buf, "MONSTERSYMBOL", 13)) {
+	    return parse_monster_symbol(bufp);
+	} else if (match_varname(buf, "OBJECTSYMBOL", 12)) {
+	    return parse_object_symbol(bufp);
+	} else if (match_varname(buf, "SYMBOL", 6)) {
+	    return parse_symbol(bufp);
+	} else if (match_varname(buf, "DUNGEONSYMBOLS", 14)) {
+	    long utf8symbols[MAXDCHARS];
+	    len = get_longs(fp, buf, bufp, utf8symbols, FALSE, MAXDCHARS, "DUNGEONSYMBOLS");
+	    assign_graphics((glyph_t *)utf8symbols, len, MAXDCHARS, 0);
 	} else if (match_varname(buf, "GRAPHICS", 4)) {
 	    len = get_uchars(fp, buf, bufp, translate, FALSE,
 			     MAXPCHARS, "GRAPHICS");
-	    assign_graphics(translate, len, MAXPCHARS, 0);
+	    assign_graphics((glyph_t *) translate, len, MAXPCHARS, 0);
+        } else if (match_varname(buf, "STATUSCOLOR", 11)) {
+            /* ignore statuscolor entries if not compiled in */
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+            (void) parse_status_color_options(bufp);
+#endif
 	} else if (match_varname(buf, "DUNGEON", 4)) {
 	    len = get_uchars(fp, buf, bufp, translate, FALSE,
 			     MAXDCHARS, "DUNGEON");
-	    assign_graphics(translate, len, MAXDCHARS, 0);
+	    assign_graphics((glyph_t *) translate, len, MAXDCHARS, 0);
 	} else if (match_varname(buf, "TRAPS", 4)) {
 	    len = get_uchars(fp, buf, bufp, translate, FALSE,
 			     MAXTCHARS, "TRAPS");
-	    assign_graphics(translate, len, MAXTCHARS, MAXDCHARS);
+	    assign_graphics((glyph_t *) translate, len, MAXTCHARS, MAXDCHARS);
 	} else if (match_varname(buf, "EFFECTS", 4)) {
 	    len = get_uchars(fp, buf, bufp, translate, FALSE,
 			     MAXECHARS, "EFFECTS");
-	    assign_graphics(translate, len, MAXECHARS, MAXDCHARS+MAXTCHARS);
+	    assign_graphics((glyph_t *)translate, len, MAXECHARS, MAXDCHARS+MAXTCHARS);
+#ifdef USER_DUNGEONCOLOR
+	} else if (match_varname(buf, "DUNGEONCOLOR", 10)) {
+	    len = get_uchars(fp, buf, bufp, translate, FALSE,
+			     MAXDCHARS, "DUNGEONCOLOR");
+	    assign_colors(translate, len, MAXDCHARS, 0);
+	} else if (match_varname(buf, "TRAPCOLORS", 7)) {
+	    len = get_uchars(fp, buf, bufp, translate, FALSE,
+			     MAXTCHARS, "TRAPCOLORS");
+	    assign_colors(translate, len, MAXTCHARS, MAXDCHARS);
+#endif
 
 	} else if (match_varname(buf, "OBJECTS", 3)) {
 	    /* oc_syms[0] is the RANDOM object, unused */
@@ -2250,8 +2501,8 @@ const char *reason;	/* explanation */
 		program_state.in_paniclog = 1;
 		lfile = fopen_datafile(PANICLOG, "a", TROUBLEPREFIX);
 		if (lfile) {
-		    (void) fprintf(lfile, "%s %08ld: %s %s\n",
-				   version_string(buf), yyyymmdd((time_t)0L),
+		    (void) fprintf(lfile, "%ld %s: %s %s\n",
+				   u.ubirthday, (plname ? plname : "(none)"),
 				   type, reason);
 		    (void) fclose(lfile);
 		}
@@ -2421,4 +2672,50 @@ int ifd, ofd;
 /* ----------  END INTERNAL RECOVER ----------- */
 #endif /*SELF_RECOVER*/
 
+#ifdef LIVELOGFILE
+
+/* Locks the live log file and writes 'buffer' */
+void
+livelog_write_string(buffer)
+     char *buffer;
+{
+    FILE* livelogfile;
+    if(lock_file(LIVELOGFILE, SCOREPREFIX, 10)) {
+	if(!(livelogfile = fopen_datafile(LIVELOGFILE, "a", SCOREPREFIX))) {
+	    pline("Cannot open live log file!");
+	} else {
+	    char tmpbuf[1024+1];
+	    char msgbuf[512+1];
+	    char *c1 = msgbuf;
+	    strncpy(msgbuf, buffer, 512);
+	    msgbuf[512] = '\0';
+	    while (*c1 != '\0') {
+	      if (*c1 == ':') *c1 = '_';
+	      c1++;
+	    }
+	    snprintf(tmpbuf, 1024, "player=%s:role=%s:race=%s:gender=%s:align=%s:turns=%ld:starttime=%ld:curtime=%ld:message=%s\n",
+		     plname,
+		     urole.filecode,
+		     urace.filecode,
+		     genders[flags.female].filecode,
+		     aligns[1-u.ualign.type].filecode,
+		     moves, (long)u.ubirthday, (long)time(NULL), msgbuf);
+
+	    fprintf(livelogfile, tmpbuf);
+	    (void) fclose(livelogfile);
+	}
+	unlock_file(LIVELOGFILE);
+    }
+}
+
+#else
+
+void
+livelog_write_string(buffer)
+     char *buffer;
+{
+}
+
+#endif /* !LIVELOGFILE */
+
 /*files.c*/
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/hack.c nethack-3.4.3-nao-osx/src/hack.c
--- nethack-3.4.3/src/hack.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/hack.c	2014-12-20 12:08:36.000000000 -0800
@@ -72,7 +72,7 @@ moverock()
 
 	rx = u.ux + 2 * u.dx;	/* boulder destination position */
 	ry = u.uy + 2 * u.dy;
-	nomul(0);
+	nomul(0, NULL);
 	if (Levitation || Is_airlevel(&u.uz)) {
 	    if (Blind) feel_location(sx, sy);
 	    You("don't have enough leverage to push %s.", the(xname(otmp)));
@@ -323,7 +323,7 @@ still_chewing(x,y)
     if (!boulder && IS_ROCK(lev->typ) && !may_dig(x,y)) {
 	You("hurt your teeth on the %s.",
 	    IS_TREE(lev->typ) ? "tree" : "hard stone");
-	nomul(0);
+	nomul(0, NULL);
 	return 1;
     } else if (digging.pos.x != x || digging.pos.y != y ||
 		!on_level(&digging.level, &u.uz)) {
@@ -561,8 +561,11 @@ int mode;
 	if (Passes_walls && may_passwall(x,y)) {
 	    ;	/* do nothing */
 	} else if (tmpr->typ == IRONBARS) {
-	    if (!(Passes_walls || passes_bars(youmonst.data)))
+	    if (!(Passes_walls || passes_bars(youmonst.data))) {
+		if (iflags.notice_walls)
+		    pline("You cannot pass through the bars.");
 		return FALSE;
+	    }
 	} else if (tunnels(youmonst.data) && !needspick(youmonst.data)) {
 	    /* Eat the rock. */
 	    if (mode == DO_MOVE && still_chewing(x,y)) return FALSE;
@@ -576,8 +579,10 @@ int mode;
 	    if (mode == DO_MOVE) {
 		if (Is_stronghold(&u.uz) && is_db_wall(x,y))
 		    pline_The("drawbridge is up!");
-		if (Passes_walls && !may_passwall(x,y) && In_sokoban(&u.uz))
+		else if (Passes_walls && !may_passwall(x,y) && In_sokoban(&u.uz))
 		    pline_The("Sokoban walls resist your ability.");
+		else if (iflags.notice_walls)
+		    pline("It's a wall.");
 	    }
 	    return FALSE;
 	}
@@ -719,7 +724,7 @@ boolean guess;
 	if (test_move(u.ux, u.uy, u.tx-u.ux, u.ty-u.uy, TEST_MOVE)) {
 	    u.dx = u.tx-u.ux;
 	    u.dy = u.ty-u.uy;
-	    nomul(0);
+	    nomul(0, NULL);
 	    iflags.travelcc.x = iflags.travelcc.y = -1;
 	    return TRUE;
 	}
@@ -785,7 +790,7 @@ boolean guess;
 				u.dx = x-ux;
 				u.dy = y-uy;
 				if (x == u.tx && y == u.ty) {
-				    nomul(0);
+				    nomul(0, NULL);
 				    /* reset run so domove run checks work */
 				    flags.run = 8;
 				    iflags.travelcc.x = iflags.travelcc.y = -1;
@@ -855,7 +860,7 @@ boolean guess;
 found:
     u.dx = 0;
     u.dy = 0;
-    nomul(0);
+    nomul(0, NULL);
     return FALSE;
 }
 
@@ -891,7 +896,7 @@ domove()
 		exercise(A_CON, FALSE);
 	    } else
 		You("collapse under your load.");
-	    nomul(0);
+	    nomul(0, NULL);
 	    return;
 	}
 	if(u.uswallow) {
@@ -943,7 +948,7 @@ domove()
 
 			do {
 				if(tries++ > 50) {
-					nomul(0);
+					nomul(0, NULL);
 					return;
 				}
 				confdir();
@@ -955,14 +960,14 @@ domove()
 		if (u.uinwater) {
 			water_friction();
 			if (!u.dx && !u.dy) {
-				nomul(0);
+				nomul(0, NULL);
 				return;
 			}
 			x = u.ux + u.dx;
 			y = u.uy + u.dy;
 		}
 		if(!isok(x, y)) {
-			nomul(0);
+			nomul(0, NULL);
 			return;
 		}
 		if (((trap = t_at(x, y)) && trap->tseen) ||
@@ -970,11 +975,11 @@ domove()
 		     !is_clinger(youmonst.data) &&
 		     (is_pool(x, y) || is_lava(x, y)) && levl[x][y].seenv)) {
 			if(flags.run >= 2) {
-				nomul(0);
+				nomul(0, NULL);
 				flags.move = 0;
 				return;
 			} else
-				nomul(0);
+				nomul(0, NULL);
 		}
 
 		if (u.ustuck && (x != u.ustuck->mx || y != u.ustuck->my)) {
@@ -1015,7 +1020,7 @@ domove()
 				!Conflict && !u.ustuck->mconf)
 				goto pull_free;
 			    You("cannot escape from %s!", mon_nam(u.ustuck));
-			    nomul(0);
+			    nomul(0, NULL);
 			    return;
 			}
 		    }
@@ -1031,7 +1036,7 @@ domove()
 				mtmp->m_ap_type != M_AP_OBJECT) ||
 			       Protection_from_shape_changers)) ||
 			     sensemon(mtmp))) {
-				nomul(0);
+				nomul(0, NULL);
 				flags.move = 0;
 				return;
 			}
@@ -1046,7 +1051,7 @@ domove()
 
 	/* attack monster */
 	if(mtmp) {
-	    nomul(0);
+	    nomul(0, NULL);
 	    /* only attack if we know it's there */
 	    /* or if we used the 'F' command to fight blindly */
 	    /* or if it hides_under, in which case we call attack() to print
@@ -1108,7 +1113,7 @@ domove()
 		    is_pool(x,y) ? "empty water" : buf);
 		unmap_object(x, y); /* known empty -- remove 'I' if present */
 		newsym(x, y);
-		nomul(0);
+		nomul(0, NULL);
 		if (expl) {
 		    u.mh = -1;		/* dead in the current form */
 		    rehumanize();
@@ -1123,7 +1128,7 @@ domove()
 #ifdef STEED
 	if (u.usteed && !u.usteed->mcanmove && (u.dx || u.dy)) {
 		pline("%s won't move!", upstart(y_monnam(u.usteed)));
-		nomul(0);
+		nomul(0, NULL);
 		return;
 	} else
 #endif
@@ -1131,7 +1136,7 @@ domove()
 		You("are rooted %s.",
 		    Levitation || Is_airlevel(&u.uz) || Is_waterlevel(&u.uz) ?
 		    "in place" : "to the ground");
-		nomul(0);
+		nomul(0, NULL);
 		return;
 	}
 	if(u.utrap) {
@@ -1254,7 +1259,7 @@ domove()
 
 	if (!test_move(u.ux, u.uy, x-u.ux, y-u.uy, DO_MOVE)) {
 	    flags.move = 0;
-	    nomul(0);
+	    nomul(0, NULL);
 	    return;
 	}
 
@@ -1370,7 +1375,7 @@ domove()
 	    if ( flags.run < 8 )
 		if (IS_DOOR(tmpr->typ) || IS_ROCK(tmpr->typ) ||
 			IS_FURNITURE(tmpr->typ))
-		    nomul(0);
+		    nomul(0, NULL);
 	}
 
 	if (hides_under(youmonst.data))
@@ -1408,7 +1413,7 @@ domove()
 	/* delay next move because of ball dragging */
 	/* must come after we finished picking up, in spoteffects() */
 	if (cause_delay) {
-	    nomul(-2);
+	    nomul(-2, "dragging an iron ball");
 	    nomovemsg = "";
 	}
 
@@ -1436,7 +1441,7 @@ invocation_message()
 	    char buf[BUFSZ];
 	    struct obj *otmp = carrying(CANDELABRUM_OF_INVOCATION);
 
-	    nomul(0);		/* stop running or travelling */
+	    nomul(0, NULL);		/* stop running or travelling */
 #ifdef STEED
 	    if (u.usteed) Sprintf(buf, "beneath %s", y_monnam(u.usteed));
 	    else
@@ -1924,7 +1929,7 @@ lookaround()
     /* Grid bugs stop if trying to move diagonal, even if blind.  Maybe */
     /* they polymorphed while in the middle of a long move. */
     if (u.umonnum == PM_GRID_BUG && u.dx && u.dy) {
-	nomul(0);
+	nomul(0, NULL);
 	return;
     }
 
@@ -2001,7 +2006,7 @@ bcorr:
 	       continue;
 	}
 stop:
-	nomul(0);
+	nomul(0, NULL);
 	return;
     } /* end for loops */
 
@@ -2064,14 +2069,19 @@ monster_nearby()
 }
 
 void
-nomul(nval)
+nomul(nval, txt)
 	register int nval;
+	const char *txt;
 {
 	if(multi < nval) return;	/* This is a bug fix by ab@unido */
 	u.uinvulnerable = FALSE;	/* Kludge to avoid ctrl-C bug -dlc */
 	u.usleep = 0;
 	multi = nval;
 	flags.travel = iflags.travel1 = flags.mv = flags.run = 0;
+	if (txt && txt[0])
+	    (void) strncpy(multi_txt, txt, BUFSZ);
+	else
+	    (void) memset(multi_txt, 0, BUFSZ);
 }
 
 /* called when a non-movement, multi-turn action has completed */
@@ -2080,6 +2090,7 @@ unmul(msg_override)
 const char *msg_override;
 {
 	multi = 0;	/* caller will usually have done this already */
+	(void) memset(multi_txt, 0, BUFSZ);
 	if (msg_override) nomovemsg = msg_override;
 	else if (!nomovemsg) nomovemsg = You_can_move_again;
 	if (*nomovemsg) pline(nomovemsg);
@@ -2173,7 +2184,7 @@ weight_cap()
 
 	if (Levitation || Is_airlevel(&u.uz)    /* pugh@cornell */
 #ifdef STEED
-			|| (u.usteed && strongmonst(u.usteed->data))
+			|| (u.usteed && u.usteed->data && strongmonst(u.usteed->data))
 #endif
 	)
 		carrcap = MAX_CARR_CAP;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/hacklib.c nethack-3.4.3-nao-osx/src/hacklib.c
--- nethack-3.4.3/src/hacklib.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/hacklib.c	2014-12-20 12:08:36.000000000 -0800
@@ -144,6 +144,19 @@ strkitten(s, c)		/* append a character t
     return s;
 }
 
+/* replace (in place) characters below space in the string */
+void
+sanitizestr(s)
+char *s;
+{
+    if (!s) return;
+    while (*s) {
+	if (*s <= ' ') *s = ' ';
+	s++;
+    }
+}
+
+
 char *
 s_suffix(s)		/* return a name converted to possessive */
     const char *s;
@@ -460,6 +473,14 @@ static struct tm *NDECL(getlt);
 void
 setrandom()
 {
+  
+  FILE *fptr = NULL;
+  int rnd[2];
+
+  fptr = fopen("/dev/urandom","r");
+  if (fptr) fread((void *)rnd, sizeof(int),1,fptr);
+  fclose(fptr);
+  
 	/* the types are different enough here that sweeping the different
 	 * routine names into one via #defines is even more confusing
 	 */
@@ -473,7 +494,7 @@ setrandom()
 #   endif
 		srandom((int) time((long *)0));
 #  else
-		srandom((int) time((time_t *)0));
+	srandom((int) (time((time_t *)0)) + rnd[0]);
 #  endif
 # else
 #  ifdef UNIX	/* system srand48() */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/invent.c nethack-3.4.3-nao-osx/src/invent.c
--- nethack-3.4.3/src/invent.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/invent.c	2014-12-20 12:08:36.000000000 -0800
@@ -19,7 +19,12 @@ STATIC_DCL boolean FDECL(taking_off, (co
 STATIC_DCL boolean FDECL(putting_on, (const char *));
 STATIC_PTR int FDECL(ckunpaid,(struct obj *));
 STATIC_PTR int FDECL(ckvalidcat,(struct obj *));
+#ifdef DUMP_LOG
+static char FDECL(display_pickinv,
+		 (const char *,BOOLEAN_P, long *, BOOLEAN_P, BOOLEAN_P));
+#else
 static char FDECL(display_pickinv, (const char *,BOOLEAN_P, long *));
+#endif /* DUMP_LOG */
 #ifdef OVLB
 STATIC_DCL boolean FDECL(this_type_only, (struct obj *));
 STATIC_DCL void NDECL(dounpaid);
@@ -28,6 +33,7 @@ STATIC_DCL void FDECL(menu_identify, (in
 STATIC_DCL boolean FDECL(tool_in_use, (struct obj *));
 #endif /* OVLB */
 STATIC_DCL char FDECL(obj_to_let,(struct obj *));
+STATIC_DCL int FDECL(itemactions,(struct obj *));
 
 #ifdef OVLB
 
@@ -253,15 +259,27 @@ struct obj *obj;
 	} else if (obj->otyp == AMULET_OF_YENDOR) {
 		if (u.uhave.amulet) impossible("already have amulet?");
 		u.uhave.amulet = 1;
+#ifdef RECORD_ACHIEVE
+                achieve.get_amulet = 1;
+#endif
 	} else if (obj->otyp == CANDELABRUM_OF_INVOCATION) {
 		if (u.uhave.menorah) impossible("already have candelabrum?");
 		u.uhave.menorah = 1;
+#ifdef RECORD_ACHIEVE
+                achieve.get_candelabrum = 1;
+#endif
 	} else if (obj->otyp == BELL_OF_OPENING) {
 		if (u.uhave.bell) impossible("already have silver bell?");
 		u.uhave.bell = 1;
+#ifdef RECORD_ACHIEVE
+                achieve.get_bell = 1;
+#endif
 	} else if (obj->otyp == SPE_BOOK_OF_THE_DEAD) {
 		if (u.uhave.book) impossible("already have the book?");
 		u.uhave.book = 1;
+#ifdef RECORD_ACHIEVE
+                achieve.get_book = 1;
+#endif
 	} else if (obj->oartifact) {
 		if (is_quest_artifact(obj)) {
 		    if (u.uhave.questart)
@@ -271,6 +289,19 @@ struct obj *obj;
 		}
 		set_artifact_intrinsic(obj, 1, W_ART);
 	}
+
+#ifdef RECORD_ACHIEVE
+        if(obj->otyp == LUCKSTONE && obj->record_achieve_special) {
+                achieve.get_luckstone = 1;
+                obj->record_achieve_special = 0;
+        } else if((obj->otyp == AMULET_OF_REFLECTION ||
+                   obj->otyp == BAG_OF_HOLDING) &&
+                  obj->record_achieve_special) {
+                achieve.finish_sokoban = 1;
+                obj->record_achieve_special = 0;
+        }
+#endif /* RECORD_ACHIEVE */
+
 }
 
 /*
@@ -575,6 +606,20 @@ register struct obj *obj;
 		 */
 		return;
 	}
+
+	if (obj == uwep) uwepgone();
+	else if (obj == uswapwep) uswapwepgone();
+	else if (obj == uquiver) uqwepgone();
+	else if (obj == uarm) setnotworn(obj);
+	else if (obj == uarmc) setnotworn(obj);
+	else if (obj == uarmh) setnotworn(obj);
+	else if (obj == uarms) setnotworn(obj);
+	else if (obj == uarmg) setnotworn(obj);
+#ifdef TOURIST
+	else if (obj == uarmu) setnotworn(obj);
+#endif
+	else if (obj == uarmf) setnotworn(obj);
+
 	update_map = (obj->where == OBJ_FLOOR);
 	obj_extract_self(obj);
 	if (update_map) newsym(obj->ox, obj->oy);
@@ -740,6 +785,21 @@ const char *action;
     return !strcmp(action, "wear") || !strcmp(action, "put on");
 }
 
+static struct obj *nextgetobj = 0;
+
+/** Returns the object to use in the inventory usage menu.
+ * nextgetobj is set to NULL before the pointer of the item is returned. */
+struct obj*
+getnextgetobj()
+{
+	if (nextgetobj) {
+		struct obj* ptr = nextgetobj;
+		nextgetobj = NULL;
+		return ptr;
+	}
+	return NULL;
+}
+
 /*
  * getobj returns:
  *	struct obj *xxx:	object to do something with.
@@ -773,6 +833,8 @@ register const char *let,*word;
 	boolean prezero = FALSE;
 	long dummymask;
 
+	if(nextgetobj) return getnextgetobj();
+
 	if(*let == ALLOW_COUNT) let++, allowcnt = 1;
 #ifndef GOLDOBJ
 	if(*let == COIN_CLASS) let++,
@@ -1007,7 +1069,9 @@ register const char *let,*word;
 #ifndef GOLDOBJ
 			if(!(allowcnt == 2 && cnt < u.ugold))
 				cnt = u.ugold;
-			return(mkgoldobj(cnt));
+			if (cnt)
+			    return(mkgoldobj(cnt));
+			else return((struct obj *)0);
 #endif
 		}
 		if(ilet == '?' || ilet == '*') {
@@ -1017,7 +1081,11 @@ register const char *let,*word;
 		    if (ilet == '?' && !*lets && *altlets)
 			allowed_choices = altlets;
 		    ilet = display_pickinv(allowed_choices, TRUE,
-					   allowcnt ? &ctmp : (long *)0);
+					   allowcnt ? &ctmp : (long *)0
+#ifdef DUMP_LOG
+					   , FALSE, TRUE
+#endif
+					   );
 		    if(!ilet) continue;
 		    if (allowcnt && ctmp >= 0) {
 			cnt = ctmp;
@@ -1498,20 +1566,20 @@ int id_limit;
     while (id_limit) {
 	Sprintf(buf, "What would you like to identify %s?",
 		first ? "first" : "next");
-	n = query_objlist(buf, invent, SIGNAL_NOMENU|USE_INVLET|INVORDER_SORT,
+	n = query_objlist(buf, invent, SIGNAL_NOMENU|USE_INVLET|INVORDER_SORT|SIGNAL_ESCAPE,
 		&pick_list, PICK_ANY, not_fully_identified);
 
 	if (n > 0) {
 	    if (n > id_limit) n = id_limit;
 	    for (i = 0; i < n; i++, id_limit--)
 		(void) identify(pick_list[i].item.a_obj);
+	    first = 0;
 	    free((genericptr_t) pick_list);
 	    mark_synch(); /* Before we loop to pop open another menu */
-	} else {
-	    if (n < 0) pline("That was all.");
+	} else if (n < 0) {
+	    if (n == -1) pline("That was all.");
 	    id_limit = 0; /* Stop now */
 	}
-	first = 0;
     }
 }
 
@@ -1647,10 +1715,348 @@ long quan;		/* if non-0, print this quan
 int
 ddoinv()
 {
-	(void) display_inventory((char *)0, FALSE);
+	char c;
+	struct obj *otmp;
+	c = display_inventory((char *)0, iflags.item_use_menu);
+	if (!c) return 0;
+	for (otmp = invent; otmp; otmp = otmp->nobj)
+		if (otmp->invlet == c) break;
+	if (otmp) return itemactions(otmp);
 	return 0;
 }
 
+/** Puts up a menu asking what to do with an object;
+   sends the object to the appropriate command, if one is selected.
+   Each command that can affect the object is listed, but only one
+   out of a set of synonyms is given.
+   Returns 1 if it consumes time, 0 otherwise. */
+int
+itemactions(obj)
+struct obj *obj;
+{
+	winid win;
+	int n;
+	int NDECL((*feedback_fn)) = 0;
+	anything any;
+	menu_item *selected = 0;
+
+	struct monst *mtmp;
+	char prompt[BUFSIZ];
+
+	win = create_nhwindow(NHW_MENU);
+	start_menu(win);
+	/* (a)pply: tools, eucalyptus, cream pie, oil, hooks/whips
+	   Exceptions: applying stones is on V; breaking wands is on V;
+	   equipment-tools are on W; tin openers are on w. */
+	any.a_void = (genericptr_t)doapply;
+	/* Rather a mess for 'a', as it means so many different things
+	   with so many different objects */
+	if (obj->otyp == CREAM_PIE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Hit yourself with this cream pie", MENU_UNSELECTED);
+	else if (obj->otyp == BULLWHIP)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Lash out with this whip", MENU_UNSELECTED);
+	else if (obj->otyp == GRAPPLING_HOOK)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Grapple something with this hook", MENU_UNSELECTED);
+	else if (obj->otyp == BAG_OF_TRICKS && obj->known)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Reach into this bag", MENU_UNSELECTED);
+	else if (Is_container(obj) || obj->otyp == BAG_OF_TRICKS)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Open this container", MENU_UNSELECTED);
+	else if (obj->otyp == CAN_OF_GREASE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Use the can to grease an item", MENU_UNSELECTED);
+	else if (obj->otyp == LOCK_PICK ||
+#ifdef TOURIST
+			obj->otyp == CREDIT_CARD ||
+#endif
+			obj->otyp == SKELETON_KEY)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Use this tool to pick a lock", MENU_UNSELECTED);
+	else if (obj->otyp == TINNING_KIT)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Use this kit to tin a corpse", MENU_UNSELECTED);
+	else if (obj->otyp == LEASH)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Tie a pet to this leash", MENU_UNSELECTED);
+	else if (obj->otyp == SADDLE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Place this saddle on a pet", MENU_UNSELECTED);
+	else if (obj->otyp == MAGIC_WHISTLE || obj->otyp == TIN_WHISTLE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Blow this whistle", MENU_UNSELECTED);
+	else if (obj->otyp == EUCALYPTUS_LEAF)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Use this leaf as a whistle", MENU_UNSELECTED);
+	else if (obj->otyp == STETHOSCOPE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Listen through the stethoscope", MENU_UNSELECTED);
+	else if (obj->otyp == MIRROR)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Show something its reflection", MENU_UNSELECTED);
+	else if (obj->otyp == BELL || obj->otyp == BELL_OF_OPENING)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Ring the bell", MENU_UNSELECTED);
+	else if (obj->otyp == CANDELABRUM_OF_INVOCATION)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Light or extinguish the candelabrum", MENU_UNSELECTED);
+	else if ((obj->otyp == WAX_CANDLE || obj->otyp == TALLOW_CANDLE) &&
+			carrying(CANDELABRUM_OF_INVOCATION))
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Attach this candle to the candelabrum", MENU_UNSELECTED);
+	else if (obj->otyp == WAX_CANDLE || obj->otyp == TALLOW_CANDLE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Light or extinguish this candle", MENU_UNSELECTED);
+	else if (obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP ||
+			obj->otyp == BRASS_LANTERN)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Light or extinguish this light source", MENU_UNSELECTED);
+	else if (obj->otyp == POT_OIL && objects[obj->otyp].oc_name_known)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Light or extinguish this oil", MENU_UNSELECTED);
+#if 0 /* TODO */
+	else if (obj->oclass == POTION_CLASS) {
+		any.a_void = (genericptr_t) dodip;
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Dip something into this potion", MENU_UNSELECTED);
+	}
+#endif
+#ifdef TOURIST
+	else if (obj->otyp == EXPENSIVE_CAMERA)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Take a photograph", MENU_UNSELECTED);
+#endif
+	else if (obj->otyp == TOWEL)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Clean yourself off with this towel", MENU_UNSELECTED);
+	else if (obj->otyp == CRYSTAL_BALL)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Peer into this crystal ball", MENU_UNSELECTED);
+	else if (obj->otyp == MAGIC_MARKER)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Write on something with this marker", MENU_UNSELECTED);
+	else if (obj->otyp == FIGURINE)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Make this figurine transform", MENU_UNSELECTED);
+	else if (obj->otyp == UNICORN_HORN)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Squeeze the unicorn horn tightly", MENU_UNSELECTED);
+	else if ((obj->otyp >= WOODEN_FLUTE && obj->otyp <= DRUM_OF_EARTHQUAKE) ||
+			(obj->otyp == HORN_OF_PLENTY && !obj->known))
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Play this musical instrument", MENU_UNSELECTED);
+	else if (obj->otyp == HORN_OF_PLENTY)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Blow into the horn of plenty", MENU_UNSELECTED);
+	else if (obj->otyp == LAND_MINE || obj->otyp == BEARTRAP)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Arm this trap", MENU_UNSELECTED);
+	else if (obj->otyp == PICK_AXE || obj->otyp == DWARVISH_MATTOCK)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Dig with this digging tool", MENU_UNSELECTED);
+	else if (obj->oclass == WAND_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'a', 0, ATR_NONE,
+				"Break this wand", MENU_UNSELECTED);
+	/* d: drop item, works on everything */
+	any.a_void = (genericptr_t)dodrop;
+	add_menu(win, NO_GLYPH, &any, 'd', 0, ATR_NONE,
+			"Drop this item", MENU_UNSELECTED);
+	/* e: eat item; eat.c provides is_edible to check */
+	any.a_void = (genericptr_t)doeat;
+	if (obj->otyp == TIN && uwep && uwep->otyp == TIN_OPENER)
+		add_menu(win, NO_GLYPH, &any, 'e', 0, ATR_NONE,
+				"Open and eat this tin with your tin opener", MENU_UNSELECTED);
+	else if (obj->otyp == TIN)
+		add_menu(win, NO_GLYPH, &any, 'e', 0, ATR_NONE,
+				"Open and eat this tin", MENU_UNSELECTED);
+	else if (is_edible(obj))
+		add_menu(win, NO_GLYPH, &any, 'e', 0, ATR_NONE,
+				"Eat this item", MENU_UNSELECTED);
+	/* E: engrave with item */
+	any.a_void = (genericptr_t)doengrave;
+	if (obj->otyp == TOWEL)
+		add_menu(win, NO_GLYPH, &any, 'E', 0, ATR_NONE,
+				"Wipe the floor with this towel", MENU_UNSELECTED);
+	else if (obj->otyp == MAGIC_MARKER)
+		add_menu(win, NO_GLYPH, &any, 'E', 0, ATR_NONE,
+				"Scribble graffiti on the floor", MENU_UNSELECTED);
+	else if (obj->oclass == WEAPON_CLASS || obj->oclass == WAND_CLASS ||
+			obj->oclass == GEM_CLASS || obj->oclass == RING_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'E', 0, ATR_NONE,
+				"Write on the floor with this object", MENU_UNSELECTED);
+	/* I: describe item, works on everything */
+	any.a_void = (genericptr_t)dotypeinv;
+	add_menu(win, NO_GLYPH, &any, 'I', 0, ATR_NONE,
+			"Describe this item", MENU_UNSELECTED);
+	/* p: pay for unpaid items */
+	any.a_void = (genericptr_t)dopay;
+	if ((mtmp = shop_keeper(*in_rooms(u.ux, u.uy, SHOPBASE))) &&
+			inhishop(mtmp) && obj->unpaid)
+		add_menu(win, NO_GLYPH, &any, 'p', 0, ATR_NONE,
+				"Buy this unpaid item", MENU_UNSELECTED);
+	/* q: drink item; strangely, this one seems to have no exceptions */
+	any.a_void = (genericptr_t)dodrink;
+	if (obj->oclass == POTION_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE,
+				"Quaff this potion", MENU_UNSELECTED);
+	/* Q: quiver throwable item
+	   (Why are weapons not designed for throwing included, I wonder?) */
+	any.a_void= (genericptr_t)dowieldquiver;
+	if (obj->oclass == GEM_CLASS || obj->oclass == WEAPON_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'Q', 0, ATR_NONE,
+				"Quiver this item for easy throwing", MENU_UNSELECTED);
+	/* r: read item */
+	any.a_void = (genericptr_t)doread;
+	if (obj->otyp == FORTUNE_COOKIE)
+		add_menu(win, NO_GLYPH, &any, 'r', 0, ATR_NONE,
+				"Read the message inside this cookie", MENU_UNSELECTED);
+	else if (obj->otyp == T_SHIRT)
+		add_menu(win, NO_GLYPH, &any, 'r', 0, ATR_NONE,
+				"Read the slogan on the shirt", MENU_UNSELECTED);
+	else if (obj->oclass == SCROLL_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'r', 0, ATR_NONE,
+				"Cast the spell on this scroll", MENU_UNSELECTED);
+	else if (obj->oclass == SPBOOK_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'r', 0, ATR_NONE,
+				"Study this spellbook", MENU_UNSELECTED);
+	any.a_void = (genericptr_t)dorub;
+	if (obj->otyp == OIL_LAMP || obj->otyp == MAGIC_LAMP)
+		add_menu(win, NO_GLYPH, &any, 'R', 0, ATR_NONE,
+				"Rub this lamp", MENU_UNSELECTED);
+	else if (obj->otyp == BRASS_LANTERN)
+		add_menu(win, NO_GLYPH, &any, 'R', 0, ATR_NONE,
+				"Rub this lantern", MENU_UNSELECTED);
+#if 0 /* TODO */
+	else if (obj->oclass == GEM_CLASS && is_graystone(obj))
+		add_menu(win, NO_GLYPH, &any, 'R', 0, ATR_NONE,
+				"Rub something on this stone", MENU_UNSELECTED);
+#endif
+	/* t: throw item, works on everything */
+	any.a_void = (genericptr_t)dothrow;
+	add_menu(win, NO_GLYPH, &any, 't', 0, ATR_NONE,
+			"Throw this item", MENU_UNSELECTED);
+	/* T: unequip worn item */
+	if ((obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))) {
+	    if ((obj->owornmask & (W_ARMOR)))
+		any.a_void = (genericptr_t)dotakeoff;
+	    if ((obj->owornmask & (W_RING | W_AMUL | W_TOOL)))
+		any.a_void = (genericptr_t)doremring;
+	    add_menu(win, NO_GLYPH, &any, 'T', 0, ATR_NONE,
+		     "Unequip this equipment", MENU_UNSELECTED);
+	}
+	/* V: invoke, rub, or break */
+	any.a_void = (genericptr_t)doinvoke;
+	if ((obj->otyp == FAKE_AMULET_OF_YENDOR && !obj->known) ||
+			obj->oartifact || objects[obj->otyp].oc_unique ||
+			obj->otyp == MIRROR) /* wtf NetHack devteam? */
+		add_menu(win, NO_GLYPH, &any, 'V', 0, ATR_NONE,
+				"Try to invoke a unique power of this object", MENU_UNSELECTED);
+	/* w: hold in hands, works on everything but with different
+	   advice text; not mentioned for things that are already
+	   wielded */
+	any.a_void = (genericptr_t)dowield;
+	if (obj == uwep) {}
+	else if (obj->oclass == WEAPON_CLASS || obj->otyp == PICK_AXE ||
+			obj->otyp == UNICORN_HORN)
+		add_menu(win, NO_GLYPH, &any, 'w', 0, ATR_NONE,
+				"Wield this as your weapon", MENU_UNSELECTED);
+	else if (obj->otyp == TIN_OPENER)
+		add_menu(win, NO_GLYPH, &any, 'w', 0, ATR_NONE,
+				"Hold the tin opener to open tins", MENU_UNSELECTED);
+	else
+		add_menu(win, NO_GLYPH, &any, 'w', 0, ATR_NONE,
+				"Hold this item in your hands", MENU_UNSELECTED);
+	/* W: Equip this item */
+	if (!(obj->owornmask & (W_ARMOR | W_RING | W_AMUL | W_TOOL))) {
+	    any.a_void = (genericptr_t)dowear;
+	    if (obj->oclass == ARMOR_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'W', 0, ATR_NONE,
+				"Wear this armor", MENU_UNSELECTED);
+	    else if (obj->oclass == RING_CLASS || obj->otyp == MEAT_RING) {
+		any.a_void = (genericptr_t)doputon;
+		add_menu(win, NO_GLYPH, &any, 'W', 0, ATR_NONE,
+				"Put this ring on", MENU_UNSELECTED);
+	    } else if (obj->oclass == AMULET_CLASS) {
+		any.a_void = (genericptr_t)doputon;
+		add_menu(win, NO_GLYPH, &any, 'W', 0, ATR_NONE,
+				"Put this amulet on", MENU_UNSELECTED);
+	    } else if (obj->otyp == TOWEL || obj->otyp == BLINDFOLD) {
+		any.a_void = (genericptr_t)doputon;
+		add_menu(win, NO_GLYPH, &any, 'W', 0, ATR_NONE,
+				"Use this to blindfold yourself", MENU_UNSELECTED);
+	    } else if (obj->otyp == LENSES) {
+		any.a_void = (genericptr_t)doputon;
+		add_menu(win, NO_GLYPH, &any, 'W', 0, ATR_NONE,
+				"Put these lenses on", MENU_UNSELECTED);
+	    }
+	}
+	/* x: Swap main and readied weapon */
+	any.a_void = (genericptr_t)doswapweapon;
+	if (obj == uwep && uswapwep)
+		add_menu(win, NO_GLYPH, &any, 'x', 0, ATR_NONE,
+				"Swap this with your alternate weapon", MENU_UNSELECTED);
+	else if (obj == uwep)
+		add_menu(win, NO_GLYPH, &any, 'x', 0, ATR_NONE,
+				"Ready this as an alternate weapon", MENU_UNSELECTED);
+	else if (obj == uswapwep)
+		add_menu(win, NO_GLYPH, &any, 'x', 0, ATR_NONE,
+				"Swap this with your main weapon", MENU_UNSELECTED);
+	/* z: Zap wand */
+	any.a_void = (genericptr_t)dozap;
+	if (obj->oclass == WAND_CLASS)
+		add_menu(win, NO_GLYPH, &any, 'z', 0, ATR_NONE,
+				"Zap this wand to release its magic", MENU_UNSELECTED);
+	/* S: Sacrifice object (should be > but that causes problems) */
+#if 0 /* TODO */
+	any.a_void = (genericptr_t)doterrain;
+	if (IS_ALTAR(levl[u.ux][u.uy].typ) && !u.uswallow) {
+		if (obj->otyp == CORPSE)
+			add_menu(win, NO_GLYPH, &any, 'S', 0, ATR_NONE,
+					"Sacrifice this corpse at this altar", MENU_UNSELECTED);
+		else if (obj->otyp == AMULET_OF_YENDOR ||
+				obj->otyp == FAKE_AMULET_OF_YENDOR)
+			add_menu(win, NO_GLYPH, &any, 'S', 0, ATR_NONE,
+					"Sacrifice this amulet at this altar", MENU_UNSELECTED);
+	}
+#endif
+
+	Sprintf(prompt, "Do what with %s?", the(cxname(obj)));
+	end_menu(win, prompt);
+
+	n = select_menu(win, PICK_ONE, &selected);
+	destroy_nhwindow(win);
+	if (n == 1) feedback_fn = (int NDECL((*)))selected[0].item.a_void;
+	if (n == 1) free((genericptr_t) selected);
+
+	if (!feedback_fn) return 0;
+#if 0
+	/* dodip() is special, because it takes the item to dip first, and
+	   the item to dip /into/ second. */
+	if (feedback_fn == dodip) {
+		setnextdodipinto(obj);
+		return dodip();
+	}
+#endif
+	/* dotypeinv() means that we want the item described. Just do it
+	   directly rather than fighting with a multiselect menu. */
+	if (feedback_fn == dotypeinv) {
+		checkfile(xname(obj), 0, TRUE, TRUE);
+		return 0;
+	}
+	/* In most cases, we can just set getobj's result directly.
+	   (This works even for commands that take no arguments, because
+	   they don't call getobj at all. */
+	nextgetobj = obj;
+	n = (*feedback_fn)();
+	nextgetobj = 0;
+
+	return n;
+}
+
+
 /*
  * find_unpaid()
  *
@@ -1684,18 +2090,87 @@ find_unpaid(list, last_found)
     return (struct obj *) 0;
 }
 
+#ifdef SORTLOOT
+int
+sortloot_cmp(obj1, obj2)
+     struct obj *obj1;
+     struct obj *obj2;
+{
+  int val1 = 0;
+  int val2 = 0;
+
+  /* Sort object names in lexicographical order. */
+  int name_cmp = strcmpi(cxname2(obj1), cxname2(obj2));
+
+  if (name_cmp != 0) {
+    return name_cmp;
+  }
+  /* Sort by BUC. Map blessed to 4, uncursed to 2, cursed to 1, and unknown to 0. */
+  val1 = obj1->bknown ? (obj1->blessed << 2) + ((!obj1->blessed && !obj1->cursed) << 1) + obj1->cursed : 0;
+  val2 = obj2->bknown ? (obj2->blessed << 2) + ((!obj2->blessed && !obj2->cursed) << 1) + obj2->cursed : 0;
+  if (val1 != val2) {
+    return val2 - val1; /* Because bigger is better. */
+  }
+
+  /* Sort by greasing. This will put the objects in degreasing order. */
+  val1 = obj1->greased;
+  val2 = obj2->greased;
+  if (val1 != val2) {
+    return val2 - val1; /* Because bigger is better. */
+  }
+
+  /* Sort by erosion. The effective amount is what matters. */
+  val1 = greatest_erosion(obj1);
+  val2 = greatest_erosion(obj2);
+  if (val1 != val2) {
+    return val1 - val2; /* Because bigger is WORSE. */
+  }
+
+  /* Sort by erodeproofing. Map known-invulnerable to 1, and both
+   * known-vulnerable and unknown-vulnerability to 0, because that's how they're displayed. */
+  val1 = obj1->rknown && obj1->oerodeproof;
+  val2 = obj2->rknown && obj2->oerodeproof;
+  if (val1 != val2) {
+    return val2 - val1; /* Because bigger is better. */
+  }
+  /* Sort by enchantment. Map unknown to -1000, which is comfortably below the range of ->spe. */
+  val1 = obj1->known ? obj1->spe : -1000;
+  val2 = obj2->known ? obj2->spe : -1000;
+  if (val1 != val2) {
+    return val2 - val1; /* Because bigger is better. */
+  }
+
+  return 0; /* They're identical, as far as we're concerned. */
+}
+#endif
+
+
 /*
  * Internal function used by display_inventory and getobj that can display
  * inventory and return a count as well as a letter. If out_cnt is not null,
  * any count returned from the menu selection is placed here.
  */
+#ifdef DUMP_LOG
+static char
+display_pickinv(lets, want_reply, out_cnt, want_dump, want_disp)
+register const char *lets;
+boolean want_reply;
+long* out_cnt;
+boolean want_dump;
+boolean want_disp;
+#else
 static char
 display_pickinv(lets, want_reply, out_cnt)
 register const char *lets;
 boolean want_reply;
 long* out_cnt;
+#endif
 {
 	struct obj *otmp;
+#ifdef SORTLOOT
+	struct obj **oarray;
+	int i, j;
+#endif
 	char ilet, ret;
 	char *invlet = flags.inv_order;
 	int n, classcount;
@@ -1704,6 +2179,9 @@ long* out_cnt;
 	anything any;
 	menu_item *selected;
 
+#ifdef DUMP_LOG
+	if (want_disp) {
+#endif
 	/* overriden by global flag */
 	if (flags.perm_invent) {
 	    win = (lets && *lets) ? local_win : WIN_INVEN;
@@ -1713,6 +2191,11 @@ long* out_cnt;
 	} else
 	    win = WIN_INVEN;
 
+#ifdef DUMP_LOG
+	}
+	if (want_dump)   dump("", "Your inventory");
+#endif
+
 	/*
 	Exit early if no inventory -- but keep going if we are doing
 	a permanent inventory update.  We need to keep going so the
@@ -1725,11 +2208,24 @@ long* out_cnt;
 	to here is short circuited away.
 	*/
 	if (!invent && !(flags.perm_invent && !lets && !want_reply)) {
+#ifdef DUMP_LOG
+	  if (want_disp) {
+#endif
 #ifndef GOLDOBJ
 	    pline("Not carrying anything%s.", u.ugold ? " except gold" : "");
 #else
 	    pline("Not carrying anything.");
 #endif
+#ifdef DUMP_LOG
+	  }
+	  if (want_dump) {
+#ifdef GOLDOBJ
+	    dump("  ", "Not carrying anything");
+#else
+	    dump("  Not carrying anything", u.ugold ? " except gold." : ".");
+#endif
+	  }
+#endif
 	    return 0;
 	}
 
@@ -1743,37 +2239,124 @@ long* out_cnt;
 	    ret = '\0';
 	    for (otmp = invent; otmp; otmp = otmp->nobj) {
 		if (otmp->invlet == lets[0]) {
+#ifdef DUMP_LOG
+		  if (want_disp) {
+#endif
 		    ret = message_menu(lets[0],
 			  want_reply ? PICK_ONE : PICK_NONE,
 			  xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
 		    if (out_cnt) *out_cnt = -1L;	/* select all */
+#ifdef DUMP_LOG
+		  }
+		  if (want_dump) {
+		    char letbuf[7];
+		    sprintf(letbuf, "  %c - ", lets[0]);
+		    dump(letbuf,
+			 xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
+		  }
+#endif
 		    break;
 		}
 	    }
 	    return ret;
 	}
 
+#ifdef SORTLOOT
+	/* count the number of items */
+	for (n = 0, otmp = invent; otmp; otmp = otmp->nobj)
+	  if(!lets || !*lets || index(lets, otmp->invlet)) n++;
+
+	/* Make a temporary array to store the objects sorted */
+	oarray = (struct obj **)alloc(n*sizeof(struct obj*));
+
+	/* Add objects to the array */
+	i = 0;
+	for(otmp = invent; otmp; otmp = otmp->nobj)
+	  if(!lets || !*lets || index(lets, otmp->invlet)) {
+	    if (iflags.sortloot == 'f') {
+	      /* Insert object at correct index */
+	      for (j = i; j; j--) {
+		if (sortloot_cmp(otmp, oarray[j-1]) > 0) break;
+		oarray[j] = oarray[j-1];
+	      }
+	      oarray[j] = otmp;
+	      i++;
+	    } else {
+	      /* Just add it to the array */
+	      oarray[i++] = otmp;
+	    }
+	  }
+#endif /* SORTLOOT */
+
+#ifdef DUMP_LOG
+	if (want_disp)
+#endif
 	start_menu(win);
 nextclass:
 	classcount = 0;
 	any.a_void = 0;		/* set all bits to zero */
+#ifdef SORTLOOT
+	for(i = 0; i < n; i++) {
+	  otmp = oarray[i];
+	  ilet = otmp->invlet;
+	  if (!flags.sortpack || otmp->oclass == *invlet) {
+	    if (flags.sortpack && !classcount) {
+	      any.a_void = 0;             /* zero */
+#ifdef DUMP_LOG
+	      if (want_dump)
+		  dump("  ", let_to_name(*invlet, FALSE, FALSE));
+	      if (want_disp)
+#endif
+	      add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
+		       let_to_name(*invlet, FALSE, FALSE), MENU_UNSELECTED);
+	      classcount++;
+	    }
+	    any.a_char = ilet;
+#ifdef DUMP_LOG
+	    if (want_dump) {
+	      char letbuf[7];
+	      sprintf(letbuf, "  %c - ", ilet);
+	      dump(letbuf, doname(otmp));
+	    }
+	    if (want_disp)
+#endif
+	    add_menu(win, obj_to_glyph(otmp),
+		     &any, ilet, 0, ATR_NONE, doname(otmp),
+		     MENU_UNSELECTED);
+	  }
+	}
+#else /* SORTLOOT */
 	for(otmp = invent; otmp; otmp = otmp->nobj) {
 		ilet = otmp->invlet;
 		if(!lets || !*lets || index(lets, ilet)) {
 			if (!flags.sortpack || otmp->oclass == *invlet) {
 			    if (flags.sortpack && !classcount) {
 				any.a_void = 0;		/* zero */
+#ifdef DUMP_LOG
+				if (want_dump)
+				    dump("  ", let_to_name(*invlet, FALSE, FALSE));
+				if (want_disp)
+#endif
 				add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-				    let_to_name(*invlet, FALSE), MENU_UNSELECTED);
+					 let_to_name(*invlet, FALSE, FALSE), MENU_UNSELECTED);
 				classcount++;
 			    }
 			    any.a_char = ilet;
+#ifdef DUMP_LOG
+			    if (want_dump) {
+			      char letbuf[7];
+			      sprintf(letbuf, "  %c - ", ilet);
+			      dump(letbuf, doname(otmp));
+			    }
+			    if (want_disp)
+#endif
 			    add_menu(win, obj_to_glyph(otmp),
 					&any, ilet, 0, ATR_NONE, doname(otmp),
 					MENU_UNSELECTED);
 			}
 		}
 	}
+#endif /* SORTLOOT */
 	if (flags.sortpack) {
 		if (*++invlet) goto nextclass;
 #ifdef WIZARD
@@ -1783,6 +2366,12 @@ nextclass:
 		}
 #endif
 	}
+#ifdef SORTLOOT
+	free(oarray);
+#endif
+#ifdef DUMP_LOG
+	if (want_disp) {
+#endif
 	end_menu(win, (char *) 0);
 
 	n = select_menu(win, want_reply ? PICK_ONE : PICK_NONE, &selected);
@@ -1792,6 +2381,10 @@ nextclass:
 	    free((genericptr_t)selected);
 	} else
 	    ret = !n ? '\0' : '\033';	/* cancelled */
+#ifdef DUMP_LOG
+	} /* want_disp */
+	if (want_dump)  dump("", "");
+#endif
 
 	return ret;
 }
@@ -1808,8 +2401,23 @@ display_inventory(lets, want_reply)
 register const char *lets;
 boolean want_reply;
 {
-	return display_pickinv(lets, want_reply, (long *)0);
+	return display_pickinv(lets, want_reply, (long *)0
+#ifdef DUMP_LOG
+			       , FALSE , TRUE
+#endif
+	);
+}
+
+#ifdef DUMP_LOG
+/* See display_inventory. This is the same thing WITH dumpfile creation */
+char
+dump_inventory(lets, want_reply, want_disp)
+register const char *lets;
+boolean want_reply, want_disp;
+{
+  return display_pickinv(lets, want_reply, (long *)0, TRUE, want_disp);
 }
+#endif
 
 /*
  * Returns the number of unpaid items within the given list.  This includes
@@ -1909,7 +2517,7 @@ dounpaid()
 	    if (otmp->unpaid) {
 		if (!flags.sortpack || otmp->oclass == *invlet) {
 		    if (flags.sortpack && !classcount) {
-			putstr(win, 0, let_to_name(*invlet, TRUE));
+			putstr(win, 0, let_to_name(*invlet, TRUE, FALSE));
 			classcount++;
 		    }
 
@@ -1929,7 +2537,7 @@ dounpaid()
     if (count > num_so_far) {
 	/* something unpaid is contained */
 	if (flags.sortpack)
-	    putstr(win, 0, let_to_name(CONTAINED_SYM, TRUE));
+	    putstr(win, 0, let_to_name(CONTAINED_SYM, TRUE, FALSE));
 	/*
 	 * Search through the container objects in the inventory for
 	 * unpaid items.  The top level inventory items have already
@@ -2235,7 +2843,7 @@ boolean picked_some;
 #ifdef INVISIBLE_OBJECTS
 	    if (otmp->oinvis && !See_invisible) verb = "feel";
 #endif
-	    You("%s here %s.", verb, doname(otmp));
+	    You("%s here %s.", verb, doname_with_price(otmp));
 	    if (otmp->otyp == CORPSE) feel_cockatrice(otmp, FALSE);
 	} else {
 	    display_nhwindow(WIN_MESSAGE, FALSE);
@@ -2255,7 +2863,7 @@ boolean picked_some;
 			putstr(tmpwin, 0, buf);
 			break;
 		}
-		putstr(tmpwin, 0, doname(otmp));
+		putstr(tmpwin, 0, doname_with_price(otmp));
 	    }
 	    display_nhwindow(tmpwin, TRUE);
 	    destroy_nhwindow(tmpwin);
@@ -2589,10 +3197,12 @@ static NEARDATA char *invbuf = (char *)0
 static NEARDATA unsigned invbufsiz = 0;
 
 char *
-let_to_name(let,unpaid)
+let_to_name(let,unpaid,showsym)
 char let;
 boolean unpaid;
+boolean showsym;
 {
+	static const char *ocsymformat = "%s('%c')";
 	const char *class_name;
 	const char *pos;
 	int oclass = (let >= 1 && let < MAXOCLASSES) ? let : 0;
@@ -2605,7 +3215,7 @@ boolean unpaid;
 	else
 	    class_name = names[0];
 
-	len = strlen(class_name) + (unpaid ? sizeof "unpaid_" : sizeof "");
+	len = strlen(class_name) + (unpaid ? sizeof "unpaid_" : sizeof "") + 10;
 	if (len > invbufsiz) {
 	    if (invbuf) free((genericptr_t)invbuf);
 	    invbufsiz = len + 10; /* add slop to reduce incremental realloc */
@@ -2615,6 +3225,9 @@ boolean unpaid;
 	    Strcat(strcpy(invbuf, "Unpaid "), class_name);
 	else
 	    Strcpy(invbuf, class_name);
+	if (oclass && showsym)
+	    Sprintf(eos(invbuf), ocsymformat,
+		    iflags.menu_tab_sep ? "\t" : "  ", def_oc_syms[let]);
 	return invbuf;
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mail.c nethack-3.4.3-nao-osx/src/mail.c
--- nethack-3.4.3/src/mail.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mail.c	2014-12-20 12:08:36.000000000 -0800
@@ -5,6 +5,8 @@
 #include "hack.h"
 
 #ifdef MAIL
+#include <fcntl.h>
+#include <errno.h>
 #include "mail.h"
 
 /*
@@ -36,6 +38,8 @@ STATIC_DCL boolean FDECL(md_stop,(coord 
 STATIC_DCL boolean FDECL(md_rush,(struct monst *,int,int));
 STATIC_DCL void FDECL(newmail, (struct mail_info *));
 
+int mailckfreq = 0;
+
 extern char *viz_rmin, *viz_rmax;	/* line-of-sight limits (vision.c) */
 
 #ifdef OVL0
@@ -464,11 +468,15 @@ struct obj *otmp;
 void
 ckmailstatus()
 {
+#ifdef SIMPLE_MAIL
+	if (mailckfreq == 0)
+	  mailckfreq = (iflags.simplemail ? 5 : 10);
+#else
+	mailckfreq = 10;
+#endif
+
 	if(!mailbox || u.uswallow || !flags.biff
-#  ifdef MAILCKFREQ
-		    || moves < laststattime + MAILCKFREQ
-#  endif
-							)
+		    || moves < laststattime + mailckfreq)
 		return;
 
 	laststattime = moves;
@@ -501,9 +509,68 @@ void
 readmail(otmp)
 struct obj *otmp;
 {
-#  ifdef DEF_MAILREADER			/* This implies that UNIX is defined */
+#ifdef DEF_MAILREADER
 	register const char *mr = 0;
+#endif /* DEF_MAILREADER */
+#ifdef SIMPLE_MAIL
+	if (iflags.simplemail)
+	{
+		FILE* mb = fopen(mailbox, "r");
+		char curline[102], *msg;
+		boolean seen_one_already = FALSE;
+		struct flock fl = { 0 };
+
+		fl.l_type = F_RDLCK;
+		fl.l_whence = SEEK_SET;
+		fl.l_start = 0;
+		fl.l_len = 0;
+
+		if (!mb)
+			goto bail;
+
+		/* Allow this call to block. */
+		if (fcntl (fileno (mb), F_SETLKW, &fl) == -1)
+		  goto bail;
+		
+		errno = 0;
+		
+		while (fgets(curline, 102, mb) != NULL)
+		{
+		  fl.l_type = F_UNLCK;
+		  fcntl (fileno(mb), F_UNLCK, &fl);
+		  
+		  pline("There is a%s message on this scroll.",
+		      seen_one_already ? "nother" : "");
+		  
+		  msg = strchr(curline, ':');
+		  
+		  if (!msg)
+		    goto bail;
+		  
+		  *msg = '\0';
+		  msg++;
+		  
+		  pline ("This message is from '%s'.", curline);
 
+		  msg[strlen(msg) - 1] = '\0'; /* kill newline */
+		  pline ("It reads: \"%s\".", msg);
+
+		  seen_one_already = TRUE;
+		  errno = 0;
+
+		  fl.l_type = F_RDLCK;
+		  fcntl(fileno(mb), F_SETLKW, &fl);
+		}
+
+		fl.l_type = F_UNLCK;
+		fcntl(fileno(mb), F_UNLCK, &fl);
+		
+		fclose(mb);
+		unlink(mailbox);
+		return;
+	}
+# endif /* SIMPLE_MAIL */
+# ifdef DEF_MAILREADER			/* This implies that UNIX is defined */
 	display_nhwindow(WIN_MESSAGE, FALSE);
 	if(!(mr = nh_getenv("MAILREADER")))
 		mr = DEF_MAILREADER;
@@ -512,15 +579,21 @@ struct obj *otmp;
 		(void) execl(mr, mr, (char *)0);
 		terminate(EXIT_FAILURE);
 	}
-#  else
-#   ifndef AMS				/* AMS mailboxes are directories */
+# else
+#  ifndef AMS				/* AMS mailboxes are directories */
 	display_file(mailbox, TRUE);
-#   endif /* AMS */
-#  endif /* DEF_MAILREADER */
+#  endif /* AMS */
+# endif /* DEF_MAILREADER */
 
 	/* get new stat; not entirely correct: there is a small time
 	   window where we do not see new mail */
 	getmailstatus();
+	return;
+
+#ifdef SIMPLE_MAIL
+bail:
+	pline("It appears to be all gibberish."); /* bail out _professionally_ */
+#endif
 }
 
 # endif /* UNIX */
@@ -587,10 +660,7 @@ ckmailstatus()
 	static int laststattime = 0;
 	
 	if(u.uswallow || !flags.biff
-#  ifdef MAILCKFREQ
-		    || moves < laststattime + MAILCKFREQ
-#  endif
-							)
+		    || moves < laststattime + mailckfreq)
 		return;
 
 	laststattime = moves;
@@ -622,4 +692,49 @@ struct obj *otmp;
 
 #endif /* MAIL */
 
+void
+ck_server_admin_msg()
+{
+#if defined(SERVER_ADMIN_MSG) && defined(UNIX)
+  static struct stat ost,nst;
+  static long lastchk = 0;
+
+  if (moves < lastchk + 10) return;
+  lastchk = moves;
+
+  if (!stat(SERVER_ADMIN_MSG, &nst)) {
+
+    if (nst.st_mtime > ost.st_mtime) {
+      char curline[250];
+      boolean shown_name = FALSE;
+      FILE* mb = fopen(SERVER_ADMIN_MSG, "r");
+      boolean snd = flags.soundok;
+
+      if (!mb) return;
+
+      while (fgets(curline, 250, mb) != NULL) {
+	char *msg = strchr(curline, ':');
+	if (!msg) {
+	  fclose(mb);
+	  flags.soundok = snd;
+	  return;
+	}
+	*msg = '\0';
+	msg++;
+	msg[strlen(msg) - 1] = '\0'; /* kill newline */
+	flags.soundok = TRUE;
+	if (!shown_name) {
+	  pline("The voice of %s booms through the caverns:", curline);
+	  shown_name = TRUE;
+	}
+	verbalize(msg);
+      }
+      ost.st_mtime = nst.st_mtime;
+      fclose(mb);
+      flags.soundok = snd;
+    }
+  }
+#endif /* SERVER_ADMIN_MSG && UNIX */
+}
+
 /*mail.c*/
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/makemon.c nethack-3.4.3-nao-osx/src/makemon.c
--- nethack-3.4.3/src/makemon.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/makemon.c	2014-12-20 12:08:36.000000000 -0800
@@ -131,9 +131,11 @@ register int x, y, n;
 		 */
 		if (enexto(&mm, mm.x, mm.y, mtmp->data)) {
 		    mon = makemon(mtmp->data, mm.x, mm.y, NO_MM_FLAGS);
-		    mon->mpeaceful = FALSE;
-		    mon->mavenge = 0;
-		    set_malign(mon);
+		    if (mon) {
+			mon->mpeaceful = FALSE;
+			mon->mavenge = 0;
+			set_malign(mon);
+		    }
 		    /* Undo the second peace_minded() check in makemon(); if the
 		     * monster turned out to be peaceful the first time we
 		     * didn't create it at all; we don't want a second check.
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mapglyph.c nethack-3.4.3-nao-osx/src/mapglyph.c
--- nethack-3.4.3/src/mapglyph.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mapglyph.c	2014-12-20 12:08:36.000000000 -0800
@@ -25,7 +25,11 @@ int explcolors[] = {
 
 #ifdef TEXTCOLOR
 #define zap_color(n)  color = iflags.use_color ? zapcolors[n] : NO_COLOR
+#ifndef USER_DUNGEONCOLOR
 #define cmap_color(n) color = iflags.use_color ? defsyms[n].color : NO_COLOR
+#else
+#define cmap_color(n) color = iflags.use_color ? showsymcolors[n] : NO_COLOR
+#endif
 #define obj_color(n)  color = iflags.use_color ? objects[n].oc_color : NO_COLOR
 #define mon_color(n)  color = iflags.use_color ? mons[n].mcolor : NO_COLOR
 #define invis_color(n) color = NO_COLOR
@@ -57,18 +61,48 @@ int explcolors[] = {
 # endif
 #endif
 
+/** Returns the correct monster glyph.
+ *  Returns a Unicode codepoint in UTF8graphics and an ASCII character otherwise. */
+static glyph_t
+get_monsym(glyph)
+int glyph;
+{
+	if (iflags.UTF8graphics &&
+	    permonst_unicode_codepoint[glyph]) {
+		/* only return a Unicode codepoint when there is one configured */
+		return permonst_unicode_codepoint[glyph];
+	} else {
+		return monsyms[(int)mons[glyph].mlet];
+	}
+}
+
+/** Returns the correct object glyph.
+ *  Returns a Unicode codepoint in UTF8graphics and an ASCII character otherwise. */
+static glyph_t
+get_objsym(glyph)
+int glyph;
+{
+	if (iflags.UTF8graphics &&
+	    objclass_unicode_codepoint[glyph]) {
+		/* only return a Unicode codepoint when there is one configured */
+		return objclass_unicode_codepoint[glyph];
+	} else {
+		return oc_syms[(int)objects[glyph].oc_class];
+	}
+}
+
 /*ARGSUSED*/
 void
 mapglyph(glyph, ochar, ocolor, ospecial, x, y)
 int glyph, *ocolor, x, y;
-int *ochar;
+glyph_t *ochar;
 unsigned *ospecial;
 {
 	register int offset;
 #if defined(TEXTCOLOR) || defined(ROGUE_COLOR)
 	int color = NO_COLOR;
 #endif
-	uchar ch;
+	glyph_t ch;
 	unsigned special = 0;
 
     /*
@@ -87,7 +121,7 @@ unsigned *ospecial;
 	    warn_color(offset);
     } else if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {	/* swallow */
 	/* see swallow_to_glyph() in display.c */
-	ch = (uchar) showsyms[S_sw_tl + (offset & 0x7)];
+	ch = showsyms[S_sw_tl + (offset & 0x7)];
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS && iflags.use_color)
 	    color = NO_COLOR;
@@ -126,14 +160,26 @@ unsigned *ospecial;
 	    /* provide a visible difference if normal and lit corridor
 	     * use the same symbol */
 	    if (iflags.use_color &&
+#ifndef USER_DUNGEONCOLOR
 		offset == S_litcorr && ch == showsyms[S_corr])
 		color = CLR_WHITE;
+#else
+		offset == S_litcorr && ch == showsyms[S_corr] &&
+		    showsymcolors[S_corr] == showsymcolors[S_litcorr]) {
+	if (showsymcolors[S_corr] != CLR_WHITE) {
+	    color = showsymcolors[S_litcorr] = CLR_WHITE;
+	} else {
+	    color = showsymcolors[S_litcorr] = CLR_GRAY;
+	}
+    }
+#endif /* USER_DUNGEONCOLOR */
 	    else
 #endif
 	    cmap_color(offset);
     } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
+	if (On_stairs(x,y) && levl[x][y].seenv) special |= MG_STAIRS;
 	if (offset == BOULDER && iflags.bouldersym) ch = iflags.bouldersym;
-	else ch = oc_syms[(int)objects[offset].oc_class];
+	else ch = get_objsym(offset);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS && iflags.use_color) {
 	    switch(objects[offset].oc_class) {
@@ -144,8 +190,13 @@ unsigned *ospecial;
 	} else
 #endif
 	    obj_color(offset);
+	if (offset != BOULDER &&
+	    level.objects[x][y] &&
+	    level.objects[x][y]->nexthere) {
+	    special |= MG_OBJPILE;
+	}
     } else if ((offset = (glyph - GLYPH_RIDDEN_OFF)) >= 0) {	/* mon ridden */
-	ch = monsyms[(int)mons[offset].mlet];
+	ch = get_monsym(offset);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS)
 	    /* This currently implies that the hero is here -- monsters */
@@ -157,7 +208,8 @@ unsigned *ospecial;
 	    mon_color(offset);
 	    special |= MG_RIDDEN;
     } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
-	ch = oc_syms[(int)objects[CORPSE].oc_class];
+	if (On_stairs(x,y) && levl[x][y].seenv) special |= MG_STAIRS;
+	ch = get_objsym(CORPSE);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS && iflags.use_color)
 	    color = CLR_RED;
@@ -165,8 +217,13 @@ unsigned *ospecial;
 #endif
 	    mon_color(offset);
 	    special |= MG_CORPSE;
+	if (offset != BOULDER &&
+	    level.objects[x][y] &&
+	    level.objects[x][y]->nexthere) {
+	    special |= MG_OBJPILE;
+	}
     } else if ((offset = (glyph - GLYPH_DETECT_OFF)) >= 0) {	/* mon detect */
-	ch = monsyms[(int)mons[offset].mlet];
+	ch = get_monsym(offset);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS)
 	    color = NO_COLOR;	/* no need to check iflags.use_color */
@@ -186,7 +243,7 @@ unsigned *ospecial;
 	    invis_color(offset);
 	    special |= MG_INVIS;
     } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
-	ch = monsyms[(int)mons[offset].mlet];
+	ch = get_monsym(offset);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS)
 	    color = NO_COLOR;	/* no need to check iflags.use_color */
@@ -195,7 +252,7 @@ unsigned *ospecial;
 	    pet_color(offset);
 	    special |= MG_PET;
     } else {							/* a monster */
-	ch = monsyms[(int)mons[glyph].mlet];
+	ch = get_monsym(glyph);
 #ifdef ROGUE_COLOR
 	if (HAS_ROGUE_IBM_GRAPHICS && iflags.use_color) {
 	    if (x == u.ux && y == u.uy)
@@ -230,7 +287,7 @@ unsigned *ospecial;
 	color = NO_COLOR;
 #endif
 
-    *ochar = (int)ch;
+    *ochar = ch;
     *ospecial = special;
 #ifdef TEXTCOLOR
     *ocolor = color;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mcastu.c nethack-3.4.3-nao-osx/src/mcastu.c
--- nethack-3.4.3/src/mcastu.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mcastu.c	2014-12-20 12:08:36.000000000 -0800
@@ -228,7 +228,7 @@ castmu(mtmp, mattk, thinks_it_foundyou, 
 	    return(0);
 	}
 
-	nomul(0);
+	nomul(0, NULL);
 	if(rn2(ml*10) < (mtmp->mconf ? 100 : 20)) {	/* fumbled attack */
 	    if (canseemon(mtmp) && flags.soundok)
 		pline_The("air crackles around %s.", mon_nam(mtmp));
@@ -600,13 +600,13 @@ int spellnum;
 	    shieldeff(u.ux, u.uy);
 	    if (multi >= 0)
 		You("stiffen briefly.");
-	    nomul(-1);
+	    nomul(-1, "paralyzed by a monster");
 	} else {
 	    if (multi >= 0)
 		You("are frozen in place!");
 	    dmg = 4 + (int)mtmp->m_lev;
 	    if (Half_spell_damage) dmg = (dmg + 1) / 2;
-	    nomul(-dmg);
+	    nomul(-dmg, "paralyzed by a monster");
 	}
 	dmg = 0;
 	break;
@@ -771,7 +771,7 @@ buzzmu(mtmp, mattk)		/* monster uses spe
 	    return(0);
 	}
 	if(lined_up(mtmp) && rn2(3)) {
-	    nomul(0);
+	    nomul(0, NULL);
 	    if(mattk->adtyp && (mattk->adtyp < 11)) { /* no cf unsigned >0 */
 		if(canseemon(mtmp))
 		    pline("%s zaps you with a %s!", Monnam(mtmp),
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mhitu.c nethack-3.4.3-nao-osx/src/mhitu.c
--- nethack-3.4.3/src/mhitu.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mhitu.c	2014-12-20 12:08:36.000000000 -0800
@@ -317,7 +317,7 @@ mattacku(mtmp)
 		 * invisible, or you might be blind....
 		 */
 	
-	if(!ranged) nomul(0);
+	if(!ranged) nomul(0, NULL);
 	if(mtmp->mhp <= 0 || (Underwater && !is_swimmer(mtmp->data)))
 	    return(0);
 
@@ -943,6 +943,10 @@ hitmu(mtmp, mattk)
 				goto do_stone;
 			}
 			dmg += dmgval(otmp, &youmonst);
+			if (objects[otmp->otyp].oc_material == SILVER &&
+			    hates_silver(youmonst.data)) {
+			  pline("The silver sears your flesh!");
+			}
 			if (dmg <= 0) dmg = 1;
 			if (!(otmp->oartifact &&
 				artifact_hit(mtmp, &youmonst, otmp, &dmg,dieroll)))
@@ -1122,7 +1126,7 @@ dopois:
 			if (Blind) You("are frozen!");
 			else You("are frozen by %s!", mon_nam(mtmp));
 			nomovemsg = 0;	/* default: "you can move again" */
-			nomul(-rnd(10));
+			nomul(-rnd(10), "paralyzed by a monster");
 			exercise(A_DEX, FALSE);
 		    }
 		}
@@ -2618,13 +2622,15 @@ cloneu()
 	if (u.mh <= 1) return(struct monst *)0;
 	if (mvitals[mndx].mvflags & G_EXTINCT) return(struct monst *)0;
 	mon = makemon(youmonst.data, u.ux, u.uy, NO_MINVENT|MM_EDOG);
-	mon = christen_monst(mon, plname);
-	initedog(mon);
-	mon->m_lev = youmonst.data->mlevel;
-	mon->mhpmax = u.mhmax;
-	mon->mhp = u.mh / 2;
-	u.mh -= mon->mhp;
-	flags.botl = 1;
+	if (mon) {
+	    mon = christen_monst(mon, plname);
+	    initedog(mon);
+	    mon->m_lev = youmonst.data->mlevel;
+	    mon->mhpmax = u.mhmax;
+	    mon->mhp = u.mh / 2;
+	    u.mh -= mon->mhp;
+	    flags.botl = 1;
+	}
 	return(mon);
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mklev.c nethack-3.4.3-nao-osx/src/mklev.c
--- nethack-3.4.3/src/mklev.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mklev.c	2014-12-20 12:08:36.000000000 -0800
@@ -1462,6 +1462,12 @@ mkinvokearea()
     mkstairs(u.ux, u.uy, 0, (struct mkroom *)0); /* down */
     newsym(u.ux, u.uy);
     vision_full_recalc = 1;	/* everything changed */
+
+    livelog_write_string("performed the invocation");
+
+#ifdef RECORD_ACHIEVE
+    achieve.perform_invocation = 1;
+#endif
 }
 
 /* Change level topology.  Boulders in the vicinity are eliminated.
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mon.c nethack-3.4.3-nao-osx/src/mon.c
--- nethack-3.4.3/src/mon.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mon.c	2014-12-20 12:08:36.000000000 -0800
@@ -1481,6 +1481,12 @@ register struct monst *mtmp;
 #endif
 	if(mtmp->iswiz) wizdead();
 	if(mtmp->data->msound == MS_NEMESIS) nemdead();
+        
+#ifdef RECORD_ACHIEVE
+        if(mtmp->data == &mons[PM_MEDUSA])
+            achieve.killed_medusa = 1;
+#endif
+
 	if(glyph_is_invisible(levl[mtmp->mx][mtmp->my].glyph))
 	    unmap_object(mtmp->mx, mtmp->my);
 	m_detach(mtmp, mptr);
@@ -1601,6 +1607,7 @@ register struct monst *mdef;
 	struct obj *otmp, *obj, *oldminvent;
 	xchar x = mdef->mx, y = mdef->my;
 	boolean wasinside = FALSE;
+	int oldgold;
 
 	/* we have to make the statue before calling mondead, to be able to
 	 * put inventory in it, and we have to check for lifesaving before
@@ -1639,6 +1646,10 @@ register struct monst *mdef;
 		/* defer statue creation until after inventory removal
 		   so that saved monster traits won't retain any stale
 		   item-conferred attributes */
+#ifndef GOLDOBJ
+		oldgold = mdef->mgold;
+		mdef->mgold = 0;
+#endif
 		otmp = mkcorpstat(STATUE, KEEPTRAITS(mdef) ? mdef : 0,
 				  mdef->data, x, y, FALSE);
 		if (mdef->mnamelth) otmp = oname(otmp, NAME(mdef));
@@ -1647,13 +1658,12 @@ register struct monst *mdef;
 		    (void) add_to_container(otmp, obj);
 		}
 #ifndef GOLDOBJ
-		if (mdef->mgold) {
+		if (oldgold) {
 			struct obj *au;
 			au = mksobj(GOLD_PIECE, FALSE, FALSE);
-			au->quan = mdef->mgold;
+			au->quan = oldgold;
 			au->owt = weight(au);
 			(void) add_to_container(otmp, au);
-			mdef->mgold = 0;
 		}
 #endif
 		/* Archeologists should not break unique statues */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mondata.c nethack-3.4.3-nao-osx/src/mondata.c
--- nethack-3.4.3/src/mondata.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mondata.c	2014-12-20 12:08:36.000000000 -0800
@@ -476,6 +476,10 @@ const char *in_str;
 		{ "erinyes",		PM_ERINYS },
 	    /* falsely caught by -ves check above */
 		{ "master of thief",	PM_MASTER_OF_THIEVES },
+	    /* human-form weres */
+		{ "wererat (human)",	PM_HUMAN_WERERAT },
+		{ "werejackal (human)",	PM_HUMAN_WEREJACKAL },
+		{ "werewolf (human)",	PM_HUMAN_WEREWOLF },
 	    /* end of list */
 		{ 0, 0 }
 	};
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/mthrowu.c nethack-3.4.3-nao-osx/src/mthrowu.c
--- nethack-3.4.3/src/mthrowu.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/mthrowu.c	2014-12-20 12:08:36.000000000 -0800
@@ -324,7 +324,7 @@ m_throw(mon, x, y, dx, dy, range, obj)
 		    if (ohitmon(mtmp, singleobj, range, TRUE))
 			break;
 		} else if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
-		    if (multi) nomul(0);
+		    if (multi) nomul(0, NULL);
 
 		    if (singleobj->oclass == GEM_CLASS &&
 			    singleobj->otyp <= LAST_GEM+9 /* 9 glass colors */
@@ -608,7 +608,7 @@ struct monst *mtmp;
 	m_shot.o = STRANGE_OBJECT;
 	m_shot.s = FALSE;
 
-	nomul(0);
+	nomul(0, NULL);
 }
 
 #endif /* OVL1 */
@@ -646,7 +646,7 @@ register struct attack *mattk;
 			pline("%s spits venom!", Monnam(mtmp));
 		    m_throw(mtmp, mtmp->mx, mtmp->my, sgn(tbx), sgn(tby),
 			distmin(mtmp->mx,mtmp->my,mtmp->mux,mtmp->muy), otmp);
-		    nomul(0);
+		    nomul(0, NULL);
 		    return 0;
 		}
 	}
@@ -684,7 +684,7 @@ breamu(mtmp, mattk)			/* monster breathe
 			      breathwep[typ-1]);
 		    buzz((int) (-20 - (typ-1)), (int)mattk->damn,
 			 mtmp->mx, mtmp->my, sgn(tbx), sgn(tby));
-		    nomul(0);
+		    nomul(0, NULL);
 		    /* breath runs out sometimes. Also, give monster some
 		     * cunning; don't breath if the player fell asleep.
 		     */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/muse.c nethack-3.4.3-nao-osx/src/muse.c
--- nethack-3.4.3/src/muse.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/muse.c	2014-12-20 12:08:36.000000000 -0800
@@ -1121,7 +1121,7 @@ register struct obj *otmp;
 			    losehp(tmp, "wand", KILLED_BY_AN);
 			} else pline_The("wand misses you.");
 			stop_occupation();
-			nomul(0);
+			nomul(0, NULL);
 		} else if (resists_magm(mtmp)) {
 			shieldeff(mtmp->mx, mtmp->my);
 			pline("Boing!");
@@ -2127,7 +2127,10 @@ struct obj *obj;
 boolean by_you;
 boolean stoning;
 {
-    int nutrit = (obj->otyp == CORPSE) ? dog_nutrition(mon, obj) : 0;
+    /* Save otyp and corpsenm for use after m_useup */
+    short obj_otyp = obj->otyp;
+    int obj_corpsenm = obj->corpsenm;
+    int nutrit = (obj_otyp == CORPSE) ? dog_nutrition(mon, obj) : 0;
     /* also sets meating */
 
     /* give a "<mon> is slowing down" message and also remove
@@ -2145,7 +2148,7 @@ boolean stoning;
     } else if (flags.soundok)
 	You_hear("%s.", (obj->otyp == POT_ACID) ? "drinking" : "chewing");
     m_useup(mon, obj);
-    if (((obj->otyp == POT_ACID) || acidic(&mons[obj->corpsenm])) &&
+    if (((obj_otyp == POT_ACID) || acidic(&mons[obj_corpsenm])) &&
 		    !resists_acid(mon)) {
 	mon->mhp -= rnd(15);
 	pline("%s has a very bad case of stomach acid.",
@@ -2164,7 +2167,7 @@ boolean stoning;
 	else
 	    pline("%s seems limber!", Monnam(mon));
     }
-    if (obj->otyp == CORPSE && obj->corpsenm == PM_LIZARD && mon->mconf) {
+    if (obj_otyp == CORPSE && obj_corpsenm == PM_LIZARD && mon->mconf) {
 	mon->mconf = 0;
 	if (canseemon(mon))
 	    pline("%s seems steadier now.", Monnam(mon));
Binary files nethack-3.4.3/src/nethack.343-nao and nethack-3.4.3-nao-osx/src/nethack.343-nao differ
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/o_init.c nethack-3.4.3-nao-osx/src/o_init.c
--- nethack-3.4.3/src/o_init.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/o_init.c	2014-12-20 12:08:36.000000000 -0800
@@ -406,7 +406,7 @@ dodiscovered()				/* free after Robert V
 	    if ((dis = disco[i]) && interesting_to_discover(dis)) {
 		ct++;
 		if (oclass != prev_class) {
-		    putstr(tmpwin, iflags.menu_headings, let_to_name(oclass, FALSE));
+		    putstr(tmpwin, iflags.menu_headings, let_to_name(oclass, FALSE, FALSE));
 		    prev_class = oclass;
 		}
 		Sprintf(buf, "%s %s",(objects[dis].oc_pre_discovered ? "*" : " "),
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/objects.c nethack-3.4.3-nao-osx/src/objects.c
--- nethack-3.4.3/src/objects.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/objects.c	2014-12-20 12:08:36.000000000 -0800
@@ -630,6 +630,8 @@ TOOL("magic marker", (char *)0, 1, 0, 1,
 TOOL("land mine",(char *)0,     1, 0, 0, 0,   0,300, 180, IRON, CLR_RED),
 TOOL("beartrap", (char *)0,     1, 0, 0, 0,   0,200,  60, IRON, HI_METAL),
 /* instruments */
+/* some code in invent.c requires wooden flute .. drum of earthquake to be
+   consecutive, with the wooden flute first and drum of earthquake last */
 TOOL("tin whistle", "whistle",  0, 0, 0, 0, 100,  3,  10, METAL, HI_METAL),
 TOOL("magic whistle", "whistle",0, 0, 1, 0,  30,  3,  10, METAL, HI_METAL),
 /* "If tin whistles are made out of tin, what do they make foghorns out of?" */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/objnam.c nethack-3.4.3-nao-osx/src/objnam.c
--- nethack-3.4.3/src/objnam.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/objnam.c	2014-12-20 12:08:36.000000000 -0800
@@ -15,6 +15,9 @@ static boolean FDECL(wishymatch, (const 
 #endif
 static char *NDECL(nextobuf);
 static void FDECL(add_erosion_words, (struct obj *, char *));
+#ifdef SORTLOOT
+char * FDECL(xname2, (struct obj *, boolean));
+#endif
 
 struct Jitem {
 	int item;
@@ -233,6 +236,15 @@ boolean juice;	/* whether or not to appe
 char *
 xname(obj)
 register struct obj *obj;
+#ifdef SORTLOOT
+{
+	return xname2(obj, FALSE);
+}
+char *
+xname2(obj, ignore_oquan)
+register struct obj *obj;
+boolean ignore_oquan;
+#endif
 {
 	register char *buf;
 	register int typ = obj->otyp;
@@ -469,6 +481,9 @@ register struct obj *obj;
 	default:
 		Sprintf(buf,"glorkum %d %d %d", obj->oclass, typ, obj->spe);
 	}
+#ifdef SORTLOOT
+	if (!ignore_oquan)
+#endif
 	if (obj->quan != 1L) Strcpy(buf, makeplural(buf));
 
 	if (obj->onamelth && obj->dknown) {
@@ -554,8 +569,9 @@ char *prefix;
 }
 
 char *
-doname(obj)
+doname_base(obj, with_price)
 register struct obj *obj;
+boolean with_price;
 {
 	boolean ispoisoned = FALSE;
 	char prefix[PREFIX];
@@ -600,7 +616,7 @@ register struct obj *obj;
 		Strcat(prefix, "cursed ");
 	    else if (obj->blessed)
 		Strcat(prefix, "blessed ");
-	    else if ((!obj->known || !objects[obj->otyp].oc_charged ||
+	    else if (iflags.show_buc || (!obj->known || !objects[obj->otyp].oc_charged ||
 		      (obj->oclass == ARMOR_CLASS ||
 		       obj->oclass == RING_CLASS))
 		/* For most items with charges or +/-, if you know how many
@@ -775,6 +791,11 @@ ring:
 			quotedprice += contained_cost(obj, shkp, 0L, FALSE, TRUE);
 		Sprintf(eos(bp), " (unpaid, %ld %s)",
 			quotedprice, currency(quotedprice));
+        } else if (with_price) {
+	    long price = get_cost_of_shop_item(obj);
+	    if (price > 0) {
+		Sprintf(eos(bp), " (%ld %s)", price, currency(price));
+	    }
 	}
 	if (!strncmp(prefix, "a ", 2) &&
 			index(vowels, *(prefix+2) ? *(prefix+2) : *bp)
@@ -789,6 +810,23 @@ ring:
 	return(bp);
 }
 
+/** Wrapper function for vanilla behaviour. */
+char *
+doname(obj)
+     register struct obj *obj;
+{
+    return doname_base(obj, FALSE);
+}
+
+/** Name of object including price. */
+char *
+doname_with_price(obj)
+     register struct obj *obj;
+{
+    return doname_base(obj, iflags.show_shop_prices);
+}
+
+
 #endif /* OVL0 */
 #ifdef OVLB
 
@@ -853,6 +891,16 @@ struct obj *obj;
 	    return corpse_xname(obj, FALSE);
 	return xname(obj);
 }
+#ifdef SORTLOOT
+char *
+cxname2(obj)
+struct obj *obj;
+{
+	if (obj->otyp == CORPSE)
+	    return corpse_xname(obj, TRUE);
+	return xname2(obj, TRUE);
+}
+#endif /* SORTLOOT */
 
 /* treat an object as fully ID'd when it might be used as reason for death */
 char *
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/options.c nethack-3.4.3-nao-osx/src/options.c
--- nethack-3.4.3/src/options.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/options.c	2014-12-20 12:08:36.000000000 -0800
@@ -14,6 +14,11 @@ NEARDATA struct instance_flags iflags;	/
 #include "tcap.h"
 #include <ctype.h>
 #endif
+#include <errno.h>
+
+#ifdef HAVE_SETLOCALE
+#include <locale.h>
+#endif
 
 #define WINTYPELEN 16
 
@@ -23,6 +28,10 @@ NEARDATA struct instance_flags iflags;	/
 #define PREFER_TILED FALSE
 #endif
 
+#ifdef CURSES_GRAPHICS
+extern int curses_read_attrs(char *attrs);
+#endif
+
 /*
  *  NOTE:  If you add (or delete) an option, please update the short
  *  options help (option_help()), the long options help (dat/opthelp),
@@ -52,12 +61,15 @@ static struct Bool_Opt
 #endif
 	{"autodig", &flags.autodig, FALSE, SET_IN_GAME},
 	{"autopickup", &flags.pickup, TRUE, SET_IN_GAME},
+	{"apexception_regex", &iflags.ape_regex, FALSE,  SET_IN_FILE},
 	{"autoquiver", &flags.autoquiver, FALSE, SET_IN_GAME},
 #if defined(MICRO) && !defined(AMIGA)
 	{"BIOS", &iflags.BIOS, FALSE, SET_IN_FILE},
 #else
 	{"BIOS", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+	{"botl_updates", &iflags.botl_updates, TRUE, SET_IN_GAME},
+	{"bones", &iflags.bones, TRUE, SET_IN_GAME},
 #ifdef INSURANCE
 	{"checkpoint", &flags.ins_chkpt, TRUE, SET_IN_GAME},
 #else
@@ -69,19 +81,24 @@ static struct Bool_Opt
 	{"checkspace", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"cmdassist", &iflags.cmdassist, TRUE, SET_IN_GAME},
-# if defined(MICRO) || defined(WIN32)
+# if defined(MICRO) || defined(WIN32) || defined(CURSES_GRAPHICS)
 	{"color",         &iflags.wc_color,TRUE, SET_IN_GAME},		/*WC*/
 # else	/* systems that support multiple terminals, many monochrome */
 	{"color",         &iflags.wc_color, FALSE, SET_IN_GAME},	/*WC*/
 # endif
 	{"confirm",&flags.confirm, TRUE, SET_IN_GAME},
+#ifdef CURSES_GRAPHICS
+	{"cursesgraphics", &iflags.cursesgraphics, TRUE, SET_IN_GAME},
+#else
+	{"cursesgraphics", (boolean *)0, FALSE, SET_IN_FILE},
+#endif
 #if defined(TERMLIB) && !defined(MAC_GRAPHICS_ENV)
 	{"DECgraphics", &iflags.DECgraphics, FALSE, SET_IN_GAME},
 #else
 	{"DECgraphics", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"eight_bit_tty", &iflags.wc_eight_bit_input, FALSE, SET_IN_GAME},	/*WC*/
-#ifdef TTY_GRAPHICS
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
 	{"extmenu", &iflags.extmenu, FALSE, SET_IN_GAME},
 #else
 	{"extmenu", (boolean *)0, FALSE, SET_IN_FILE},
@@ -99,8 +116,14 @@ static struct Bool_Opt
 	{"flush", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"fullscreen", &iflags.wc2_fullscreen, FALSE, SET_IN_FILE},
+	{"guicolor", &iflags.wc2_guicolor, TRUE, SET_IN_GAME},
 	{"help", &flags.help, TRUE, SET_IN_GAME},
 	{"hilite_pet",    &iflags.wc_hilite_pet, FALSE, SET_IN_GAME},	/*WC*/
+	{"hilite_hidden_stairs",    &iflags.hilite_hidden_stairs, FALSE, SET_IN_GAME},	/*WC*/
+	{"hilite_obj_piles",    &iflags.hilite_obj_piles, FALSE, SET_IN_GAME},	/*WC*/
+	{"hitpointbar", &iflags.hitpointbar, FALSE, SET_IN_GAME},
+	{"hp_monitor", (boolean *)0, TRUE, SET_IN_FILE}, /* For backward compat, HP monitor patch */
+	{"hp_notify", &iflags.hp_notify, FALSE, SET_IN_GAME},
 #ifdef ASCIIGRAPH
 	{"IBMgraphics", &iflags.IBMgraphics, FALSE, SET_IN_GAME},
 #else
@@ -111,6 +134,7 @@ static struct Bool_Opt
 #else
 	{"ignintr", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+	{"item_use_menu", &iflags.item_use_menu, TRUE, SET_IN_GAME},
 	{"large_font", &iflags.obsolete, FALSE, SET_IN_FILE},	/* OBSOLETE */
 	{"legacy", &flags.legacy, TRUE, DISP_IN_GAME},
 	{"lit_corridor", &flags.lit_corridor, FALSE, SET_IN_GAME},
@@ -125,29 +149,53 @@ static struct Bool_Opt
 #else
 	{"mail", (boolean *)0, TRUE, SET_IN_FILE},
 #endif
+#ifdef MENU_COLOR
+# ifdef MICRO
+	{"menucolors", &iflags.use_menu_color, TRUE,  SET_IN_GAME},
+# else
+	{"menucolors", &iflags.use_menu_color, FALSE, SET_IN_GAME},
+# endif
+#else
+	{"menucolors", (boolean *)0, FALSE, SET_IN_GAME},
+#endif
+	{"menu_glyphs", &iflags.use_menu_glyphs, FALSE, SET_IN_GAME},
 #ifdef WIZARD
 	/* for menu debugging only*/
 	{"menu_tab_sep", &iflags.menu_tab_sep, FALSE, SET_IN_GAME},
 #else
 	{"menu_tab_sep", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef CURSES_GRAPHICS
+	{"mouse_support", &iflags.wc_mouse_support, FALSE, DISP_IN_GAME},	/*WC*/
+#else
 	{"mouse_support", &iflags.wc_mouse_support, TRUE, DISP_IN_GAME},	/*WC*/
+#endif
+	{"msgtype_regex", &iflags.msgtype_regex, FALSE,  SET_IN_FILE},
 #ifdef NEWS
 	{"news", &iflags.news, TRUE, DISP_IN_GAME},
 #else
 	{"news", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+	{"msg_wall_hits", &iflags.notice_walls, FALSE, SET_IN_GAME},
 	{"null", &flags.null, TRUE, SET_IN_GAME},
+	{"old_C_behaviour", &iflags.old_C_behaviour, FALSE, SET_IN_GAME},
 #ifdef MAC
 	{"page_wait", &flags.page_wait, TRUE, SET_IN_GAME},
 #else
 	{"page_wait", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef PARANOID
+	{"paranoid_hit", &iflags.paranoid_hit, FALSE, SET_IN_GAME},
+	{"paranoid_quit", &iflags.paranoid_quit, FALSE, SET_IN_GAME},
+	{"paranoid_remove", &iflags.paranoid_remove, FALSE, SET_IN_GAME},
+#endif
 	{"perm_invent", &flags.perm_invent, FALSE, SET_IN_GAME},
+       {"pickup_thrown", &iflags.pickup_thrown, FALSE, SET_IN_GAME},
 	{"popup_dialog",  &iflags.wc_popup_dialog, FALSE, SET_IN_GAME},	/*WC*/
 	{"prayconfirm", &flags.prayconfirm, TRUE, SET_IN_GAME},
 	{"preload_tiles", &iflags.wc_preload_tiles, TRUE, DISP_IN_GAME},	/*WC*/
 	{"pushweapon", &flags.pushweapon, FALSE, SET_IN_GAME},
+	{"quiver_fired", &iflags.quiver_fired, TRUE, SET_IN_GAME},
 #if defined(MICRO) && !defined(AMIGA)
 	{"rawio", &iflags.rawio, FALSE, DISP_IN_GAME},
 #else
@@ -160,23 +208,37 @@ static struct Bool_Opt
 #else
 	{"sanity_check", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef SHOW_BORN
+	{"showborn", &iflags.show_born, FALSE, SET_IN_GAME},
+#endif
+	{"showbuc", &iflags.show_buc, FALSE, SET_IN_GAME},
 #ifdef EXP_ON_BOTL
 	{"showexp", &flags.showexp, FALSE, SET_IN_GAME},
 #else
 	{"showexp", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+	{"show_obj_sym", &iflags.show_obj_sym, TRUE, SET_IN_GAME},
 	{"showrace", &iflags.showrace, FALSE, SET_IN_GAME},
+#ifdef REALTIME_ON_BOTL
+        {"showrealtime", &iflags.showrealtime, FALSE, SET_IN_GAME},
+#endif
 #ifdef SCORE_ON_BOTL
 	{"showscore", &flags.showscore, FALSE, SET_IN_GAME},
 #else
 	{"showscore", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+	{"show_shop_prices", &iflags.show_shop_prices, TRUE, SET_IN_GAME},
 	{"silent", &flags.silent, TRUE, SET_IN_GAME},
 	{"softkeyboard", &iflags.wc2_softkeyboard, FALSE, SET_IN_FILE},
 	{"sortpack", &flags.sortpack, TRUE, SET_IN_GAME},
 	{"sound", &flags.soundok, TRUE, SET_IN_GAME},
 	{"sparkle", &flags.sparkle, TRUE, SET_IN_GAME},
 	{"standout", &flags.standout, FALSE, SET_IN_GAME},
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+        {"statuscolors", &iflags.use_status_colors, TRUE, SET_IN_GAME},
+#else
+        {"statuscolors", (boolean *)0, TRUE, SET_IN_GAME},
+#endif
 	{"splash_screen",     &iflags.wc_splash_screen, TRUE, DISP_IN_GAME},	/*WC*/
 	{"tiled_map",     &iflags.wc_tiled_map, PREFER_TILED, DISP_IN_GAME},	/*WC*/
 	{"time", &flags.time, FALSE, SET_IN_GAME},
@@ -188,12 +250,28 @@ static struct Bool_Opt
 	{"tombstone",&flags.tombstone, TRUE, SET_IN_GAME},
 	{"toptenwin",&flags.toptenwin, FALSE, SET_IN_GAME},
 	{"travel", &iflags.travelcmd, TRUE, SET_IN_GAME},
+#ifdef UTF8_GLYPHS
+	{"UTF8graphics", &iflags.UTF8graphics, FALSE, SET_IN_GAME},
+#else
+	{"UTF8graphics", (boolean *)0, FALSE, SET_IN_FILE},
+#endif
+	{"use_darkgray", &iflags.wc2_darkgray, FALSE, SET_IN_FILE},
 #ifdef WIN32CON
 	{"use_inverse",   &iflags.wc_inverse, TRUE, SET_IN_GAME},		/*WC*/
 #else
 	{"use_inverse",   &iflags.wc_inverse, FALSE, SET_IN_GAME},		/*WC*/
 #endif
+#ifdef WIN_EDGE
+	{"win_edge", &iflags.win_edge, FALSE, SET_IN_GAME},
+#else
+	{"win_edge", (boolean *)0, TRUE, SET_IN_FILE},
+#endif
 	{"verbose", &flags.verbose, TRUE, SET_IN_GAME},
+#ifdef USE_TILES
+	{"vt_tiledata", &iflags.vt_nethack, FALSE, SET_IN_GAME},
+#else
+	{"vt_tiledata", (boolean *)0, FALSE, SET_IN_FILE},
+#endif
 	{"wraptext", &iflags.wc2_wraptext, FALSE, SET_IN_GAME},
 	{(char *)0, (boolean *)0, FALSE, 0}
 };
@@ -224,6 +302,14 @@ static struct Comp_Opt
 						SET_IN_GAME },
 	{ "dogname",  "the name of your (first) dog (e.g., dogname:Fang)",
 						PL_PSIZ, DISP_IN_GAME },
+#ifdef DUMP_LOG
+	{ "dumpfile", "where to dump data (e.g., dumpfile:/tmp/dump.nh)",
+#ifdef DUMP_FN
+						PL_PSIZ, DISP_IN_GAME },
+#else
+						PL_PSIZ, SET_IN_GAME },
+#endif
+#endif
 	{ "dungeon",  "the symbols to use in drawing the dungeon map",
 						MAXDCHARS+1, SET_IN_FILE },
 	{ "effects",  "the symbols to use in drawing special effects",
@@ -245,7 +331,9 @@ static struct Comp_Opt
 						8, DISP_IN_GAME },
 	{ "horsename", "the name of your (first) horse (e.g., horsename:Silver)",
 						PL_PSIZ, DISP_IN_GAME },
+	{ "hp_notify_fmt", "hp_notify format string", 20, SET_IN_GAME },
 	{ "map_mode", "map display mode under Windows", 20, DISP_IN_GAME },	/*WC*/
+	{ "menucolor", "set menu colors", PL_PSIZ, SET_IN_FILE },
 	{ "menustyle", "user interface for object selection",
 						MENUTYPELEN, SET_IN_GAME },
 	{ "menu_deselect_all", "deselect all items in a menu", 4, SET_IN_FILE },
@@ -288,6 +376,7 @@ static struct Comp_Opt
 						15, SET_IN_FILE },
 # endif
 #endif
+	{ "petattr",  "attributes for highlighting pets", 12, SET_IN_FILE },
 	{ "pettype",  "your preferred initial pet type", 4, DISP_IN_GAME },
 	{ "pickup_burden",  "maximum burden picked up before prompt",
 						20, SET_IN_GAME },
@@ -306,6 +395,9 @@ static struct Comp_Opt
 	{ "scroll_amount", "amount to scroll map when scroll_margin is reached",
 						20, DISP_IN_GAME }, /*WC*/
 	{ "scroll_margin", "scroll map when this far from the edge", 20, DISP_IN_GAME }, /*WC*/
+#ifdef SORTLOOT
+	{ "sortloot", "sort object selection lists by description", 4, SET_IN_GAME },
+#endif
 #ifdef MSDOS
 	{ "soundcard", "type of sound card to use", 20, SET_IN_FILE },
 #endif
@@ -527,11 +619,25 @@ initoptions()
 		monsyms[i] = (uchar) def_monsyms[i];
 	for (i = 0; i < WARNCOUNT; i++)
 		warnsyms[i] = def_warnsyms[i].sym;
+
+#ifdef USER_DUNGEONCOLOR
+	assign_colors((uchar *)0, 0, MAXPCHARS, 0);
+#endif
+
+/* FIXME: These should be integrated into objclass and permonst structs,
+   but that invalidates saves */
+	memset(objclass_unicode_codepoint, 0, sizeof(objclass_unicode_codepoint));
+	memset(permonst_unicode_codepoint, 0, sizeof(permonst_unicode_codepoint));
+
 	iflags.bouldersym = 0;
 	iflags.travelcc.x = iflags.travelcc.y = -1;
 	flags.warnlevel = 1;
 	flags.warntype = 0L;
 
+#ifdef SORTLOOT
+	iflags.sortloot = 'n';
+#endif
+
      /* assert( sizeof flags.inv_order == sizeof def_inv_order ); */
 	(void)memcpy((genericptr_t)flags.inv_order,
 		     (genericptr_t)def_inv_order, sizeof flags.inv_order);
@@ -566,6 +672,14 @@ initoptions()
 		switch_graphics(DEC_GRAPHICS);
 	}
 # endif
+#  ifdef HAVE_SETLOCALE
+	/* try to detect if a utf-8 locale is supported */
+	if (setlocale(LC_ALL, "") &&
+	    (opts = setlocale(LC_CTYPE, NULL)) &&
+	    ((strstri(opts, "utf8") != 0) || (strstri(opts, "utf-8") != 0))) {
+		switch_graphics(UTF8_GRAPHICS);
+	}
+#  endif
 #endif /* UNIX || VMS */
 
 #ifdef MAC_GRAPHICS_ENV
@@ -657,7 +771,7 @@ char *tp;
 		for (; (index("0123456789",*cp)) && (dcount++ < 3); cp++)
 		    cval = (cval * 10) + (*cp - '0');
 	}
-	else if (*cp == '\\')		/* C-style character escapes */
+	else if (*cp == '\\' && cp[1] != '\0')		/* C-style character escapes */
 	{
 	    switch (*++cp)
 	    {
@@ -670,13 +784,17 @@ char *tp;
 	    }
 	    cp++;
 	}
-	else if (*cp == '^')		/* expand control-character syntax */
+	else if (*cp == '^' && cp[1] != '\0')		/* expand control-character syntax */
 	{
 	    cval = (*++cp & 0x1f);
 	    cp++;
 	}
-	else
+	else if (*cp != '\0') {
 	    cval = *cp++;
+	} else {
+	    cval = 0;
+	    meta = 0;
+	}
 	if (meta)
 	    cval |= 0x80;
 	*tp++ = cval;
@@ -813,7 +931,7 @@ register char *opts;
 const char *optype;
 int maxlen, offset;
 {
-	uchar translate[MAXPCHARS+1];
+	glyph_t translate[MAXPCHARS+1];
 	int length, i;
 
 	if (!(opts = string_for_env_opt(optype, opts, FALSE)))
@@ -824,7 +942,7 @@ int maxlen, offset;
 	if (length > maxlen) length = maxlen;
 	/* match the form obtained from PC configuration files */
 	for (i = 0; i < length; i++)
-		translate[i] = (uchar) opts[i];
+		translate[i] = (glyph_t) opts[i];
 	assign_graphics(translate, length, maxlen, offset);
 }
 
@@ -891,6 +1009,173 @@ const char *optn;
 	return 1;
 }
 
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+
+struct name_value {
+    char *name;
+    int value;
+};
+
+const struct name_value status_colornames[] = {
+    { "black",      CLR_BLACK },
+    { "red",        CLR_RED },
+    { "green",      CLR_GREEN },
+    { "brown",      CLR_BROWN },
+    { "blue",       CLR_BLUE },
+    { "magenta",    CLR_MAGENTA },
+    { "cyan",       CLR_CYAN },
+    { "gray",       CLR_GRAY },
+    { "grey",       CLR_GRAY },
+    { "orange",     CLR_ORANGE },
+    { "lightgreen", CLR_BRIGHT_GREEN },
+    { "yellow",     CLR_YELLOW },
+    { "lightblue",  CLR_BRIGHT_BLUE },
+    { "lightmagenta", CLR_BRIGHT_MAGENTA },
+    { "lightcyan",  CLR_BRIGHT_CYAN },
+    { "white",      CLR_WHITE },
+    { NULL,         -1 }
+};
+
+const struct name_value status_attrnames[] = {
+    { "none",      ATR_NONE },
+    { "bold",      ATR_BOLD },
+    { "dim",       ATR_DIM },
+    { "underline", ATR_ULINE },
+    { "blink",     ATR_BLINK },
+    { "inverse",   ATR_INVERSE },
+    { NULL,        -1 }
+};
+
+int
+value_of_name(name, name_values)
+     const char *name;
+     const struct name_value *name_values;
+{
+    while (name_values->name && !strstri(name_values->name, name))
+	++name_values;
+    return name_values->value;
+}
+
+struct color_option
+parse_color_option(start)
+     char *start;
+{
+    struct color_option result = {NO_COLOR, 0};
+    char last;
+    char *end;
+    int attr;
+
+    for (end = start; *end != '&' && *end != '\0'; ++end);
+    last = *end;
+    *end = '\0';
+    result.color = value_of_name(start, status_colornames);
+
+    while (last == '&') {
+	for (start = ++end; *end != '&' && *end != '\0'; ++end);
+	last = *end;
+	*end = '\0';
+	attr = value_of_name(start, status_attrnames);
+	if (attr >= 0)
+	    result.attr_bits |= 1 << attr;
+    }
+
+    return result;
+}
+
+const struct percent_color_option *hp_colors = NULL;
+const struct percent_color_option *pw_colors = NULL;
+const struct text_color_option *text_colors = NULL;
+
+struct percent_color_option *
+add_percent_option(new_option, list_head)
+     struct percent_color_option *new_option;
+     struct percent_color_option *list_head;
+{
+    if (list_head == NULL)
+	return new_option;
+    if (new_option->percentage <= list_head->percentage) {
+	new_option->next = list_head;
+	return new_option;
+    }
+    list_head->next = add_percent_option(new_option, list_head->next);
+    return list_head;
+}
+
+boolean
+parse_status_color_option(start)
+     char *start;
+{
+    char *middle;
+
+    while (*start && isspace(*start)) start++;
+    for (middle = start; *middle != ':' && *middle != '=' && *middle != '\0'; ++middle);
+    *middle++ = '\0';
+    if (middle - start > 2 && (start[2] == '%' || start[2] == '.' || start[2] == '<' || start[2] == '>')) {
+                struct percent_color_option *percent_color_option =
+		    (struct percent_color_option *)alloc(sizeof(*percent_color_option));
+                percent_color_option->next = NULL;
+                percent_color_option->percentage = atoi(start + 3);
+		switch (start[2]) {
+		default:
+		case '%': percent_color_option->statclrtype = STATCLR_TYPE_PERCENT; break;
+		case '.': percent_color_option->statclrtype = STATCLR_TYPE_NUMBER_EQ; break;
+		case '>': percent_color_option->statclrtype = STATCLR_TYPE_NUMBER_GT; break;
+		case '<': percent_color_option->statclrtype = STATCLR_TYPE_NUMBER_LT; break;
+		}
+                percent_color_option->color_option = parse_color_option(middle);
+                start[2] = '\0';
+                if (percent_color_option->color_option.color >= 0
+		    && percent_color_option->color_option.attr_bits >= 0) {
+		    if (!strcmpi(start, "hp")) {
+			hp_colors = add_percent_option(percent_color_option, hp_colors);
+			return TRUE;
+		    }
+		    if (!strcmpi(start, "pw")) {
+			pw_colors = add_percent_option(percent_color_option, pw_colors);
+			return TRUE;
+		    }
+                }
+                free(percent_color_option);
+                return FALSE;
+    } else {
+	int length = strlen(start) + 1;
+                struct text_color_option *text_color_option =
+		    (struct text_color_option *)alloc(sizeof(*text_color_option));
+                text_color_option->next = NULL;
+                text_color_option->text = (char *)alloc(length);
+                memcpy((char *)text_color_option->text, start, length);
+                text_color_option->color_option = parse_color_option(middle);
+                if (text_color_option->color_option.color >= 0
+		    && text_color_option->color_option.attr_bits >= 0) {
+		    text_color_option->next = text_colors;
+		    text_colors = text_color_option;
+		    return TRUE;
+                }
+                free((genericptr_t)text_color_option->text);
+                free(text_color_option);
+                return FALSE;
+    }
+}
+
+boolean
+parse_status_color_options(start)
+     char *start;
+{
+    char last = ',';
+    char *end = start - 1;
+    boolean ok = TRUE;
+    while (last == ',') {
+	for (start = ++end; *end != ',' && *end != '\0'; ++end);
+	last = *end;
+	*end = '\0';
+	ok = parse_status_color_option(start) && ok;
+    }
+    return ok;
+}
+
+#endif /* STATUS_COLORS */
+
+
 void
 set_duplicate_opt_detection(on_or_off)
 int on_or_off;
@@ -964,6 +1249,372 @@ int bool_or_comp;	/* 0 == boolean option
 	}
 }
 
+static const struct {
+   const char *name;
+   const int color;
+} colornames[] = {
+   {"black", CLR_BLACK},
+   {"red", CLR_RED},
+   {"green", CLR_GREEN},
+   {"brown", CLR_BROWN},
+   {"blue", CLR_BLUE},
+   {"magenta", CLR_MAGENTA},
+   {"cyan", CLR_CYAN},
+   {"gray", CLR_GRAY},
+   {"grey", CLR_GRAY},
+   {"orange", CLR_ORANGE},
+   {"lightgreen", CLR_BRIGHT_GREEN},
+   {"yellow", CLR_YELLOW},
+   {"lightblue", CLR_BRIGHT_BLUE},
+   {"lightmagenta", CLR_BRIGHT_MAGENTA},
+   {"lightcyan", CLR_BRIGHT_CYAN},
+   {"white", CLR_WHITE}
+};
+
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+
+static const struct {
+   const char *name;
+   const int attr;
+} attrnames[] = {
+     {"none", ATR_NONE},
+     {"bold", ATR_BOLD},
+     {"dim", ATR_DIM},
+     {"underline", ATR_ULINE},
+     {"blink", ATR_BLINK},
+     {"inverse", ATR_INVERSE}
+
+};
+
+/* parse '"regex_string"=color&attr' and add it to menucoloring */
+boolean
+add_menu_coloring(str)
+char *str;
+{
+    int i, c = NO_COLOR, a = ATR_NONE;
+    struct menucoloring *tmp;
+    char *tmps, *cs = strchr(str, '=');
+#ifdef MENU_COLOR_REGEX_POSIX
+    int errnum;
+    char errbuf[80];
+#endif
+    const char *err = (char *)0;
+
+    if (!cs || !str) return FALSE;
+
+    tmps = cs;
+    tmps++;
+    while (*tmps && isspace(*tmps)) tmps++;
+
+    for (i = 0; i < SIZE(colornames); i++)
+	if (strstri(tmps, colornames[i].name) == tmps) {
+	    c = colornames[i].color;
+	    break;
+	}
+    if ((i == SIZE(colornames)) && (*tmps >= '0' && *tmps <='9'))
+	c = atoi(tmps);
+
+    if (c > 15) return FALSE;
+
+    tmps = strchr(str, '&');
+    if (tmps) {
+	tmps++;
+	while (*tmps && isspace(*tmps)) tmps++;
+	for (i = 0; i < SIZE(attrnames); i++)
+	    if (strstri(tmps, attrnames[i].name) == tmps) {
+		a = attrnames[i].attr;
+		break;
+	    }
+	if ((i == SIZE(attrnames)) && (*tmps >= '0' && *tmps <='9'))
+	    a = atoi(tmps);
+    }
+
+    *cs = '\0';
+    tmps = str;
+    if ((*tmps == '"') || (*tmps == '\'')) {
+	cs--;
+	while (isspace(*cs)) cs--;
+	if (*cs == *tmps) {
+	    *cs = '\0';
+	    tmps++;
+	}
+    }
+
+    tmp = (struct menucoloring *)alloc(sizeof(struct menucoloring));
+#ifdef MENU_COLOR_REGEX
+#ifdef MENU_COLOR_REGEX_POSIX
+    errnum = regcomp(&tmp->match, tmps, REG_EXTENDED | REG_NOSUB);
+    if (errnum != 0)
+    {
+	regerror(errnum, &tmp->match, errbuf, sizeof(errbuf));
+	err = errbuf;
+    }
+#else
+    tmp->match.translate = 0;
+    tmp->match.fastmap = 0;
+    tmp->match.buffer = 0;
+    tmp->match.allocated = 0;
+    tmp->match.regs_allocated = REGS_FIXED;
+    err = re_compile_pattern(tmps, strlen(tmps), &tmp->match);
+#endif
+#else
+    tmp->match = (char *)alloc(strlen(tmps)+1);
+    (void) memcpy((genericptr_t)tmp->match, (genericptr_t)tmps, strlen(tmps)+1);
+#endif
+    if (err) {
+	raw_printf("\nMenucolor regex error: %s\n", err);
+	wait_synch();
+	free(tmp);
+	return FALSE;
+    } else {
+	tmp->next = menu_colorings;
+	tmp->color = c;
+	tmp->attr = a;
+	menu_colorings = tmp;
+	return TRUE;
+    }
+}
+#endif /* MENU_COLOR */
+
+/* parse '"monster name":color' and change monster info accordingly */
+boolean
+parse_monster_color(str)
+     char *str;
+{
+    int i, c = NO_COLOR;
+    char *tmps, *cs = strchr(str, ':');
+    char buf[BUFSZ];
+    int monster;
+
+    if (!str) return FALSE;
+
+    strncpy(buf, str, BUFSZ);
+    cs = strchr(buf, ':');
+    if (!cs) return FALSE;
+
+    tmps = cs;
+    tmps++;
+    /* skip whitespace at start of string */
+    while (*tmps && isspace(*tmps)) tmps++;
+
+    /* determine color */
+    for (i = 0; i < SIZE(colornames); i++)
+	if (strstri(tmps, colornames[i].name) == tmps) {
+	    c = colornames[i].color;
+	    break;
+	}
+    if ((i == SIZE(colornames)) && (*tmps >= '0' && *tmps <='9'))
+	c = atoi(tmps);
+
+    if (c > 15) return FALSE;
+
+    /* determine monster name */
+    *cs = '\0';
+    tmps = buf;
+    if ((*tmps == '"') || (*tmps == '\'')) {
+	cs--;
+	while (isspace(*cs)) cs--;
+	if (*cs == *tmps) {
+	    *cs = '\0';
+	    tmps++;
+	}
+    }
+
+    monster = name_to_mon(tmps);
+    if (monster > -1) {
+	mons[monster].mcolor = c;
+	return TRUE;
+    } else {
+	return FALSE;
+    }
+}
+
+/** Split up a string that matches name:value or 'name':value and
+ * return name and value separately. */
+static boolean
+parse_extended_option(str, option_name, option_value)
+const char *str;
+char *option_name;	/**< Output string buffer for option name */
+char *option_value;	/**< Output string buffer for option value */
+{
+	int i;
+	char *tmps, *cs;
+	char buf[BUFSZ];
+
+	if (!str) return FALSE;
+
+	strncpy(buf, str, BUFSZ);
+
+	/* remove comment*/
+	cs = strrchr(buf, '#');
+	if (cs) *cs = '\0';
+
+	/* trim whitespace at end of string */
+	i = strlen(buf)-1;
+	while (i>=0 && isspace(buf[i])) {
+		buf[i--] = '\0';
+	}
+
+	/* extract value */
+	cs = strchr(buf, ':');
+	if (!cs) return FALSE;
+
+	tmps = cs;
+	tmps++;
+	/* skip whitespace at start of string */
+	while (*tmps && isspace(*tmps)) tmps++;
+
+	strncpy(option_value, tmps, BUFSZ);
+
+	/* extract option name */
+	*cs = '\0';
+	tmps = buf;
+	if ((*tmps == '"') || (*tmps == '\'')) {
+		cs--;
+		while (isspace(*cs)) cs--;
+		if (*cs == *tmps) {
+			*cs = '\0';
+			tmps++;
+		}
+	}
+
+	strncpy(option_name, tmps, BUFSZ);
+
+	return TRUE;
+}
+
+/** Parse a string as Unicode codepoint and return the numerical codepoint.
+ * Valid codepoints are decimal numbers or U+FFFF and 0xFFFF for hexadecimal
+ * values. */
+int
+parse_codepoint(codepoint)
+char *codepoint;
+{
+	char *ptr, *endptr;
+	int num=0, base;
+
+	/* parse codepoint */
+	if (!strncmpi(codepoint, "u+", 2) ||
+	    !strncmpi(codepoint, "0x", 2)) {
+		/* hexadecimal */
+		ptr = &codepoint[2];
+		base = 16;
+	} else {
+		/* decimal */
+		ptr = &codepoint[0];
+		base = 10;
+	}
+	errno = 0;
+	num = strtol(ptr, &endptr, base);
+	if (errno != 0 || *endptr != 0 || endptr == ptr) {
+		return FALSE;
+	}
+	return num;
+}
+
+/** Parse '"monster name":unicode_codepoint' and change symbol in
+ * monster list. */
+boolean
+parse_monster_symbol(str)
+const char *str;
+{
+	char monster[BUFSZ];
+	char codepoint[BUFSZ];
+	int i, num=0;
+
+	if (!parse_extended_option(str, monster, codepoint)) {
+		return FALSE;
+	}
+
+	num = parse_codepoint(codepoint);
+	if (num < 0) {
+		return FALSE;
+	}
+
+	/* find monster */
+	for (i=0; mons[i].mlet != 0; i++) {
+		if (!strcmpi(monster, mons[i].mname)) {
+			permonst_unicode_codepoint[i] = num;
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+/** Parse '"object name":unicode_codepoint' and change symbol in
+ * object list. */
+boolean
+parse_object_symbol(str)
+const char *str;
+{
+       char object[BUFSZ];
+       char codepoint[BUFSZ];
+       int i, num=0;
+
+       if (!parse_extended_option(str, object, codepoint)) {
+               return FALSE;
+       }
+
+       num = parse_codepoint(codepoint);
+       if (num < 0) {
+               return FALSE;
+       }
+
+       /* find object */
+       for (i=0; obj_descr[i].oc_name || obj_descr[i].oc_descr; i++) {
+               if ((obj_descr[i].oc_name && obj_descr[i].oc_descr) ||
+                   (obj_descr[i].oc_descr)) {
+                       /* Items with both descriptive and actual name or only
+                        * descriptive name. */
+                       if (!strcmpi(object, obj_descr[i].oc_descr)) {
+                               objclass_unicode_codepoint[i] = num;
+                               return TRUE;
+                       }
+               } else if (obj_descr[i].oc_name) {
+                       /* items with only actual name like "carrot" */
+                       if (!strcmpi(object, obj_descr[i].oc_name)) {
+                               objclass_unicode_codepoint[i] = num;
+                               return TRUE;
+                       }
+               }
+       }
+       return FALSE;
+}
+
+
+/** Parse '"dungeon feature":unicode_codepoint' and change symbol in
+ * UTF8graphics. */
+boolean
+parse_symbol(str)
+const char *str;
+{
+	char feature[BUFSZ];
+	char codepoint[BUFSZ];
+	int i, num;
+
+	if (!parse_extended_option(str, feature, codepoint)) {
+		return FALSE;
+	}
+
+	num = parse_codepoint(codepoint);
+	if (num < 0) {
+		return FALSE;
+	}
+
+	/* find dungeon feature */
+	for (i=0; i < MAXPCHARS; i++) {
+		if (!strcmpi(feature, defsyms[i].explanation)) {
+			assign_utf8graphics_symbol(i, num);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+
 void
 parseoptions(opts, tinitial, tfrom_file)
 register char *opts;
@@ -987,9 +1638,7 @@ boolean tinitial, tfrom_file;
 	}
 
 	/* strip leading and trailing white space */
-	while (isspace(*opts)) opts++;
-	op = eos(opts);
-	while (--op >= opts && isspace(*op)) *op = '\0';
+	opts = stripspace(opts);
 
 	if (!*opts) return;
 	negated = FALSE;
@@ -1066,6 +1715,7 @@ boolean tinitial, tfrom_file;
 		if (negated) bad_negation(fullname, FALSE);
 		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
 			nmcpy(catname, op, PL_PSIZ);
+		sanitizestr(catname);
 		return;
 	}
 
@@ -1074,14 +1724,29 @@ boolean tinitial, tfrom_file;
 		if (negated) bad_negation(fullname, FALSE);
 		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
 			nmcpy(dogname, op, PL_PSIZ);
+		sanitizestr(dogname);
 		return;
 	}
 
+#ifdef DUMP_LOG
+	fullname = "dumpfile";
+	if (match_optname(opts, fullname, 3, TRUE)) {
+#ifndef DUMP_FN
+		if (negated) bad_negation(fullname, FALSE);
+		else if ((op = string_for_opt(opts, !tfrom_file)) != 0
+			&& strlen(op) > 1)
+			nmcpy(dump_fn, op, PL_PSIZ);
+#endif
+		return;
+       }
+#endif
+
 	fullname = "horsename";
 	if (match_optname(opts, fullname, 5, TRUE)) {
 		if (negated) bad_negation(fullname, FALSE);
 		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
 			nmcpy(horsename, op, PL_PSIZ);
+		sanitizestr(horsename);
 		return;
 	}
 
@@ -1133,6 +1798,28 @@ boolean tinitial, tfrom_file;
 		return;
 	}
 
+	/* menucolor:"regex_string"=color */
+	fullname = "menucolor";
+	if (match_optname(opts, fullname, 9, TRUE)) {
+#ifdef MENU_COLOR
+	    if (negated) bad_negation(fullname, FALSE);
+	    else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
+		if (!add_menu_coloring(op))
+		    badoption(opts);
+#endif
+	    return;
+	}
+
+	fullname = "hp_notify_fmt";
+	if (match_optname(opts, fullname, sizeof("hp_notify_fmt")-1, TRUE)) {
+		if ((op = string_for_opt(opts, FALSE)) != 0) {
+			if (iflags.hp_notify_fmt) free(iflags.hp_notify_fmt);
+			iflags.hp_notify_fmt = (char *)alloc(strlen(op) + 1);
+			Strcpy(iflags.hp_notify_fmt, op);
+		}
+		return;
+	}
+
 	fullname = "msghistory";
 	if (match_optname(opts, fullname, 3, TRUE)) {
 		op = string_for_env_opt(fullname, opts, negated);
@@ -1351,6 +2038,7 @@ boolean tinitial, tfrom_file;
 		}
 goodfruit:
 		nmcpy(pl_fruit, op, PL_FSIZ);
+		sanitizestr(pl_fruit);
 	/* OBJ_NAME(objects[SLIME_MOLD]) won't work after initialization */
 		if (!*pl_fruit)
 		    nmcpy(pl_fruit, "slime mold", PL_FSIZ);
@@ -1839,6 +2527,36 @@ goodfruit:
 	    return;
 	}
 
+        fullname = "statuscolor";
+        if (match_optname(opts, fullname, 11, TRUE)) {
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+	    if (negated) bad_negation(fullname, FALSE);
+	    else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
+		if (!parse_status_color_options(op))
+		    badoption(opts);
+#endif
+            return;
+        }
+
+
+#ifdef SORTLOOT
+	fullname = "sortloot";
+	if (match_optname(opts, fullname, 4, TRUE)) {
+		op = string_for_env_opt(fullname, opts, FALSE);
+		if (op) {
+			switch (tolower(*op)) {
+                        case 'n':
+                        case 'l':
+                        case 'f': iflags.sortloot = tolower(*op);
+				break;
+                        default:  badoption(opts);
+				return;
+			}
+		}
+		return;
+	}
+#endif /* SORTLOOT */
+
 	fullname = "suppress_alert";
 	if (match_optname(opts, fullname, 4, TRUE)) {
 		op = string_for_opt(opts, negated);
@@ -2043,6 +2761,64 @@ goodfruit:
 		return;
 	}
 
+
+	/* WINCAP2
+	 * term_cols:amount */
+	fullname = "term_cols";
+	if (match_optname(opts, fullname, sizeof("term_cols")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		iflags.wc2_term_cols = atoi(op);
+		if (negated) bad_negation(fullname, FALSE);
+		return;
+	}
+
+	/* WINCAP2
+	 * term_rows:amount */
+	fullname = "term_rows";
+	if (match_optname(opts, fullname, sizeof("term_rows")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		iflags.wc2_term_rows = atoi(op);
+		if (negated) bad_negation(fullname, FALSE);
+		return;
+	}
+
+
+	/* WINCAP2
+	 * petattr:string */
+	fullname = "petattr";
+	if (match_optname(opts, fullname, sizeof("petattr")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		if (op && !negated) {
+		    iflags.wc2_petattr = curses_read_attrs(op);
+		    if (!curses_read_attrs(op))
+		    	badoption(opts);
+		} else if (negated) bad_negation(fullname, TRUE);
+		return;
+	}
+
+
+	/* WINCAP2
+	 * windowborders:n */
+	fullname = "windowborders";
+	if (match_optname(opts, fullname, sizeof("windowborders")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		if (negated && op) bad_negation(fullname, TRUE);
+		else {
+		    if (negated)
+		        iflags.wc2_windowborders = 2; /* Off */
+		    else if (!op)
+		        iflags.wc2_windowborders = 1; /* On */
+		    else    /* Value supplied */
+		        iflags.wc2_windowborders = atoi(op);
+		    if ((iflags.wc2_windowborders > 3) ||
+		     (iflags.wc2_windowborders < 1)) {
+		        iflags.wc2_windowborders = 0;
+		        badoption(opts);
+		    }
+		}
+		return;
+	}
+
 	/* menustyle:traditional or combo or full or partial */
 	if (match_optname(opts, "menustyle", 4, TRUE)) {
 		int tmp;
@@ -2149,7 +2925,7 @@ goodfruit:
 
 			duplicate_opt_detection(boolopt[i].name, 0);
 
-#if defined(TERMLIB) || defined(ASCIIGRAPH) || defined(MAC_GRAPHICS_ENV)
+#if defined(TERMLIB) || defined(ASCIIGRAPH) || defined(MAC_GRAPHICS_ENV) || defined(CURSES_GRAPHICS)
 			if (FALSE
 # ifdef TERMLIB
 				 || (boolopt[i].addr) == &iflags.DECgraphics
@@ -2160,6 +2936,12 @@ goodfruit:
 # ifdef MAC_GRAPHICS_ENV
 				 || (boolopt[i].addr) == &iflags.MACgraphics
 # endif
+# ifdef UTF8_GLYPHS
+				 || (boolopt[i].addr) == &iflags.UTF8graphics
+# endif
+# ifdef CURSES_GRAPHICS
+				 || (boolopt[i].addr) == &iflags.cursesgraphics
+# endif
 				) {
 # ifdef REINCARNATION
 			    if (!initial && Is_rogue_level(&u.uz))
@@ -2181,6 +2963,16 @@ goodfruit:
 				switch_graphics(iflags.MACgraphics ?
 						MAC_GRAPHICS : ASCII_GRAPHICS);
 # endif
+# ifdef UTF8_GLYPHS
+			    if ((boolopt[i].addr) == &iflags.UTF8graphics)
+				switch_graphics(iflags.UTF8graphics ?
+						UTF8_GRAPHICS : ASCII_GRAPHICS);
+# endif
+# ifdef CURSES_GRAPHICS
+			    if ((boolopt[i].addr) == &iflags.cursesgraphics)
+				switch_graphics(iflags.cursesgraphics ?
+						CURS_GRAPHICS : ASCII_GRAPHICS);
+# endif
 # ifdef REINCARNATION
 			    if (!initial && Is_rogue_level(&u.uz))
 				assign_rogue_graphics(TRUE);
@@ -2223,9 +3015,15 @@ goodfruit:
 			}
 			else if ((boolopt[i].addr) == &iflags.use_inverse ||
 					(boolopt[i].addr) == &iflags.showrace ||
-					(boolopt[i].addr) == &iflags.hilite_pet) {
+					(boolopt[i].addr) == &iflags.hilite_pet ||
+					(boolopt[i].addr) == &iflags.wc2_guicolor) {
+			    need_redraw = TRUE;
+			}
+#ifdef CURSES_GRAPHICS
+			else if ((boolopt[i].addr) == &iflags.cursesgraphics) {
 			    need_redraw = TRUE;
 			}
+#endif
 #ifdef TEXTCOLOR
 			else if ((boolopt[i].addr) == &iflags.use_color) {
 			    need_redraw = TRUE;
@@ -2263,6 +3061,12 @@ static NEARDATA const char *runmodes[] =
 	"teleport", "run", "walk", "crawl"
 };
 
+#ifdef SORTLOOT
+static NEARDATA const char *sortltype[] = {
+	"none", "loot", "full"
+};
+#endif
+
 /*
  * Convert the given string of object classes to a string of default object
  * symbols.
@@ -2540,7 +3344,7 @@ boolean setinitial,setfromfile;
     boolean retval = FALSE;
     
     /* Special handling of menustyle, pickup_burden, pickup_types,
-     * disclose, runmode, msg_window, menu_headings, and number_pad options.
+     * disclose, runmode, msg_window, menu_headings, number_pad and sortloot
 #ifdef AUTOPICKUP_EXCEPTIONS
      * Also takes care of interactive autopickup_exception_handling changes.
 #endif
@@ -2761,6 +3565,26 @@ boolean setinitial,setfromfile;
         }
 	destroy_nhwindow(tmpwin);
         retval = TRUE;
+#ifdef SORTLOOT
+    } else if (!strcmp("sortloot", optname)) {
+	const char *sortl_name;
+	menu_item *sortl_pick = (menu_item *)0;
+	tmpwin = create_nhwindow(NHW_MENU);
+	start_menu(tmpwin);
+	for (i = 0; i < SIZE(sortltype); i++) {
+	    sortl_name = sortltype[i];
+	    any.a_char = *sortl_name;
+	    add_menu(tmpwin, NO_GLYPH, &any, *sortl_name, 0,
+		     ATR_NONE, sortl_name, MENU_UNSELECTED);
+	}
+	end_menu(tmpwin, "Select loot sorting type:");
+	if (select_menu(tmpwin, PICK_ONE, &sortl_pick) > 0) {
+	    iflags.sortloot = sortl_pick->item.a_char;
+	    free((genericptr_t)sortl_pick);
+	}
+	destroy_nhwindow(tmpwin);
+	retval = TRUE;
+#endif /* SORTLOOT */
     } else if (!strcmp("menu_headings", optname)) {
 	static const char *mhchoices[3] = {"bold", "inverse", "underline"};
 	const char *npletters = "biu";
@@ -2933,6 +3757,12 @@ char *buf;
 	}
 	else if (!strcmp(optname, "dogname")) 
 		Sprintf(buf, "%s", dogname[0] ? dogname : none );
+#ifdef DUMP_LOG
+	else if (!strcmp(optname, "dumpfile"))
+		Sprintf(buf, "%s", dump_fn[0] ? dump_fn: none );
+#endif
+	else if (!strcmp(optname, "hp_notify_fmt"))
+		Sprintf(buf, "%s", iflags.hp_notify_fmt ? iflags.hp_notify_fmt : "[HP%c%a=%h]" );
 	else if (!strcmp(optname, "dungeon"))
 		Sprintf(buf, "%s", to_be_done);
 	else if (!strcmp(optname, "effects"))
@@ -3072,6 +3902,17 @@ char *buf;
 		if (iflags.wc_scroll_margin) Sprintf(buf, "%d",iflags.wc_scroll_margin);
 		else Strcpy(buf, defopt);
 	}
+#ifdef SORTLOOT
+	else if (!strcmp(optname, "sortloot")) {
+		char *sortname = (char *)NULL;
+		for (i=0; i < SIZE(sortltype) && sortname==(char *)NULL; i++) {
+		   if (iflags.sortloot == sortltype[i][0])
+		     sortname = (char *)sortltype[i];
+		}
+		if (sortname != (char *)NULL)
+		   Sprintf(buf, "%s", sortname);
+	}
+#endif /* SORTLOOT */
 	else if (!strcmp(optname, "player_selection"))
 		Sprintf(buf, "%s", iflags.wc_player_selection ? "prompts" : "dialog");
 #ifdef MSDOS
@@ -3087,6 +3928,14 @@ char *buf;
 			FEATURE_NOTICE_VER_MIN,
 			FEATURE_NOTICE_VER_PATCH);
 	}
+	else if (!strcmp(optname, "term_cols")) {
+		if (iflags.wc2_term_cols) Sprintf(buf, "%d",iflags.wc2_term_cols);
+		else Strcpy(buf, defopt);
+	}
+	else if (!strcmp(optname, "term_rows")) {
+		if (iflags.wc2_term_rows) Sprintf(buf, "%d",iflags.wc2_term_rows);
+		else Strcpy(buf, defopt);
+	}
 	else if (!strcmp(optname, "tile_file"))
 		Sprintf(buf, "%s", iflags.wc_tile_file ? iflags.wc_tile_file : defopt);
 	else if (!strcmp(optname, "tile_height")) {
@@ -3120,6 +3969,11 @@ char *buf;
 			ttycolors[CLR_BRIGHT_MAGENTA],
 			ttycolors[CLR_BRIGHT_CYAN]);
 #endif /* VIDEOSHADES */
+	else if (!strcmp(optname,"windowborders"))
+		Sprintf(buf, "%s", iflags.wc2_windowborders == 1     ? "1=on" :
+				   iflags.wc2_windowborders == 2             ? "2=off" :
+				   iflags.wc2_windowborders == 3             ? "3=auto" :
+				   defopt);
 	else if (!strcmp(optname, "windowtype"))
 		Sprintf(buf, "%s", windowprocs.name);
 	else if (!strcmp(optname, "windowcolors"))
@@ -3193,6 +4047,23 @@ const char *mapping;
 				alloc(sizeof(struct autopickup_exception));
 		ape->pattern = (char *) alloc(textsize+1);
 		Strcpy(ape->pattern, text2);
+		ape->is_regexp = iflags.ape_regex;
+		if (iflags.ape_regex) {
+		    int errnum;
+		    char errbuf[80];
+		    const char *err = (char *)0;
+		    errnum = regcomp(&ape->match, text2, REG_EXTENDED | REG_NOSUB);
+		    if (errnum != 0) {
+			regerror(errnum, &ape->match, errbuf, sizeof(errbuf));
+			err = errbuf;
+		    }
+		    if (err) {
+			raw_printf("\nAUTOPICKUP_EXCEPTION regex error: %s\n", err);
+			wait_synch();
+			free(ape);
+			return 0;
+		    }
+		}
 		ape->grab = grab;
 		if (!*apehead) ape->next = (struct autopickup_exception *)0;
 		else ape->next = *apehead;
@@ -3218,6 +4089,9 @@ struct autopickup_exception *whichape;
 	    if (prev) prev->next = ape;
 	    else iflags.autopickup_exceptions[chain] = ape;
 	    free(freeape->pattern);
+	    if (freeape->is_regexp) {
+		(void) regfree(&freeape->match);
+	    }
 	    free(freeape);
 	} else {
 	    prev = ape;
@@ -3254,7 +4128,10 @@ free_autopickup_exceptions()
 
 	for (pass = AP_LEAVE; pass <= AP_GRAB; ++pass) {
 		while((ape = iflags.autopickup_exceptions[pass]) != 0) {
-			free(ape->pattern);
+		    free(ape->pattern);
+		    if (ape->is_regexp) {
+			(void) regfree(&ape->match);
+		    }
 			iflags.autopickup_exceptions[pass] = ape->next;
 			free(ape);
 		}
@@ -3593,6 +4470,12 @@ struct wc_Opt wc2_options[] = {
 	{"fullscreen", WC2_FULLSCREEN},
 	{"softkeyboard", WC2_SOFTKEYBOARD},
 	{"wraptext", WC2_WRAPTEXT},
+	{"term_cols", WC2_TERM_COLS},
+	{"term_rows", WC2_TERM_ROWS},
+	{"windowborders", WC2_WINDOWBORDERS},
+	{"petattr", WC2_PETATTR},
+	{"guicolor", WC2_GUICOLOR},
+	{"use_darkgray", WC2_DARKGRAY},
 	{(char *)0, 0L}
 };
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/pager.c nethack-3.4.3-nao-osx/src/pager.c
--- nethack-3.4.3/src/pager.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/pager.c	2014-12-20 12:08:36.000000000 -0800
@@ -11,8 +11,6 @@
 STATIC_DCL boolean FDECL(is_swallow_sym, (int));
 STATIC_DCL int FDECL(append_str, (char *, const char *));
 STATIC_DCL struct permonst * FDECL(lookat, (int, int, char *, char *));
-STATIC_DCL void FDECL(checkfile,
-		      (char *,struct permonst *,BOOLEAN_P,BOOLEAN_P));
 STATIC_DCL int FDECL(do_look, (BOOLEAN_P));
 STATIC_DCL boolean FDECL(help_menu, (int *));
 #ifdef PORT_HELP
@@ -298,7 +296,7 @@ lookat(x, y, buf, monbuf)
  *	 lcase() for data.base lookup so that we can have a clean key.
  *	 Therefore, we create a copy of inp _just_ for data.base lookup.
  */
-STATIC_OVL void
+void
 checkfile(inp, pm, user_typed_name, without_asking)
     char *inp;
     struct permonst *pm;
@@ -462,16 +460,18 @@ do_look(quick)
     const char *x_str, *firstmatch = 0;
     struct permonst *pm = 0;
     int     i, ans = 0;
-    int     sym;		/* typed symbol or converted glyph */
+    glyph_t sym;		/* typed symbol or converted glyph */
     int	    found;		/* count of matching syms found */
     coord   cc;			/* screen pos of unknown glyph */
     boolean save_verbose;	/* saved value of flags.verbose */
     boolean from_screen;	/* question from the screen */
+    boolean force_defsyms;	/* force using glyphs from defsyms[].sym */
     boolean need_to_look;	/* need to get explan. from glyph */
     boolean hit_trap;		/* true if found trap explanation */
     int skipped_venom;		/* non-zero if we ignored "splash of venom" */
     static const char *mon_interior = "the interior of a monster";
 
+    force_defsyms = FALSE;
     if (quick) {
 	from_screen = TRUE;	/* yes, we want to use the cursor */
     } else {
@@ -529,7 +529,14 @@ do_look(quick)
 	    /* Convert the glyph at the selected position to a symbol. */
 	    glyph = glyph_at(cc.x,cc.y);
 	    if (glyph_is_cmap(glyph)) {
-		sym = showsyms[glyph_to_cmap(glyph)];
+		if (iflags.UTF8graphics) {
+			/* Temporary workaround as NetHack can't yet
+			 * display UTF-8 glyphs on the topline */
+			force_defsyms = TRUE;
+			sym = defsyms[glyph_to_cmap(glyph)].sym;
+		} else {
+			sym = showsyms[glyph_to_cmap(glyph)];
+		}
 	    } else if (glyph_is_trap(glyph)) {
 		sym = showsyms[trap_to_defsym(glyph_to_trap(glyph))];
 	    } else if (glyph_is_object(glyph)) {
@@ -630,7 +637,7 @@ do_look(quick)
 	/* Now check for graphics symbols */
 	for (hit_trap = FALSE, i = 0; i < MAXPCHARS; i++) {
 	    x_str = defsyms[i].explanation;
-	    if (sym == (from_screen ? showsyms[i] : defsyms[i].sym) && *x_str) {
+	    if (sym == (force_defsyms ? defsyms[i].sym : (from_screen ? showsyms[i] : defsyms[i].sym)) && *x_str) {
 		/* avoid "an air", "a water", or "a floor of a room" */
 		int article = (i == S_room) ? 2 :		/* 2=>"the" */
 			      !(strcmp(x_str, "air") == 0 ||	/* 1=>"an"  */
@@ -866,8 +873,9 @@ static const char *help_menu_items[] = {
 /* 4*/	"Info on what a given key does.",
 /* 5*/	"List of game options.",
 /* 6*/	"Longer explanation of game options.",
-/* 7*/	"List of extended commands.",
-/* 8*/	"The NetHack license.",
+/* 7*/  "Full list of keyboard commands.",
+/* 8*/	"List of extended commands.",
+/* 9*/	"The NetHack license.",
 #ifdef PORT_HELP
 	"%s-specific help and commands.",
 #define PORT_HELP_ID 100
@@ -940,8 +948,9 @@ dohelp()
 			case  4:  (void) dowhatdoes();  break;
 			case  5:  option_help();  break;
 			case  6:  display_file(OPTIONFILE, TRUE);  break;
-			case  7:  (void) doextlist();  break;
-			case  8:  display_file(LICENSE, TRUE);  break;
+			case  7:  dokeylist(); break;
+			case  8:  (void) doextlist();  break;
+			case  9:  display_file(LICENSE, TRUE);  break;
 #ifdef WIZARD
 			/* handle slot 9 or 10 */
 			default: display_file(DEBUGHELP, TRUE);  break;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/pickup.c nethack-3.4.3-nao-osx/src/pickup.c
--- nethack-3.4.3/src/pickup.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/pickup.c	2014-12-20 12:08:36.000000000 -0800
@@ -267,7 +267,7 @@ boolean picked_some;
 
 	/* If there are objects here, take a look. */
 	if (ct) {
-	    if (flags.run) nomul(0);
+	    if (flags.run) nomul(0, NULL);
 	    flush_screen(1);
 	    (void) look_here(ct, picked_some);
 	} else {
@@ -440,7 +440,7 @@ int what;		/* should be a long */
 		}
 
 		/* if there's anything here, stop running */
-		if (OBJ_AT(u.ux,u.uy) && flags.run && flags.run != 8 && !flags.nopick) nomul(0);
+		if (OBJ_AT(u.ux,u.uy) && flags.run && flags.run != 8 && !flags.nopick) nomul(0, NULL);
 	}
 
 	add_valid_menu_class(0);	/* reset */
@@ -609,7 +609,11 @@ boolean grab;	 /* forced pickup, rather 
 					iflags.autopickup_exceptions[AP_GRAB] :
 					iflags.autopickup_exceptions[AP_LEAVE];
 	while (ape) {
+	    if (ape->is_regexp) {
+		if (regexec(&ape->match, objdesc, 0, NULL, 0) == 0) return TRUE;
+	    } else {
 		if (pmatch(ape->pattern, objdesc)) return TRUE;
+	    }
 		ape = ape->next;
 	}
 	return FALSE;
@@ -639,11 +643,11 @@ menu_item **pick_list;	/* list of object
 
 
 #ifndef AUTOPICKUP_EXCEPTIONS
-	    if (!*otypes || index(otypes, curr->oclass))
+           if (!*otypes || index(otypes, curr->oclass) || (iflags.pickup_thrown && curr->was_thrown))
 #else
-	    if ((!*otypes || index(otypes, curr->oclass) ||
-		 is_autopickup_exception(curr, TRUE)) &&
-	    	 !is_autopickup_exception(curr, FALSE))
+	     if (((!*otypes || index(otypes, curr->oclass) ||
+		   is_autopickup_exception(curr, TRUE)) &&
+		  !is_autopickup_exception(curr, FALSE)) || (iflags.pickup_thrown && curr->was_thrown))
 #endif
 		n++;
 
@@ -651,11 +655,11 @@ menu_item **pick_list;	/* list of object
 	    *pick_list = pi = (menu_item *) alloc(sizeof(menu_item) * n);
 	    for (n = 0, curr = olist; curr; curr = FOLLOW(curr, follow))
 #ifndef AUTOPICKUP_EXCEPTIONS
-		if (!*otypes || index(otypes, curr->oclass)) {
+               if (!*otypes || index(otypes, curr->oclass) || (iflags.pickup_thrown && curr->was_thrown)) {
 #else
-	    if ((!*otypes || index(otypes, curr->oclass) ||
-		 is_autopickup_exception(curr, TRUE)) &&
-	    	 !is_autopickup_exception(curr, FALSE)) {
+		 if (((!*otypes || index(otypes, curr->oclass) ||
+		       is_autopickup_exception(curr, TRUE)) &&
+		      !is_autopickup_exception(curr, FALSE)) || (iflags.pickup_thrown && curr->was_thrown)) {
 #endif
 		    pi[n].item.a_obj = curr;
 		    pi[n].count = curr->quan;
@@ -680,6 +684,7 @@ menu_item **pick_list;	/* list of object
  *	USE_INVLET	  - Use object's invlet.
  *	INVORDER_SORT	  - Use hero's pack order.
  *	SIGNAL_NOMENU	  - Return -1 rather than 0 if nothing passes "allow".
+ *	SIGNAL_ESCAPE	  - Return -2 if menu was escaped.
  */
 int
 query_objlist(qstr, olist, qflags, pick_list, how, allow)
@@ -690,9 +695,15 @@ menu_item **pick_list;		/* return list o
 int how;			/* type of query */
 boolean FDECL((*allow), (OBJ_P));/* allow function */
 {
+#ifdef SORTLOOT
+	int i, j;
+#endif
 	int n;
 	winid win;
 	struct obj *curr, *last;
+#ifdef SORTLOOT
+	struct obj **oarray;
+#endif
 	char *pack;
 	anything any;
 	boolean printed_type_name;
@@ -717,6 +728,33 @@ boolean FDECL((*allow), (OBJ_P));/* allo
 	    return 1;
 	}
 
+#ifdef SORTLOOT
+	/* Make a temporary array to store the objects sorted */
+	oarray = (struct obj **)alloc(n*sizeof(struct obj*));
+
+	/* Add objects to the array */
+	i = 0;
+	for (curr = olist; curr; curr = FOLLOW(curr, qflags)) {
+	  if ((*allow)(curr)) {
+	    if (iflags.sortloot == 'f' ||
+		(iflags.sortloot == 'l' && !(qflags & USE_INVLET)))
+	      {
+		/* Insert object at correct index */
+		for (j = i; j; j--)
+		  {
+		    if (sortloot_cmp(curr, oarray[j-1])>0) break;
+		    oarray[j] = oarray[j-1];
+		  }
+		oarray[j] = curr;
+		i++;
+	      } else {
+		/* Just add it to the array */
+		oarray[i++] = curr;
+	      }
+	  }
+	}
+#endif /* SORTLOOT */
+
 	win = create_nhwindow(NHW_MENU);
 	start_menu(win);
 	any.a_obj = (struct obj *) 0;
@@ -730,7 +768,12 @@ boolean FDECL((*allow), (OBJ_P));/* allo
 	pack = flags.inv_order;
 	do {
 	    printed_type_name = FALSE;
+#ifdef SORTLOOT
+	    for (i = 0; i < n; i++) {
+		curr = oarray[i];
+#else /* SORTLOOT */
 	    for (curr = olist; curr; curr = FOLLOW(curr, qflags)) {
+#endif /* SORTLOOT */
 		if ((qflags & FEEL_COCKATRICE) && curr->otyp == CORPSE &&
 		     will_feel_cockatrice(curr, FALSE)) {
 			destroy_nhwindow(win);	/* stop the menu and revert */
@@ -744,7 +787,7 @@ boolean FDECL((*allow), (OBJ_P));/* allo
 		    if (qflags & INVORDER_SORT && !printed_type_name) {
 			any.a_obj = (struct obj *) 0;
 			add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
-					let_to_name(*pack, FALSE), MENU_UNSELECTED);
+				 let_to_name(*pack, FALSE, iflags.show_obj_sym), MENU_UNSELECTED);
 			printed_type_name = TRUE;
 		    }
 
@@ -752,12 +795,15 @@ boolean FDECL((*allow), (OBJ_P));/* allo
 		    add_menu(win, obj_to_glyph(curr), &any,
 			    qflags & USE_INVLET ? curr->invlet : 0,
 			    def_oc_syms[(int)objects[curr->otyp].oc_class],
-			    ATR_NONE, doname(curr), MENU_UNSELECTED);
+			    ATR_NONE, doname_with_price(curr), MENU_UNSELECTED);
 		}
 	    }
 	    pack++;
 	} while (qflags & INVORDER_SORT && *pack);
 
+#ifdef SORTLOOT
+	free(oarray);
+#endif
 	end_menu(win, qstr);
 	n = select_menu(win, how, pick_list);
 	destroy_nhwindow(win);
@@ -771,7 +817,7 @@ boolean FDECL((*allow), (OBJ_P));/* allo
 		if (mi->count == -1L || mi->count > mi->item.a_obj->quan)
 		    mi->count = mi->item.a_obj->quan;
 	} else if (n < 0) {
-	    n = 0;	/* caller's don't expect -1 */
+	    n = (qflags & SIGNAL_ESCAPE) ? -2 : 0;
 	}
 	return n;
 }
@@ -868,7 +914,7 @@ int how;			/* type of query */
 			any.a_int = curr->oclass;
 			add_menu(win, NO_GLYPH, &any, invlet++,
 				def_oc_syms[(int)objects[curr->otyp].oc_class],
-				ATR_NONE, let_to_name(*pack, FALSE),
+				 ATR_NONE, let_to_name(*pack, FALSE, iflags.show_obj_sym),
 				MENU_UNSELECTED);
 			collected_type_name = TRUE;
 		   }
@@ -1282,12 +1328,11 @@ boolean telekinesis;	/* not picking it u
 		    gold_capacity == 1L ? "one" : "some", obj->quan, where);
 		pline("%s %ld gold piece%s.",
 		    nearloadmsg, gold_capacity, plur(gold_capacity));
+		costly_gold(obj->ox, obj->oy, gold_capacity);
 		u.ugold += gold_capacity;
 		obj->quan -= gold_capacity;
-		costly_gold(obj->ox, obj->oy, gold_capacity);
 	    } else {
-		u.ugold += count;
-		if ((nearload = near_capacity()) != 0)
+		if ((nearload = calc_capacity(GOLD_WT(count))) != 0)
 		    pline("%s %ld gold piece%s.",
 			  nearload < MOD_ENCUMBER ?
 			  moderateloadmsg : nearloadmsg,
@@ -1295,13 +1340,14 @@ boolean telekinesis;	/* not picking it u
 		else
 		    prinv((char *) 0, obj, count);
 		costly_gold(obj->ox, obj->oy, count);
+		u.ugold += count;
 		if (count == obj->quan)
 		    delobj(obj);
 		else
 		    obj->quan -= count;
 	    }
 	    flags.botl = 1;
-	    if (flags.run) nomul(0);
+	    if (flags.run) nomul(0, NULL);
 	    return 1;
 #endif
 	} else if (obj->otyp == CORPSE) {
@@ -1352,6 +1398,7 @@ boolean telekinesis;	/* not picking it u
 	    obj = splitobj(obj, count);
 
 	obj = pick_obj(obj);
+	obj->was_thrown = 0;
 
 	if (uwep && uwep == obj) mrg_to_wielded = TRUE;
 	nearload = near_capacity();
@@ -1503,6 +1550,33 @@ int x, y;
 }
 
 int
+do_loot_cont(cobj, noit)
+struct obj *cobj;
+boolean noit;
+{
+    if (!cobj) return 0;
+
+    if (cobj->olocked) {
+	pline("Hmmm, %s seems to be locked.", noit ? the(xname(cobj)) : "it");
+	return 0;
+    }
+    if (cobj->otyp == BAG_OF_TRICKS) {
+	int tmp;
+	You("carefully open the bag...");
+	pline("It develops a huge set of teeth and bites you!");
+	tmp = rnd(10);
+	if (Half_physical_damage) tmp = (tmp+1) / 2;
+	losehp(tmp, "carnivorous bag", KILLED_BY_AN);
+	makeknown(BAG_OF_TRICKS);
+	return 1;
+    }
+
+    You("carefully open %s...", the(xname(cobj)));
+    return use_container(cobj, 0);
+}
+
+
+int
 doloot()	/* loot a container on the floor or loot saddle from mon. */
 {
     register struct obj *cobj, *nobj;
@@ -1515,6 +1589,7 @@ doloot()	/* loot a container on the floo
     char qbuf[BUFSZ];
     int prev_inquiry = 0;
     boolean prev_loot = FALSE;
+    int num_cont = 0;
 
     if (check_capacity((char *)0)) {
 	/* "Can't do that while carrying so much stuff." */
@@ -1532,6 +1607,50 @@ lootcont:
 	boolean any = FALSE;
 
 	if (!able_to_loot(cc.x, cc.y)) return 0;
+
+	for (cobj = level.objects[cc.x][cc.y]; cobj; cobj = cobj->nexthere) {
+	    if (Is_container(cobj)) num_cont++;
+	}
+
+	if (num_cont > 1) {
+	    /* use a menu to loot many containers */
+	    int n, i;
+
+	    winid win;
+	    anything any;
+	    menu_item *pick_list;
+
+	    timepassed = 0;
+
+	    any.a_void = 0;
+	    win = create_nhwindow(NHW_MENU);
+	    start_menu(win);
+
+	    for (cobj = level.objects[cc.x][cc.y]; cobj; cobj = cobj->nexthere) {
+		if (Is_container(cobj)) {
+		    any.a_obj = cobj;
+		    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, doname(cobj),
+			     MENU_UNSELECTED);
+		}
+	    }
+	    end_menu(win, "Loot which containers?");
+	    n = select_menu(win, PICK_ANY, &pick_list);
+	    destroy_nhwindow(win);
+
+	    if (n > 0) {
+		for (i = 0; i < n; i++) {
+		    timepassed |= do_loot_cont(pick_list[i].item.a_obj, TRUE);
+		    if (multi < 0) {/* chest trap, stop looting */
+			free((genericptr_t) pick_list);
+			return 1;
+		    }
+		}
+	    }
+	    if (pick_list)
+		free((genericptr_t) pick_list);
+	    if (n != 0) c = 'y';
+	} else {
+
 	for (cobj = level.objects[cc.x][cc.y]; cobj; cobj = nobj) {
 	    nobj = cobj->nexthere;
 
@@ -1545,28 +1664,12 @@ lootcont:
 		if (c == 'n') continue;
 		any = TRUE;
 
-		if (cobj->olocked) {
-		    pline("Hmmm, it seems to be locked.");
-		    continue;
-		}
-		if (cobj->otyp == BAG_OF_TRICKS) {
-		    int tmp;
-		    You("carefully open the bag...");
-		    pline("It develops a huge set of teeth and bites you!");
-		    tmp = rnd(10);
-		    if (Half_physical_damage) tmp = (tmp+1) / 2;
-		    losehp(tmp, "carnivorous bag", KILLED_BY_AN);
-		    makeknown(BAG_OF_TRICKS);
-		    timepassed = 1;
-		    continue;
-		}
-
-		You("carefully open %s...", the(xname(cobj)));
-		timepassed |= use_container(cobj, 0);
+		timepassed |= do_loot_cont(cobj, FALSE);
 		if (multi < 0) return 1;		/* chest trap */
 	    }
 	}
 	if (any) c = 'y';
+	}
     } else if (Confusion) {
 #ifndef GOLDOBJ
 	if (u.ugold){
@@ -2101,7 +2204,7 @@ register int held;
 	    (void) chest_trap(obj, HAND, FALSE);
 	    /* even if the trap fails, you've used up this turn */
 	    if (multi >= 0) {	/* in case we didn't become paralyzed */
-		nomul(-1);
+		nomul(-1, "opening a container");
 		nomovemsg = "";
 	    }
 	    return 1;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/pline.c nethack-3.4.3-nao-osx/src/pline.c
--- nethack-3.4.3/src/pline.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/pline.c	2014-12-20 12:08:36.000000000 -0800
@@ -15,6 +15,79 @@ static boolean no_repeat = FALSE;
 
 static char *FDECL(You_buf, (int));
 
+#if defined(DUMP_LOG) && defined(DUMPMSGS)
+char msgs[DUMPMSGS][BUFSZ];
+int lastmsg = -1;
+#endif
+
+
+void
+msgpline_add(typ, pattern)
+     int typ;
+     char *pattern;
+{
+    int errnum;
+    char errbuf[80];
+    const char *err = (char *)0;
+    struct _plinemsg *tmp = (struct _plinemsg *) alloc(sizeof(struct _plinemsg));
+    if (!tmp) return;
+    tmp->msgtype = typ;
+    tmp->is_regexp = iflags.msgtype_regex;
+    if (tmp->is_regexp) {
+	errnum = regcomp(&tmp->match, pattern, REG_EXTENDED | REG_NOSUB);
+	if (errnum != 0) {
+	    regerror(errnum, &tmp->match, errbuf, sizeof(errbuf));
+	    err = errbuf;
+	}
+	if (err) {
+	    raw_printf("\nMSGTYPE regex error: %s\n", err);
+	    wait_synch();
+	    free(tmp);
+	    return;
+	}
+    } else {
+	tmp->pattern = strdup(pattern);
+    }
+    tmp->next = pline_msg;
+    pline_msg = tmp;
+}
+
+void
+msgpline_free()
+{
+    struct _plinemsg *tmp = pline_msg;
+    struct _plinemsg *tmp2;
+    while (tmp) {
+	if (tmp->is_regexp) {
+	    (void) regfree(&tmp->match);
+	} else {
+	    free(tmp->pattern);
+	}
+	tmp2 = tmp;
+	tmp = tmp->next;
+	free(tmp2);
+    }
+    pline_msg = NULL;
+}
+
+int
+msgpline_type(msg)
+     char *msg;
+{
+    struct _plinemsg *tmp = pline_msg;
+    while (tmp) {
+	if (tmp->is_regexp) {
+	    if (regexec(&tmp->match, msg, 0, NULL, 0) == 0) return tmp->msgtype;
+	} else {
+	    if (pmatch(tmp->pattern, msg)) return tmp->msgtype;
+	}
+	tmp = tmp->next;
+    }
+    return MSGTYP_NORMAL;
+}
+
+
+
 /*VARARGS1*/
 /* Note that these declarations rely on knowledge of the internals
  * of the variable argument handling stuff in "tradstdc.h"
@@ -31,6 +104,8 @@ pline VA_DECL(const char *, line)
 	VA_END();
 }
 
+char prevmsg[BUFSZ];
+
 # ifdef USE_STDARG
 static void
 vpline(const char *line, va_list the_args) {
@@ -48,6 +123,7 @@ pline VA_DECL(const char *, line)
 #endif	/* USE_STDARG | USE_VARARG */
 
 	char pbuf[BUFSZ];
+	int typ;
 /* Do NOT use VA_START and VA_END in here... see above */
 
 	if (!line || !*line) return;
@@ -55,6 +131,13 @@ pline VA_DECL(const char *, line)
 	    Vsprintf(pbuf,line,VA_ARGS);
 	    line = pbuf;
 	}
+#if defined(DUMP_LOG) && defined(DUMPMSGS)
+	if (DUMPMSGS > 0 && !program_state.gameover) {
+	  lastmsg = (lastmsg + 1) % DUMPMSGS;
+	  strncpy(msgs[lastmsg], line, BUFSZ);
+	}
+#endif
+	typ = msgpline_type(line);
 	if (!iflags.window_inited) {
 	    raw_print(line);
 	    return;
@@ -65,7 +148,11 @@ pline VA_DECL(const char *, line)
 #endif /* MAC */
 	if (vision_full_recalc) vision_recalc(0);
 	if (u.ux) flush_screen(1);		/* %% */
+	if (typ == MSGTYP_NOSHOW) return;
+	if (typ == MSGTYP_NOREP && !strcmp(line, prevmsg)) return;
 	putstr(WIN_MESSAGE, 0, line);
+	strncpy(prevmsg, line, BUFSZ);
+	if (typ == MSGTYP_STOP) display_nhwindow(WIN_MESSAGE, TRUE); /* --more-- */
 }
 
 /*VARARGS1*/
@@ -246,18 +333,17 @@ raw_printf VA_DECL(const char *, line)
 /*VARARGS1*/
 void
 impossible VA_DECL(const char *, s)
+	char pbuf[2*BUFSZ];
 	VA_START(s);
 	VA_INIT(s, const char *);
 	if (program_state.in_impossible)
 		panic("impossible called impossible");
 	program_state.in_impossible = 1;
-	{
-	    char pbuf[BUFSZ];
-	    Vsprintf(pbuf,s,VA_ARGS);
-	    paniclog("impossible", pbuf);
-	}
-	vpline(s,VA_ARGS);
-	pline("Program in disorder - perhaps you'd better #quit.");
+	Vsprintf(pbuf,s,VA_ARGS);
+	pbuf[BUFSZ-1] = '\0';
+	paniclog("impossible", pbuf);
+	pline("%s", pbuf);
+	pline("Program in disorder - you should probably S)ave and reload the game.");
 	program_state.in_impossible = 0;
 	VA_END();
 }
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/polyself.c nethack-3.4.3-nao-osx/src/polyself.c
--- nethack-3.4.3/src/polyself.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/polyself.c	2014-12-20 12:08:36.000000000 -0800
@@ -729,7 +729,7 @@ rehumanize()
 	    done(DIED);
 	}
 	if (!uarmg) selftouch("No longer petrify-resistant, you");
-	nomul(0);
+	nomul(0, NULL);
 
 	flags.botl = 1;
 	vision_full_recalc = 1;
@@ -1019,7 +1019,7 @@ dogaze()
 			    nomul((u.ulevel > 6 || rn2(4)) ?
 				    -d((int)mtmp->m_lev+1,
 					    (int)mtmp->data->mattk[0].damd)
-				    : -200);
+				    : -200, "frozen by a monster's gaze");
 			    return 1;
 			} else
 			    You("stiffen momentarily under %s gaze.",
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/potion.c nethack-3.4.3-nao-osx/src/potion.c
--- nethack-3.4.3/src/potion.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/potion.c	2014-12-20 12:08:36.000000000 -0800
@@ -316,7 +316,7 @@ ghost_from_bottle()
 		Hallucination ? rndmonnam() : (const char *)"ghost");
 	if(flags.verbose)
 	    You("are frightened to death, and unable to move.");
-	nomul(-3);
+	nomul(-3, "being frightened to death");
 	nomovemsg = "You regain your composure.";
 }
 
@@ -603,7 +603,7 @@ peffects(otmp)
 		    else
 			Your("%s are frozen to the %s!",
 			     makeplural(body_part(FOOT)), surface(u.ux, u.uy));
-		    nomul(-(rn1(10, 25 - 12*bcsign(otmp))));
+		    nomul(-(rn1(10, 25 - 12*bcsign(otmp))), "frozen by a potion");
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		}
@@ -1255,7 +1255,7 @@ register struct obj *obj;
 		kn++;
 		if (!Free_action) {
 		    pline("%s seems to be holding you.", Something);
-		    nomul(-rnd(5));
+		    nomul(-rnd(5), "frozen by a potion");
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		} else You("stiffen momentarily.");
@@ -1264,7 +1264,7 @@ register struct obj *obj;
 		kn++;
 		if (!Free_action && !Sleep_resistance) {
 		    You_feel("rather tired.");
-		    nomul(-rnd(5));
+		    nomul(-rnd(5), "sleeping off a magical draught");
 		    nomovemsg = You_can_move_again;
 		    exercise(A_DEX, FALSE);
 		} else You("yawn.");
@@ -1530,7 +1530,7 @@ dodip()
 	uchar here;
 	char allowall[2];
 	short mixture;
-	char qbuf[QBUFSZ], Your_buf[BUFSZ];
+	char qbuf[BUFSZ+QBUFSZ], Your_buf[BUFSZ];
 
 	allowall[0] = ALL_CLASSES; allowall[1] = '\0';
 	if(!(obj = getobj(allowall, "dip")))
@@ -1539,13 +1539,22 @@ dodip()
 	here = levl[u.ux][u.uy].typ;
 	/* Is there a fountain to dip into here? */
 	if (IS_FOUNTAIN(here)) {
+#ifdef PARANOID
+		Sprintf(qbuf, "Dip %s into the fountain?", the(xname(obj)));
+		if(yn(qbuf) == 'y') {
+#else
 		if(yn("Dip it into the fountain?") == 'y') {
+#endif
 			dipfountain(obj);
 			return(1);
 		}
 	} else if (is_pool(u.ux,u.uy)) {
 		tmp = waterbody_name(u.ux,u.uy);
+#ifdef PARANOID
+		Sprintf(qbuf, "Dip %s into the %s?", the(xname(obj)), tmp);
+#else
 		Sprintf(qbuf, "Dip it into the %s?", tmp);
+#endif
 		if (yn(qbuf) == 'y') {
 		    if (Levitation) {
 			floating_above(tmp);
@@ -1562,7 +1571,12 @@ dodip()
 		}
 	}
 
+#ifdef PARANOID
+	Sprintf(qbuf, "dip %s into", the(xname(obj)));
+	if(!(potion = getobj(beverages, qbuf)))
+#else
 	if(!(potion = getobj(beverages, "dip into")))
+#endif
 		return(0);
 	if (potion == obj && potion->quan == 1L) {
 		pline("That is a potion bottle, not a Klein bottle!");
@@ -1783,6 +1797,7 @@ dodip()
 			    obj->oeroded == MAX_ERODE ? "destroys" : "damages",
 			    yname(obj));
 		    if (obj->oeroded == MAX_ERODE) {
+			setnotworn(obj);
 			obj_extract_self(obj);
 			obfree(obj, (struct obj *)0);
 			obj = (struct obj *) 0;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/pray.c nethack-3.4.3-nao-osx/src/pray.c
--- nethack-3.4.3/src/pray.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/pray.c	2014-12-20 12:08:36.000000000 -0800
@@ -1206,7 +1206,7 @@ dosacrifice()
 		    if (sgn(u.ualign.type) == sgn(dmon->data->maligntyp))
 			dmon->mpeaceful = TRUE;
 		    You("are terrified, and unable to move.");
-		    nomul(-3);
+		    nomul(-3, "being terrified of a demon");
 		} else pline_The("%s.", demonless_msg);
 	    }
 
@@ -1287,6 +1287,11 @@ dosacrifice()
 		done(ESCAPED);
 	    } else { /* super big win */
 		adjalign(10);
+
+#ifdef RECORD_ACHIEVE
+                achieve.ascended = 1;
+#endif
+
 pline("An invisible choir sings, and you are bathed in radiance...");
 		godvoice(altaralign, "Congratulations, mortal!");
 		display_nhwindow(WIN_MESSAGE, FALSE);
@@ -1579,7 +1584,7 @@ dopray()
 	}
     }
 #endif
-    nomul(-3);
+    nomul(-3, "praying");
     nomovemsg = "You finish your prayer.";
     afternmv = prayer_done;
 
@@ -1739,7 +1744,7 @@ doturn()
 		    }
 	    }
 	}
-	nomul(-5);
+	nomul(-5, "trying to turn the monsters");
 	return(1);
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/priest.c nethack-3.4.3-nao-osx/src/priest.c
--- nethack-3.4.3/src/priest.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/priest.c	2014-12-20 12:08:36.000000000 -0800
@@ -393,7 +393,7 @@ register int roomno;
 		    set_malign(mtmp);
 		    if(flags.verbose)
 			You("are frightened to death, and unable to move.");
-		    nomul(-3);
+		    nomul(-3, "being frightened to death");
 		    nomovemsg = "You regain your composure.";
 	       }
 	   }
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/read.c nethack-3.4.3-nao-osx/src/read.c
--- nethack-3.4.3/src/read.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/read.c	2014-12-20 12:08:36.000000000 -0800
@@ -73,6 +73,90 @@ doread()
     "Don't Panic",				/* HHGTTG */
     "Furinkan High School Athletic Dept.",	/* Ranma 1/2 */
     "Hel-LOOO, Nurse!",			/* Animaniacs */
+    "=^.^=",
+    "100% goblin hair - do not wash",
+    "Aberzombie and Fitch",
+    "Aim >>> <<< here",
+    "cK -- Cockatrice touches the Kop",
+    "Croesus for President 2008 - Campaign Finance Reform Now (for the other guy)",
+    "- - - - - - CUT HERE - - - - - -",
+    "Don't ask me, I only adventure here",
+    "Down With Pants!",
+    "d, your dog or a killer?",
+    "FREE PUG AND NEWT!",
+    "Gehennoms Angels",
+    "Glutton For Punishment",
+    "Go Team Ant!",
+    "Got Newt?",
+    "Heading for Godhead",
+    "Hello, my darlings!", /* Charlie Drake */
+    "Hey! Nymphs! Steal This T-Shirt!",
+    "I <3 Dungeon of Doom",
+    "I <3 Maud",
+    "I am a Valkyrie. If you see me running, try to keep up.",
+    "I Am Not a Pack Rat - I Am a Collector",
+    "I bounced off a rubber tree",
+    "If you can read this, I can hit you with my polearm",
+    "I'm Confused!",
+    "I met Carl, the swordmaster of Jambalaya island and all I got was this lousy t-shirt",
+    "I'm in ur base, killin ur doods",
+    "I scored with the princess",
+    "I Support Single Succubi",
+    "I want to live forever or die in the attempt.",
+    "I'll stick it in you!",
+    "Kop Killaz",
+    "Lichen Park",
+    "LOST IN THOUGHT - please send search party",
+    "Meat Is Mordor",
+    "Minetown Better Business Bureau",
+    "Minetown Watch",
+    "Ms. Palm's House of Negotiable Affection -- A Very Reputable House Of Disrepute",
+    "^^  My eyes are up there!  ^^",
+    "Neferet/Pelias '08",
+    "Next time you wave at me, use more than one finger, please.",
+    "No Outfit Is Complete Without a Little Cat Fur",
+    "Objects In This Shirt Are Closer Than They Appear",
+    "Protection Racketeer",
+    "P Happens",
+    "Real men love Crom",
+    "Rodney in '08. OR ELSE!",
+    "Sokoban Gym -- Get Strong or Die Trying",
+    "Somebody stole my Mojo!",
+    "The Hellhound Gang",
+    "The Werewolves",
+    "They Might Be Storm Giants",
+    "Up with miniskirts!",
+    "Weapons don't kill people, I kill people",
+    "Where's the beef?",
+    "White Zombie",
+    "Worship me",
+    "You laugh because I'm different, I laugh because you're about to die",
+    "You're killing me!",
+    "You should hear what the voices in my head are saying about you.",
+    "Anhur State University - Home of the Fighting Fire Ants!",
+    "FREE HUGS",
+    "Serial Ascender",
+    "Plunder Island Brimstone Beach Club",
+    "Real Men Are Valkyries",
+    "Young Men's Cavedigging Association",
+    "Occupy Fort Ludios",
+    "I couldn't afford this T-shirt so I stole it!",
+    "End Mercantile Opacity Discrimination Now: Let Invisible Customers Shop!",
+    "Elvira's House O'Succubi, granting the gift of immorality!",
+    "Mind Flayers Suck",
+    "I'm not wearing any pants",
+    "Newt Fodder",
+    "My Dog ate Og",
+    "End Lich Prejudice Now!",
+    "Down With The Living!",
+    "Pudding Farmer",
+    "Dudley",
+    "I pray to Our Lady of Perpetual Mood Swings",
+    "Soooo, When's the Wizard Getting Back to You About That Brain?",
+    "Vegetarian",
+    "I plan to go to Astral",
+    "If They Don't Have Fruit Juice in Heaven, I Ain't Going",
+    "Living Dead",
 	    };
 	    char buf[BUFSZ];
 	    int erosion;
@@ -111,6 +195,7 @@ doread()
 
 	/* Actions required to win the game aren't counted towards conduct */
 	if (scroll->otyp != SPE_BOOK_OF_THE_DEAD &&
+	    scroll->otyp != SCR_MAIL &&
 		scroll->otyp != SPE_BLANK_PAPER &&
 		scroll->otyp != SCR_BLANK_PAPER)
 	    u.uconduct.literate++;
@@ -804,7 +889,19 @@ register struct obj	*sobj;
 			known = TRUE;
 		} else {	/* armor and scroll both cursed */
 		    Your("%s %s.", xname(otmp), otense(otmp, "vibrate"));
-		    if (otmp->spe >= -6) otmp->spe--;
+		    if (otmp->spe >= -6) {
+			otmp->spe--;
+			if (otmp->otyp == HELM_OF_BRILLIANCE) {
+			    ABON(A_INT)--;
+			    ABON(A_WIS)--;
+			    makeknown(otmp->otyp);
+			    flags.botl = 1;
+			} else if (otmp->otyp == GAUNTLETS_OF_DEXTERITY) {
+			    ABON(A_DEX)--;
+			    makeknown(otmp->otyp);
+			    flags.botl = 1;
+			}
+		    }
 		    make_stunned(HStun + rn1(10, 10), TRUE);
 		}
 	    }
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/restore.c nethack-3.4.3-nao-osx/src/restore.c
--- nethack-3.4.3/src/restore.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/restore.c	2014-12-20 12:08:36.000000000 -0800
@@ -376,6 +376,8 @@ unsigned int *stuckid, *steedid;	/* STEE
 
 	mread(fd, (genericptr_t) &flags, sizeof(struct flag));
 	flags.bypasses = 0;	/* never use the saved value of bypasses */
+	has_loaded_bones = flags.end_around;
+	flags.end_around = 2;
 	if (remember_discover) discover = remember_discover;
 
 	role_init();	/* Reset the initial role, race, gender, and alignment */
@@ -407,20 +409,6 @@ unsigned int *stuckid, *steedid;	/* STEE
 	migrating_mons = restmonchn(fd, FALSE);
 	mread(fd, (genericptr_t) mvitals, sizeof(mvitals));
 
-	/* this comes after inventory has been loaded */
-	for(otmp = invent; otmp; otmp = otmp->nobj)
-		if(otmp->owornmask)
-			setworn(otmp, otmp->owornmask);
-	/* reset weapon so that player will get a reminder about "bashing"
-	   during next fight when bare-handed or wielding an unconventional
-	   item; for pick-axe, we aren't able to distinguish between having
-	   applied or wielded it, so be conservative and assume the former */
-	otmp = uwep;	/* `uwep' usually init'd by setworn() in loop above */
-	uwep = 0;	/* clear it and have setuwep() reinit */
-	setuwep(otmp);	/* (don't need any null check here) */
-	if (!uwep || uwep->otyp == PICK_AXE || uwep->otyp == GRAPPLING_HOOK)
-	    unweapon = TRUE;
-
 	restore_dungeon(fd);
 	restlevchn(fd);
 	mread(fd, (genericptr_t) &moves, sizeof moves);
@@ -445,9 +433,21 @@ unsigned int *stuckid, *steedid;	/* STEE
 
 	restnames(fd);
 	restore_waterlevel(fd);
+
+#ifdef RECORD_ACHIEVE
+        mread(fd, (genericptr_t) &achieve, sizeof achieve);
+#endif
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+        mread(fd, (genericptr_t) &realtime_data.realtime, 
+                  sizeof realtime_data.realtime);
+#endif
+
 	/* must come after all mons & objs are restored */
 	relink_timers(FALSE);
 	relink_light_sources(FALSE);
+#ifdef WHEREIS_FILE
+        touch_whereis();
+#endif
 	return(TRUE);
 }
 
@@ -651,6 +651,22 @@ register int fd;
 	gameDiskPrompt();
 #endif
 	max_rank_sz(); /* to recompute mrank_sz (botl.c) */
+
+	/* this comes after inventory has been loaded */
+	for(otmp = invent; otmp; otmp = otmp->nobj)
+		if(otmp->owornmask)
+			setworn(otmp, otmp->owornmask);
+
+	/* reset weapon so that player will get a reminder about "bashing"
+	   during next fight when bare-handed or wielding an unconventional
+	   item; for pick-axe, we aren't able to distinguish between having
+	   applied or wielded it, so be conservative and assume the former */
+	otmp = uwep;	/* `uwep' usually init'd by setworn() in loop above */
+	uwep = 0;	/* clear it and have setuwep() reinit */
+	setuwep(otmp);	/* (don't need any null check here) */
+	if (!uwep || uwep->otyp == PICK_AXE || uwep->otyp == GRAPPLING_HOOK)
+	    unweapon = TRUE;
+
 	/* take care of iron ball & chain */
 	for(otmp = fobj; otmp; otmp = otmp->nobj)
 		if(otmp->owornmask)
@@ -676,6 +692,17 @@ register int fd;
 	clear_nhwindow(WIN_MESSAGE);
 	program_state.something_worth_saving++;	/* useful data now exists */
 
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+
+/* Start the timer here (realtime has already been set) */
+#if defined(BSD) && !defined(POSIX_TYPES)
+        (void) time((long *)&realtime_data.restoretime);
+#else
+        (void) time(&realtime_data.restoretime);
+#endif
+
+#endif /* RECORD_REALTIME || REALTIME_ON_BOTL */
+
 	/* Success! */
 	welcome(FALSE);
 	return(1);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/rip.c nethack-3.4.3-nao-osx/src/rip.c
--- nethack-3.4.3/src/rip.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/rip.c	2014-12-20 12:08:36.000000000 -0800
@@ -8,7 +8,7 @@ STATIC_DCL void FDECL(center, (int, char
 
 extern const char * const killed_by_prefix[];	/* from topten.c */
 
-#if defined(TTY_GRAPHICS) || defined(X11_GRAPHICS) || defined(GEM_GRAPHICS) || defined(MSWIN_GRAPHICS)
+#if defined(TTY_GRAPHICS) || defined(X11_GRAPHICS) || defined(GEM_GRAPHICS) || defined(MSWIN_GRAPHICS) || defined(CURSES_GRAPHICS)
 # define TEXT_TOMBSTONE
 #endif
 #if defined(mac) || defined(__BEOS__) || defined(WIN32_GRAPHICS)
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/rnd.c nethack-3.4.3-nao-osx/src/rnd.c
--- nethack-3.4.3/src/rnd.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/rnd.c	2014-12-20 12:08:36.000000000 -0800
@@ -18,10 +18,31 @@ extern int NDECL(rand);
 
 #ifdef OVL0
 
+static int reseed_period = 0;
+static int reseed_count = 0;
+
+void
+check_reseed()
+{
+    reseed_count++;
+    if (reseed_count > reseed_period) {
+	FILE *fptr = NULL;
+	int rnd[2];
+
+	fptr = fopen("/dev/urandom","r");
+	if (fptr) fread((void *)rnd, sizeof(int),2,fptr);
+	fclose(fptr);
+	srandom((int) (time((time_t *)0)) + rnd[0]);
+	reseed_period = (rnd[1] % 700) + 10;
+	reseed_count = 0;
+    }
+}
+
 int
 rn2(x)		/* 0 <= rn2(x) < x */
 register int x;
 {
+    check_reseed();
 #ifdef DEBUG
 	if (x <= 0) {
 		impossible("rn2(%d) attempted", x);
@@ -42,7 +63,7 @@ rnl(x)		/* 0 <= rnl(x) < x; sometimes su
 register int x;	/* good luck approaches 0, bad luck approaches (x-1) */
 {
 	register int i;
-
+    check_reseed();
 #ifdef DEBUG
 	if (x <= 0) {
 		impossible("rnl(%d) attempted", x);
@@ -67,6 +88,7 @@ int
 rnd(x)		/* 1 <= rnd(x) <= x */
 register int x;
 {
+    check_reseed();
 #ifdef DEBUG
 	if (x <= 0) {
 		impossible("rnd(%d) attempted", x);
@@ -87,6 +109,7 @@ d(n,x)		/* n <= d(n,x) <= (n*x) */
 register int n, x;
 {
 	register int tmp = n;
+    check_reseed();
 
 #ifdef DEBUG
 	if (x < 0 || n < 0 || (x == 0 && n != 0)) {
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/save.c nethack-3.4.3-nao-osx/src/save.c
--- nethack-3.4.3/src/save.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/save.c	2014-12-20 12:08:36.000000000 -0800
@@ -48,6 +48,16 @@ static long nulls[10];
 #define HUP
 #endif
 
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+extern const struct percent_color_option *hp_colors;
+extern const struct percent_color_option *pw_colors;
+extern const struct text_color_option *text_colors;
+#endif
+
 /* need to preserve these during save to avoid accessing freed memory */
 static unsigned ustuck_id = 0, usteed_id = 0;
 
@@ -57,7 +67,7 @@ dosave()
 	clear_nhwindow(WIN_MESSAGE);
 	if(yn("Really save?") == 'n') {
 		clear_nhwindow(WIN_MESSAGE);
-		if(multi > 0) nomul(0);
+		if(multi > 0) nomul(0, NULL);
 	} else {
 		clear_nhwindow(WIN_MESSAGE);
 		pline("Saving...");
@@ -91,8 +101,14 @@ int sig_unused;
 #  endif
 # else	/* SAVEONHANGUP */
 	if (!program_state.done_hup++) {
-	    if (program_state.something_worth_saving)
+	    if (program_state.something_worth_saving) {
+		/* AIS: Record levels on which there were hangups */
+		if (ledger_no(&u.uz) >= 0 &&
+		    ledger_no(&u.uz) < MAXLINFO)
+		    level_info[ledger_no(&u.uz)].flags |= HANGUP_HERE;
+		write_HUP_file();
 		(void) dosave0();
+	    }
 #  ifdef VMS
 	    /* don't call exit when already within an exit handler;
 	       that would cancel any other pending user-mode handlers */
@@ -156,6 +172,10 @@ dosave0()
 		return(0);
 	}
 
+#ifdef WHEREIS_FILE
+	touch_whereis();
+#endif
+
 	vision_recalc(2);	/* shut down vision to prevent problems
 				   in the event of an impossible() call */
 	
@@ -265,6 +285,9 @@ dosave0()
 	/* get rid of current level --jgm */
 	delete_levelfile(ledger_no(&u.uz));
 	delete_levelfile(0);
+#ifdef WHEREIS_FILE
+        delete_whereis();
+#endif
 	compress(fq_save);
 	return(1);
 }
@@ -274,12 +297,17 @@ savegamestate(fd, mode)
 register int fd, mode;
 {
 	int uid;
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+        time_t realtime;
+#endif
+
 
 #ifdef MFLOPPY
 	count_only = (mode & COUNT_SAVE);
 #endif
 	uid = getuid();
 	bwrite(fd, (genericptr_t) &uid, sizeof uid);
+	flags.end_around = has_loaded_bones;
 	bwrite(fd, (genericptr_t) &flags, sizeof(struct flag));
 	bwrite(fd, (genericptr_t) &u, sizeof(struct you));
 
@@ -319,6 +347,15 @@ register int fd, mode;
 	savefruitchn(fd, mode);
 	savenames(fd, mode);
 	save_waterlevel(fd, mode);
+
+#ifdef RECORD_ACHIEVE
+        bwrite(fd, (genericptr_t) &achieve, sizeof achieve);
+#endif
+#if defined(RECORD_REALTIME) || defined(REALTIME_ON_BOTL)
+        realtime = get_realtime();
+        bwrite(fd, (genericptr_t) &realtime, sizeof realtime);
+#endif
+
 	bflush(fd);
 }
 
@@ -942,6 +979,37 @@ register int fd, mode;
 	    ffruit = 0;
 }
 
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+
+void
+free_percent_color_options(list_head)
+     const struct percent_color_option *list_head;
+{
+    if (list_head == NULL) return;
+    free_percent_color_options(list_head->next);
+    free((genericptr_t)list_head);
+}
+
+void
+free_text_color_options(list_head)
+     const struct text_color_option *list_head;
+{
+    if (list_head == NULL) return;
+    free_text_color_options(list_head->next);
+    free((genericptr_t)list_head->text);
+    free((genericptr_t)list_head);
+}
+
+void
+free_status_colors()
+{
+    free_percent_color_options(hp_colors); hp_colors = NULL;
+    free_percent_color_options(pw_colors); pw_colors = NULL;
+    free_text_color_options(text_colors); text_colors = NULL;
+}
+#endif
+
+
 /* also called by prscore(); this probably belongs in dungeon.c... */
 void
 free_dungeons()
@@ -953,12 +1021,38 @@ free_dungeons()
 	return;
 }
 
+#ifdef MENU_COLOR
+void
+free_menu_coloring()
+{
+    struct menucoloring *tmp = menu_colorings;
+
+    while (tmp) {
+	struct menucoloring *tmp2 = tmp->next;
+# ifdef MENU_COLOR_REGEX
+	(void) regfree(&tmp->match);
+# else
+	free(tmp->match);
+# endif
+	free(tmp);
+	tmp = tmp2;
+    }
+}
+#endif /* MENU_COLOR */
+
 void
 freedynamicdata()
 {
+#if defined(STATUS_COLORS) && defined(TEXTCOLOR)
+    free_status_colors();
+#endif
 	unload_qtlist();
 	free_invbuf();	/* let_to_name (invent.c) */
 	free_youbuf();	/* You_buf,&c (pline.c) */
+	msgpline_free();
+#ifdef MENU_COLOR
+	free_menu_coloring();
+#endif
 	tmp_at(DISP_FREEMEM, 0);	/* temporary display effects */
 #ifdef FREE_ALL_MEMORY
 # define freeobjchn(X)	(saveobjchn(0, X, FREE_SAVE),  X = 0)
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/shk.c nethack-3.4.3-nao-osx/src/shk.c
--- nethack-3.4.3/src/shk.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/shk.c	2014-12-20 12:08:36.000000000 -0800
@@ -833,6 +833,20 @@ register struct obj *obj, *merge;
 #endif
 		}
 	}
+
+	if (obj == uwep) uwepgone();
+	else if (obj == uswapwep) uswapwepgone();
+	else if (obj == uquiver) uqwepgone();
+	else if (obj == uarm) setnotworn(obj);
+	else if (obj == uarmc) setnotworn(obj);
+	else if (obj == uarmh) setnotworn(obj);
+	else if (obj == uarms) setnotworn(obj);
+	else if (obj == uarmg) setnotworn(obj);
+#ifdef TOURIST
+	else if (obj == uarmu) setnotworn(obj);
+#endif
+	else if (obj == uarmf) setnotworn(obj);
+
 	dealloc_obj(obj);
 }
 #endif /* OVLB */
@@ -1392,7 +1406,10 @@ proceed:
 	}
 	/* now check items on bill */
 	if (eshkp->billct) {
-	    register boolean itemize;
+	    boolean itemize = FALSE;
+	    /* get item selected by inventory menu */
+	    struct obj* payme_item = getnextgetobj();
+
 #ifndef GOLDOBJ
 	    if (!u.ugold && !eshkp->credit) {
 #else
@@ -1418,7 +1435,9 @@ proceed:
 
 	    /* this isn't quite right; it itemizes without asking if the
 	     * single item on the bill is partly used up and partly unpaid */
-	    itemize = (eshkp->billct > 1 ? yn("Itemized billing?") == 'y' : 1);
+	    if (!payme_item) {
+		    itemize = (eshkp->billct > 1 ? yn("Itemized billing?") == 'y' : 1);
+	    }
 
 	    for (pass = 0; pass <= 1; pass++) {
 		tmp = 0;
@@ -1444,25 +1463,29 @@ proceed:
 			 * are processed on both passes */
 			tmp++;
 		    } else {
-			switch (dopayobj(shkp, bp, &otmp, pass, itemize)) {
-			  case PAY_CANT:
-				return 1;	/*break*/
-			  case PAY_BROKE:
-				paid = TRUE;
-				goto thanks;	/*break*/
-			  case PAY_SKIP:
-				tmp++;
-				continue;	/*break*/
-			  case PAY_SOME:
-				paid = TRUE;
+			if (payme_item == NULL || payme_item == otmp) {
+				switch (dopayobj(shkp, bp, &otmp, pass, itemize)) {
+					case PAY_CANT:
+						return 1;	/*break*/
+					case PAY_BROKE:
+						paid = TRUE;
+						goto thanks;	/*break*/
+					case PAY_SKIP:
+						tmp++;
+						continue;	/*break*/
+					case PAY_SOME:
+						paid = TRUE;
+						if (itemize) bot();
+						continue;	/*break*/
+					case PAY_BUY:
+						paid = TRUE;
+						break;
+				}
 				if (itemize) bot();
-				continue;	/*break*/
-			  case PAY_BUY:
-				paid = TRUE;
-				break;
+				*bp = eshkp->bill_p[--eshkp->billct];
+			} else {
+				tmp++;
 			}
-			if (itemize) bot();
-			*bp = eshkp->bill_p[--eshkp->billct];
 		    }
 		}
 	    }
@@ -1841,6 +1864,38 @@ unsigned id;
 #endif /*OVLB*/
 #ifdef OVL3
 
+
+/** Returns the price of an arbitrary item in the shop.
+ * Returns 0 if the item doesn't belong to a shopkeeper. */
+long
+get_cost_of_shop_item(obj)
+     register struct obj *obj;
+{
+    struct monst *shkp;
+    xchar x, y;
+    int cost=0;
+
+    if (get_obj_location(obj, &x, &y, 0) &&
+	(obj->unpaid ||
+	 (obj->where==OBJ_FLOOR && !obj->no_charge && costly_spot(x,y)))) {
+
+	if (!(shkp = shop_keeper(*in_rooms(x, y, SHOPBASE)))) return 0;
+	if (!inhishop(shkp)) return 0;
+	if (!costly_spot(x, y)) return 0;
+	if (!*u.ushops) return 0;
+
+	if (obj->oclass != COIN_CLASS) {
+	    cost = (obj == uball || obj == uchain) ? 0L :
+		obj->quan * get_cost(obj, shkp);
+	    if (Has_contents(obj)) {
+		cost += contained_cost(obj, shkp, 0L, FALSE, FALSE);
+	    }
+	}
+    }
+    return cost;
+}
+
+
 /* calculate the value that the shk will charge for [one of] an object */
 STATIC_OVL long
 get_cost(obj, shkp)
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/shknam.c nethack-3.4.3-nao-osx/src/shknam.c
--- nethack-3.4.3/src/shknam.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/shknam.c	2014-12-20 12:08:36.000000000 -0800
@@ -408,6 +408,7 @@ struct mkroom	*sroom;
 	ESHK(shk)->visitct = 0;
 	ESHK(shk)->following = 0;
 	ESHK(shk)->billct = 0;
+	ESHK(shk)->bill_p = &ESHK(shk)->bill[0];
 #ifndef GOLDOBJ
 	shk->mgold = 1000L + 30L*(long)rnd(100);	/* initial capital */
 #else
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/sit.c nethack-3.4.3-nao-osx/src/sit.c
--- nethack-3.4.3/src/sit.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/sit.c	2014-12-20 12:08:36.000000000 -0800
@@ -436,6 +436,7 @@ attrcurse()			/* remove a random INTRINS
 		}
 	case 10: if (HProtection & INTRINSIC) {
 			HProtection &= ~INTRINSIC;
+			u.ublessed = 0; /* fix for C343-189 */
 			You_feel("vulnerable.");
 			break;
 		}
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/sounds.c nethack-3.4.3-nao-osx/src/sounds.c
--- nethack-3.4.3/src/sounds.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/sounds.c	2014-12-20 12:08:36.000000000 -0800
@@ -263,7 +263,11 @@ dosounds()
 
 static const char * const h_sounds[] = {
     "beep", "boing", "sing", "belche", "creak", "cough", "rattle",
-    "ululate", "pop", "jingle", "sniffle", "tinkle", "eep"
+    "ululate", "pop", "jingle", "sniffle", "tinkle", "eep",
+    "clatter", "hum", "sizzle", "twitter", "wheeze", "rustle",
+    "honk", "lisp", "yodel", "coo", "burp", "moo", "boom",
+    "murmur", "oink", "quack", "rumble", "twang", "bellow",
+    "toot", "gargle", "hoot", "warble"
 };
 
 const char *
@@ -325,7 +329,7 @@ register struct monst *mtmp;
 	growl_verb = growl_sound(mtmp);
     if (growl_verb) {
 	pline("%s %s!", Monnam(mtmp), vtense((char *)0, growl_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0, NULL);
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 18);
     }
 }
@@ -366,7 +370,7 @@ register struct monst *mtmp;
     }
     if (yelp_verb) {
 	pline("%s %s!", Monnam(mtmp), vtense((char *)0, yelp_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0, NULL);
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 12);
     }
 }
@@ -398,7 +402,7 @@ register struct monst *mtmp;
     }
     if (whimper_verb) {
 	pline("%s %s.", Monnam(mtmp), vtense((char *)0, whimper_verb));
-	if(flags.run) nomul(0);
+	if(flags.run) nomul(0, NULL);
 	wake_nearto(mtmp->mx, mtmp->my, mtmp->data->mlevel * 6);
     }
 }
@@ -627,7 +631,7 @@ register struct monst *mtmp;
 	case MS_BONES:
 	    pline("%s rattles noisily.", Monnam(mtmp));
 	    You("freeze for a moment.");
-	    nomul(-2);
+	    nomul(-2, "being scared by rattling");
 	    break;
 	case MS_LAUGH:
 	    {
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/sp_lev.c nethack-3.4.3-nao-osx/src/sp_lev.c
--- nethack-3.4.3/src/sp_lev.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/sp_lev.c	2014-12-20 12:08:36.000000000 -0800
@@ -1010,28 +1010,48 @@ struct mkroom	*croom;
 	    struct monst *was;
 	    struct obj *obj;
 	    int wastyp;
+	    int i = 0; /* prevent endless loop in case makemon always fails */
 
 	    /* Named random statues are of player types, and aren't stone-
 	     * resistant (if they were, we'd have to reset the name as well as
 	     * setting corpsenm).
 	     */
-	    for (wastyp = otmp->corpsenm; ; wastyp = rndmonnum()) {
+	    for (wastyp = otmp->corpsenm; i < 1000; i++) {
 		/* makemon without rndmonst() might create a group */
 		was = makemon(&mons[wastyp], 0, 0, NO_MM_FLAGS);
-		if (!resists_ston(was)) break;
+		if (was) {
+		    if (!resists_ston(was)) break;
+		    mongone(was);
+		}
+		wastyp = rndmonnum();
+	    }
+	    if (was) {
+		otmp->corpsenm = wastyp;
+		while(was->minvent) {
+		    obj = was->minvent;
+		    obj->owornmask = 0;
+		    obj_extract_self(obj);
+		    (void) add_to_container(otmp, obj);
+		}
+		otmp->owt = weight(otmp);
 		mongone(was);
 	    }
-	    otmp->corpsenm = wastyp;
-	    while(was->minvent) {
-		obj = was->minvent;
-		obj->owornmask = 0;
-		obj_extract_self(obj);
-		(void) add_to_container(otmp, obj);
-	    }
-	    otmp->owt = weight(otmp);
-	    mongone(was);
 	}
 
+#ifdef RECORD_ACHIEVE
+        /* Nasty hack here: try to determine if this is the Mines or Sokoban
+         * "prize" and then set record_achieve_special (maps to corpsenm)
+         * for the object.  That field will later be checked to find out if
+         * the player obtained the prize. */
+        if(otmp->otyp == LUCKSTONE && Is_mineend_level(&u.uz)) {
+                otmp->record_achieve_special = 1;
+        } else if((otmp->otyp == AMULET_OF_REFLECTION ||
+                   otmp->otyp == BAG_OF_HOLDING) && 
+                  Is_sokoend_level(&u.uz)) {
+                otmp->record_achieve_special = 1;
+        }
+#endif
+
 	stackobj(otmp);
 
     }		/* if (rn2(100) < o->chance) */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/spell.c nethack-3.4.3-nao-osx/src/spell.c
--- nethack-3.4.3/src/spell.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/spell.c	2014-12-20 12:08:36.000000000 -0800
@@ -325,7 +325,7 @@ learn()
 	if (Confusion) {		/* became confused while learning */
 	    (void) confused_book(book);
 	    book = 0;			/* no longer studying */
-	    nomul(delay);		/* remaining delay is uninterrupted */
+	    nomul(delay, "reading a book");		/* remaining delay is uninterrupted */
 	    delay = 0;
 	    return(0);
 	}
@@ -463,7 +463,7 @@ register struct obj *spellbook;
 		if (too_hard) {
 		    boolean gone = cursed_book(spellbook);
 
-		    nomul(delay);			/* study time */
+		    nomul(delay, "reading a book");			/* study time */
 		    delay = 0;
 		    if(gone || !rn2(3)) {
 			if (!gone) pline_The("spellbook crumbles to dust!");
@@ -478,7 +478,7 @@ register struct obj *spellbook;
 		    if (!confused_book(spellbook)) {
 			spellbook->in_use = FALSE;
 		    }
-		    nomul(delay);
+		    nomul(delay, "reading a book");
 		    delay = 0;
 		    return(1);
 		}
@@ -665,8 +665,9 @@ cast_protection()
 			      hgolden);
 		else
 		    pline_The("%s around you begins to shimmer with %s haze.",
-			/*[ what about being inside solid rock while polyd? ]*/
-			(Underwater || Is_waterlevel(&u.uz)) ? "water" : "air",
+			      (Underwater || Is_waterlevel(&u.uz)) ? "water" :
+			       u.uswallow ? mbodypart(u.ustuck, STOMACH) :
+			      IS_STWALL(levl[u.ux][u.uy].typ) ? "stone" : "air",
 			      an(hgolden));
 	    }
 	    u.uspellprot += gain;
@@ -1114,6 +1115,35 @@ int *spell_no;
 	return FALSE;
 }
 
+#ifdef DUMP_LOG
+void 
+dump_spells()
+{
+	int i;
+	char buf[BUFSZ];
+
+	if (spellid(0) == NO_SPELL) {
+	    dump("", "You didn't know any spells.");
+	    dump("", "");
+	    return;
+	}
+	dump("", "Spells known in the end");
+
+	Sprintf(buf, "%-20s   Level    %-12s Fail", "    Name", "Category");
+	dump("  ",buf);
+	for (i = 0; i < MAXSPELL && spellid(i) != NO_SPELL; i++) {
+		Sprintf(buf, "%c - %-20s  %2d%s   %-12s %3d%%",
+			spellet(i), spellname(i), spellev(i),
+			spellknow(i) ? " " : "*",
+			spelltypemnemonic(spell_skilltype(spellid(i))),
+			100 - percent_success(i));
+		dump("  ", buf);
+	}
+	dump("","");
+
+} /* dump_spells */
+#endif
+
 /* Integer square root function without using floating point. */
 STATIC_OVL int
 isqrt(val)
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/steal.c nethack-3.4.3-nao-osx/src/steal.c
--- nethack-3.4.3/src/steal.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/steal.c	2014-12-20 12:08:36.000000000 -0800
@@ -382,7 +382,7 @@ gotobj:
 				  equipname(otmp));
 			named++;
 			/* the following is to set multi for later on */
-			nomul(-armordelay);
+			nomul(-armordelay, "taking off clothes");
 			remove_worn_item(otmp, TRUE);
 			otmp->cursed = curssv;
 			if(multi < 0){
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/teleport.c nethack-3.4.3-nao-osx/src/teleport.c
--- nethack-3.4.3/src/teleport.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/teleport.c	2014-12-20 12:08:36.000000000 -0800
@@ -326,7 +326,7 @@ boolean allow_drag;
 	newsym(u.ux0,u.uy0);
 	see_monsters();
 	vision_full_recalc = 1;
-	nomul(0);
+	nomul(0, NULL);
 	vision_recalc(0);	/* vision before effects */
 	spoteffects(TRUE);
 	invocation_message();
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/timeout.c nethack-3.4.3-nao-osx/src/timeout.c
--- nethack-3.4.3/src/timeout.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/timeout.c	2014-12-20 12:08:36.000000000 -0800
@@ -30,12 +30,14 @@ stoned_dialogue()
 {
 	register long i = (Stoned & TIMEOUT);
 
-	if (i > 0L && i <= SIZE(stoned_texts))
+	if (i > 0L && i <= SIZE(stoned_texts)) {
 		pline(stoned_texts[SIZE(stoned_texts) - i]);
+		nomul(0, NULL); /* fix for C343-74 */
+	}
 	if (i == 5L)
 		HFast = 0L;
 	if (i == 3L)
-		nomul(-3);
+		nomul(-3, "getting stoned");
 	exercise(A_DEX, FALSE);
 }
 
@@ -137,7 +139,7 @@ slime_dialogue()
 	if (i == 3L) {	/* limbs becoming oozy */
 	    HFast = 0L;	/* lose intrinsic speed */
 	    stop_occupation();
-	    if (multi > 0) nomul(0);
+	    if (multi > 0) nomul(0, NULL);
 	}
 	exercise(A_DEX, FALSE);
 }
@@ -327,7 +329,7 @@ nh_timeout()
 			/* otherwise handle fumbling msgs locally. */
 			if (u.umoved && !Levitation) {
 			    slip_or_trip();
-			    nomul(-2);
+			    nomul(-2, "fumbling");
 			    nomovemsg = "";
 			    /* The more you are carrying the more likely you
 			     * are to make noise when you fumble.  Adjustments
@@ -362,7 +364,7 @@ int how_long;
 boolean wakeup_msg;
 {
 	stop_occupation();
-	nomul(how_long);
+	nomul(how_long, "sleeping");
 	/* generally don't notice sounds while sleeping */
 	if (wakeup_msg && multi == how_long) {
 	    /* caller can follow with a direct call to Hear_again() if
@@ -1220,7 +1222,7 @@ do_storms()
 	pline("Kaboom!!!  Boom!!  Boom!!");
 	if(!u.uinvulnerable) {
 	    stop_occupation();
-	    nomul(-3);
+	    nomul(-3, "hiding from thunderstorm");
 	}
     } else
 	You_hear("a rumbling noise.");
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/topten.c nethack-3.4.3-nao-osx/src/topten.c
--- nethack-3.4.3/src/topten.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/topten.c	2014-12-20 12:08:36.000000000 -0800
@@ -9,6 +9,10 @@
 #else
 #include "patchlevel.h"
 #endif
+#ifdef UNIX /* filename chmod() */
+#include <sys/types.h>
+#include <sys/stat.h>
+#endif
 
 #ifdef VMS
  /* We don't want to rewrite the whole file, because that entails	 */
@@ -30,15 +34,15 @@ static long final_fpos;
 
 #define newttentry() (struct toptenentry *) alloc(sizeof(struct toptenentry))
 #define dealloc_ttentry(ttent) free((genericptr_t) (ttent))
-#define NAMSZ	10
+#define NAMSZ	20
 #define DTHSZ	100
 #define ROLESZ   3
 #define PERSMAX	 3		/* entries per name/uid per char. allowed */
 #define POINTSMIN	1	/* must be > 0 */
-#define ENTRYMAX	100	/* must be >= 10 */
+#define ENTRYMAX	2000	/* must be >= 10 */
 
 #if !defined(MICRO) && !defined(MAC) && !defined(WIN32)
-#define PERS_IS_UID		/* delete for PERSMAX per name; now per uid */
+/*#define PERS_IS_UID*/		/* delete for PERSMAX per name; now per uid */
 #endif
 struct toptenentry {
 	struct toptenentry *tt_next;
@@ -66,10 +70,21 @@ STATIC_DCL void NDECL(outheader);
 STATIC_DCL void FDECL(outentry, (int,struct toptenentry *,BOOLEAN_P));
 STATIC_DCL void FDECL(readentry, (FILE *,struct toptenentry *));
 STATIC_DCL void FDECL(writeentry, (FILE *,struct toptenentry *));
+#ifdef XLOGFILE
+STATIC_DCL void FDECL(munge_xlstring, (char *dest, char *src, int n));
+STATIC_DCL void FDECL(write_xlentry, (FILE *,struct toptenentry *));
+#endif
 STATIC_DCL void FDECL(free_ttlist, (struct toptenentry *));
 STATIC_DCL int FDECL(classmon, (char *,BOOLEAN_P));
 STATIC_DCL int FDECL(score_wanted,
 		(BOOLEAN_P, int,struct toptenentry *,int,const char **,int));
+#ifdef RECORD_CONDUCT
+/*STATIC_DCL long FDECL(encodeconduct, (void));*/
+#endif
+#ifdef RECORD_ACHIEVE
+STATIC_DCL long FDECL(encodeachieve, (void));
+#endif
+STATIC_DCL long FDECL(encode_xlogflags, (void));
 #ifdef NO_SCAN_BRACK
 STATIC_DCL void FDECL(nsb_mung_line,(char*));
 STATIC_DCL void FDECL(nsb_unmung_line,(char*));
@@ -84,6 +99,10 @@ NEARDATA const char * const killed_by_pr
 
 static winid toptenwin = WIN_ERR;
 
+#ifdef RECORD_START_END_TIME
+static time_t deathtime = 0L;
+#endif
+
 STATIC_OVL void
 topten_print(x)
 const char *x;
@@ -226,6 +245,211 @@ struct toptenentry *tt;
 #endif
 }
 
+#ifdef XLOGFILE
+#define SEP ":"
+#define SEPC ':'
+
+/* copy a maximum of n-1 characters from src to dest, changing ':' and '\n'
+ * to '_'; always null-terminate. */
+STATIC_OVL void
+munge_xlstring(dest, src, n)
+char *dest;
+char *src;
+int n;
+{
+  int i;
+
+  for(i = 0; i < (n - 1) && src[i] != '\0'; i++) {
+    if(src[i] == SEPC || src[i] == '\n')
+      dest[i] = '_';
+    else
+      dest[i] = src[i];
+  }
+
+  dest[i] = '\0';
+
+  return;
+}
+
+STATIC_OVL void
+write_xlentry(rfile,tt)
+FILE *rfile;
+struct toptenentry *tt;
+{
+
+  char buf[DTHSZ+1];
+
+  /* Log all of the data found in the regular logfile */
+  (void)fprintf(rfile,
+                "version=%d.%d.%d"
+                SEP "points=%ld"
+                SEP "deathdnum=%d"
+                SEP "deathlev=%d"
+                SEP "maxlvl=%d"
+                SEP "hp=%d"
+                SEP "maxhp=%d"
+                SEP "deaths=%d"
+                SEP "deathdate=%d"
+                SEP "birthdate=%d"
+                SEP "uid=%d",
+                tt->ver_major, tt->ver_minor, tt->patchlevel,
+                tt->points, tt->deathdnum, tt->deathlev,
+                tt->maxlvl, tt->hp, tt->maxhp, tt->deaths,
+                tt->deathdate, tt->birthdate, tt->uid);
+
+  (void)fprintf(rfile,
+                SEP "role=%s"
+                SEP "race=%s"
+                SEP "gender=%s"
+                SEP "align=%s",
+                tt->plrole, tt->plrace, tt->plgend, tt->plalign);
+   
+   munge_xlstring(buf, plname, DTHSZ + 1);
+  (void)fprintf(rfile, SEP "name=%s", buf);
+
+   munge_xlstring(buf, tt->death, DTHSZ + 1);
+  (void)fprintf(rfile, SEP "death=%s", buf);
+
+  (void)fprintf(rfile, SEP "flags=0x%lx", encode_xlogflags());
+
+#ifdef RECORD_CONDUCT
+  (void)fprintf(rfile, SEP "conduct=0x%lx", encodeconduct());
+#endif
+
+#ifdef RECORD_TURNS
+  (void)fprintf(rfile, SEP "turns=%ld", moves);
+#endif
+
+#ifdef RECORD_ACHIEVE
+  (void)fprintf(rfile, SEP "achieve=0x%lx", encodeachieve());
+#endif
+
+#ifdef RECORD_REALTIME
+  (void)fprintf(rfile, SEP "realtime=%ld", (long)realtime_data.realtime);
+#endif
+
+#ifdef RECORD_START_END_TIME
+  (void)fprintf(rfile, SEP "starttime=%ld", (long)u.ubirthday);
+  (void)fprintf(rfile, SEP "endtime=%ld", (long)deathtime);
+#endif
+
+#ifdef RECORD_GENDER0
+  (void)fprintf(rfile, SEP "gender0=%s", genders[flags.initgend].filecode);
+#endif
+
+#ifdef RECORD_ALIGN0
+  (void)fprintf(rfile, SEP "align0=%s", 
+          aligns[1 - u.ualignbase[A_ORIGINAL]].filecode);
+#endif
+
+  (void)fprintf(rfile, "\n");
+
+}
+
+#undef SEP
+#undef SEPC
+#endif /* XLOGFILE */
+
+
+void
+get_current_ttentry_data(t0, how)
+struct toptenentry *t0;
+int how;
+{
+	int uid = getuid();
+	t0->ver_major = VERSION_MAJOR;
+	t0->ver_minor = VERSION_MINOR;
+	t0->patchlevel = PATCHLEVEL;
+	t0->points = u.urexp;
+	t0->deathdnum = u.uz.dnum;
+	t0->deathlev = observable_depth(&u.uz);
+	t0->maxlvl = deepest_lev_reached(TRUE);
+	t0->hp = u.uhp;
+	t0->maxhp = u.uhpmax;
+	t0->deaths = u.umortality;
+	t0->uid = uid;
+	(void) strncpy(t0->plrole, urole.filecode, ROLESZ);
+	t0->plrole[ROLESZ] = '\0';
+	(void) strncpy(t0->plrace, urace.filecode, ROLESZ);
+	t0->plrace[ROLESZ] = '\0';
+	(void) strncpy(t0->plgend, genders[flags.female].filecode, ROLESZ);
+	t0->plgend[ROLESZ] = '\0';
+	(void) strncpy(t0->plalign, aligns[1-u.ualign.type].filecode, ROLESZ);
+	t0->plalign[ROLESZ] = '\0';
+	(void) strncpy(t0->name, plname, NAMSZ);
+	t0->name[NAMSZ] = '\0';
+	t0->death[0] = '\0';
+	if (how == -1) {
+	    Strcat(t0->death, "hangup");
+	} else {
+	    switch (killer_format) {
+		default: impossible("bad killer format?");
+		case KILLED_BY_AN:
+			Strcat(t0->death, killed_by_prefix[how]);
+			(void) strncat(t0->death, an(killer),
+						DTHSZ-strlen(t0->death));
+			break;
+		case KILLED_BY:
+			Strcat(t0->death, killed_by_prefix[how]);
+			(void) strncat(t0->death, killer,
+						DTHSZ-strlen(t0->death));
+			break;
+		case NO_KILLER_PREFIX:
+			(void) strncat(t0->death, killer, DTHSZ);
+			break;
+	    }
+	}
+	t0->birthdate = yyyymmdd(u.ubirthday);
+
+#ifdef RECORD_START_END_TIME
+  /* Make sure that deathdate and deathtime refer to the same time; it
+   * wouldn't be good to have deathtime refer to the day after deathdate. */
+
+#if defined(BSD) && !defined(POSIX_TYPES)
+        (void) time((long *)&deathtime);
+#else
+        (void) time(&deathtime);
+#endif
+
+        t0->deathdate = yyyymmdd(deathtime);
+#else
+        t0->deathdate = yyyymmdd((time_t)0L);
+#endif /* RECORD_START_END_TIME */
+}
+
+/* record into file whenever user does HUP */
+void
+mk_HUPfile(char *fname)
+{
+  if (fname[0]) {
+    char new_dump_fn[512];
+    Sprintf(new_dump_fn, "%s", dump_format_str(fname));
+
+    FILE *dump_fp = fopen(new_dump_fn, "a");
+    if (!dump_fp) {
+    } else {
+	struct toptenentry t0;
+#ifdef UNIX
+	mode_t dumpmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+	chmod(new_dump_fn, dumpmode);
+#endif
+	get_current_ttentry_data(&t0, -1);
+	write_xlentry(dump_fp, &t0);
+	fclose(dump_fp);
+    }
+  }
+}
+
+
+void
+write_HUP_file()
+{
+#ifdef HUPLIST_FN
+    mk_HUPfile(HUPLIST_FN);
+#endif
+}
+
+
 STATIC_OVL void
 free_ttlist(tt)
 struct toptenentry *tt;
@@ -244,7 +468,6 @@ void
 topten(how)
 int how;
 {
-	int uid = getuid();
 	int rank, rank0 = -1, rank1 = 0;
 	int occ_cnt = PERSMAX;
 	register struct toptenentry *t0, *tprev;
@@ -255,6 +478,9 @@ int how;
 #ifdef LOGFILE
 	FILE *lfile;
 #endif /* LOGFILE */
+#ifdef XLOGFILE
+	FILE *xlfile;
+#endif /* XLOGFILE */
 
 /* Under DICE 3.0, this crashes the system consistently, apparently due to
  * corruption of *rfile somewhere.  Until I figure this out, just cut out
@@ -293,46 +519,9 @@ int how;
 	 * as well (which also seems reasonable since that's all the player
 	 * sees on the screen anyway)
 	 */
-	t0->ver_major = VERSION_MAJOR;
-	t0->ver_minor = VERSION_MINOR;
-	t0->patchlevel = PATCHLEVEL;
-	t0->points = u.urexp;
-	t0->deathdnum = u.uz.dnum;
-	t0->deathlev = observable_depth(&u.uz);
-	t0->maxlvl = deepest_lev_reached(TRUE);
-	t0->hp = u.uhp;
-	t0->maxhp = u.uhpmax;
-	t0->deaths = u.umortality;
-	t0->uid = uid;
-	(void) strncpy(t0->plrole, urole.filecode, ROLESZ);
-	t0->plrole[ROLESZ] = '\0';
-	(void) strncpy(t0->plrace, urace.filecode, ROLESZ);
-	t0->plrace[ROLESZ] = '\0';
-	(void) strncpy(t0->plgend, genders[flags.female].filecode, ROLESZ);
-	t0->plgend[ROLESZ] = '\0';
-	(void) strncpy(t0->plalign, aligns[1-u.ualign.type].filecode, ROLESZ);
-	t0->plalign[ROLESZ] = '\0';
-	(void) strncpy(t0->name, plname, NAMSZ);
-	t0->name[NAMSZ] = '\0';
-	t0->death[0] = '\0';
-	switch (killer_format) {
-		default: impossible("bad killer format?");
-		case KILLED_BY_AN:
-			Strcat(t0->death, killed_by_prefix[how]);
-			(void) strncat(t0->death, an(killer),
-						DTHSZ-strlen(t0->death));
-			break;
-		case KILLED_BY:
-			Strcat(t0->death, killed_by_prefix[how]);
-			(void) strncat(t0->death, killer,
-						DTHSZ-strlen(t0->death));
-			break;
-		case NO_KILLER_PREFIX:
-			(void) strncat(t0->death, killer, DTHSZ);
-			break;
-	}
-	t0->birthdate = yyyymmdd(u.ubirthday);
-	t0->deathdate = yyyymmdd((time_t)0L);
+
+	get_current_ttentry_data(t0,how);
+
 	t0->tt_next = 0;
 #ifdef UPDATE_RECORD_IN_PLACE
 	t0->fpos = -1L;
@@ -350,6 +539,18 @@ int how;
 	}
 #endif /* LOGFILE */
 
+#ifdef XLOGFILE
+         if(lock_file(XLOGFILE, SCOREPREFIX, 10)) {
+             if(!(xlfile = fopen_datafile(XLOGFILE, "a", SCOREPREFIX))) {
+                  HUP raw_print("Cannot open extended log file!");
+             } else {
+                  write_xlentry(xlfile, t0);
+                  (void) fclose(xlfile);
+             }
+             unlock_file(XLOGFILE);
+         }
+#endif /* XLOGFILE */
+
 	if (wizard || discover) {
 	    if (how != PANICKED) HUP {
 		char pbuf[BUFSZ];
@@ -358,6 +559,12 @@ int how;
 	      "Since you were in %s mode, the score list will not be checked.",
 		    wizard ? "wizard" : "discover");
 		topten_print(pbuf);
+#ifdef DUMP_LOG
+		if (dump_fn[0]) {
+		  dump("", pbuf);
+		  dump("", "");
+		}
+#endif
 	    }
 	    goto showwin;
 	}
@@ -378,6 +585,9 @@ int how;
 	}
 
 	HUP topten_print("");
+#ifdef DUMP_LOG
+	dump("", "");
+#endif
 
 	/* assure minimum number of points */
 	if(t0->points < POINTSMIN) t0->points = 0;
@@ -422,6 +632,10 @@ int how;
 				    t1->points);
 			    topten_print(pbuf);
 			    topten_print("");
+#ifdef DUMP_LOG
+			    dump("", pbuf);
+			    dump("", "");
+#endif
 			}
 		    }
 		    if(occ_cnt < 0) {
@@ -452,17 +666,27 @@ int how;
 			goto destroywin;
 		}
 #endif	/* UPDATE_RECORD_IN_PLACE */
-		if(!done_stopprint) if(rank0 > 0){
-		    if(rank0 <= 10)
+		if(rank0 > 0){
+		    if(rank0 <= 10) {
+			if(!done_stopprint) 
 			topten_print("You made the top ten list!");
-		    else {
+#ifdef DUMP_LOG
+			dump("", "You made the top ten list!");
+#endif
+		    } else {
 			char pbuf[BUFSZ];
 			Sprintf(pbuf,
 			  "You reached the %d%s place on the top %d list.",
 				rank0, ordin(rank0), ENTRYMAX);
-			topten_print(pbuf);
+			if(!done_stopprint) topten_print(pbuf);
+#ifdef DUMP_LOG
+			dump("", pbuf);
+#endif
 		    }
-		    topten_print("");
+		    if(!done_stopprint) topten_print("");
+#ifdef DUMP_LOG
+		    dump("", "");
+#endif
 		}
 	}
 	if(rank0 == 0) rank0 = rank1;
@@ -475,7 +699,7 @@ int how;
 		    && rank >= rank0
 #endif
 		) writeentry(rfile, t1);
-	    if (done_stopprint) continue;
+	    /* if (done_stopprint) continue; */
 	    if (rank > flags.end_top &&
 		    (rank < rank0 - flags.end_around ||
 		     rank > rank0 + flags.end_around) &&
@@ -488,8 +712,12 @@ int how;
 		)) continue;
 	    if (rank == rank0 - flags.end_around &&
 		    rank0 > flags.end_top + flags.end_around + 1 &&
-		    !flags.end_own)
-		topten_print("");
+		    !flags.end_own) {
+		if(!done_stopprint) topten_print("");
+#ifdef DUMP_LOG
+		dump("", "");
+#endif
+	    }
 	    if(rank != rank0)
 		outentry(rank, t1, FALSE);
 	    else if(!rank1)
@@ -546,7 +774,10 @@ outheader()
 	bp = eos(linebuf);
 	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
 	Strcpy(bp, "Hp [max]");
-	topten_print(linebuf);
+	if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump("", linebuf);
+#endif
 }
 
 /* so>0: standout line; so=0: ordinary line */
@@ -664,9 +895,16 @@ boolean so;
 	    if (so) {
 		while (bp < linebuf + (COLNO-1)) *bp++ = ' ';
 		*bp = 0;
-		topten_print_bold(linebuf);
-	    } else
-		topten_print(linebuf);
+		if(!done_stopprint) topten_print_bold(linebuf);
+#ifdef DUMP_LOG
+		dump("*", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
+	    } else {
+		if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+		dump(" ", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
+	    }
 	    Sprintf(linebuf, "%15s %s", "", linebuf3);
 	    lngr = strlen(linebuf);
 	}
@@ -688,9 +926,12 @@ boolean so;
 	    if (so >= COLNO) so = COLNO-1;
 	    while (bp < linebuf + so) *bp++ = ' ';
 	    *bp = 0;
-	    topten_print_bold(linebuf);
+	    if(!done_stopprint) topten_print_bold(linebuf);
 	} else
-	    topten_print(linebuf);
+	    if(!done_stopprint) topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump(" ", linebuf[0]==' '? linebuf+1: linebuf);
+#endif
 }
 
 STATIC_OVL int
@@ -735,6 +976,97 @@ int uid;
 	return 0;
 }
 
+long
+encode_xlogflags(void)
+{
+       long e = 0L;
+
+       if (wizard)              e |= 0x001L; /* wizard mode */
+       if (discover)            e |= 0x002L; /* explore mode */
+       if (killer_flags & 0x1)  e |= 0x004L; /* died, (with the Amulet) */
+       if (killer_flags & 0x2)  e |= 0x008L; /* died, (in celestial disgrace) */
+       if (killer_flags & 0x4)  e |= 0x010L; /* died, (with a fake Amulet) */
+       if (has_loaded_bones)    e |= 0x020L; /* has loaded bones */
+       /*
+       if(!u.uconduct.unvegetarian)    e |= 0x004L;
+       if(!u.uconduct.gnostic)         e |= 0x008L;
+       if(!u.uconduct.weaphit)         e |= 0x010L;
+       if(!u.uconduct.killer)          e |= 0x020L;
+       if(!u.uconduct.literate)        e |= 0x040L;
+       if(!u.uconduct.polypiles)       e |= 0x080L;
+       if(!u.uconduct.polyselfs)       e |= 0x100L;
+       if(!u.uconduct.wishes)          e |= 0x200L;
+       if(!u.uconduct.wisharti)        e |= 0x400L;
+       if(!num_genocides())            e |= 0x800L;
+       */
+       return e;
+}
+
+
+#ifdef RECORD_CONDUCT
+long
+encodeconduct(void)
+{
+       long e = 0L;
+
+       if(!u.uconduct.food)            e |= 0x001L;
+       if(!u.uconduct.unvegan)         e |= 0x002L;
+       if(!u.uconduct.unvegetarian)    e |= 0x004L;
+       if(!u.uconduct.gnostic)         e |= 0x008L;
+       if(!u.uconduct.weaphit)         e |= 0x010L;
+       if(!u.uconduct.killer)          e |= 0x020L;
+       if(!u.uconduct.literate)        e |= 0x040L;
+       if(!u.uconduct.polypiles)       e |= 0x080L;
+       if(!u.uconduct.polyselfs)       e |= 0x100L;
+       if(!u.uconduct.wishes)          e |= 0x200L;
+       if(!u.uconduct.wisharti)        e |= 0x400L;
+       if(!num_genocides())            e |= 0x800L;
+
+       return e;
+}
+#endif
+
+#ifdef RECORD_ACHIEVE
+long
+encodeachieve(void)
+{
+  /* Achievement bitfield:
+   * bit  meaning
+   *  0   obtained the Bell of Opening
+   *  1   entered gehennom (by any means)
+   *  2   obtained the Candelabrum of Invocation
+   *  3   obtained the Book of the Dead
+   *  4   performed the invocation ritual
+   *  5   obtained the amulet
+   *  6   entered elemental planes
+   *  7   entered astral plane
+   *  8   ascended (not "escaped in celestial disgrace!")
+   *  9   obtained the luckstone from the Mines
+   *  10  obtained the sokoban prize
+   *  11  killed medusa
+   */
+
+  long r;
+
+  r = 0;
+
+  if(achieve.get_bell)           r |= 1L << 0;
+  if(achieve.enter_gehennom)     r |= 1L << 1;
+  if(achieve.get_candelabrum)    r |= 1L << 2;
+  if(achieve.get_book)           r |= 1L << 3;
+  if(achieve.perform_invocation) r |= 1L << 4;
+  if(achieve.get_amulet)         r |= 1L << 5;
+  if(In_endgame(&u.uz))          r |= 1L << 6;
+  if(Is_astralevel(&u.uz))       r |= 1L << 7;
+  if(achieve.ascended)           r |= 1L << 8;
+  if(achieve.get_luckstone)      r |= 1L << 9;
+  if(achieve.finish_sokoban)     r |= 1L << 10;
+  if(achieve.killed_medusa)      r |= 1L << 11;
+
+  return r;
+}
+#endif
+
 /*
  * print selected parts of score list.
  * argc >= 2, with argv[0] untrustworthy (directory names, et al.),
@@ -928,7 +1260,7 @@ struct obj *otmp;
 	}
 
 	tt = &tt_buf;
-	rank = rnd(10);
+	rank = rnd(1000);
 pickentry:
 	for(i = rank; i; i--) {
 	    readentry(rfile, tt);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/trap.c nethack-3.4.3-nao-osx/src/trap.c
--- nethack-3.4.3/src/trap.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/trap.c	2014-12-20 12:08:36.000000000 -0800
@@ -591,7 +591,7 @@ unsigned trflags;
 	boolean webmsgok = (!(trflags & NOWEBMSG));
 	boolean forcebungle = (trflags & FORCEBUNGLE);
 
-	nomul(0);
+	nomul(0, NULL);
 
 	/* KMH -- You can't escape the Sokoban level traps */
 	if (In_sokoban(&u.uz) &&
@@ -1415,7 +1415,7 @@ int style;
 				break;
 			}
 		} else if (bhitpos.x == u.ux && bhitpos.y == u.uy) {
-			if (multi) nomul(0);
+			if (multi) nomul(0, NULL);
 			if (thitu(9 + singleobj->spe,
 				  dmgval(singleobj, &youmonst),
 				  singleobj, (char *)0))
@@ -2678,12 +2678,15 @@ xchar x, y;
     return retval;
 }
 
-void
+/* returns TRUE if obj is destroyed */
+boolean
 water_damage(obj, force, here)
 register struct obj *obj;
 register boolean force, here;
 {
 	struct obj *otmp;
+	struct obj *obj_original = obj;
+	boolean obj_destroyed = FALSE;
 
 	/* Scrolls, spellbooks, potions, weapons and
 	   pieces of armor may get affected by the water */
@@ -2724,6 +2727,7 @@ register boolean force, here;
 				/* damage player/monster? */
 				pline("A potion explodes!");
 				delobj(obj);
+				obj_destroyed = (obj == obj_original);
 				continue;
 			} else if (obj->odiluted) {
 				obj->otyp = POT_WATER;
@@ -2740,7 +2744,9 @@ register boolean force, here;
 			   (uarmc->cursed && !rn2(3)))
 				obj->oeroded++;
 		}
+		obj_destroyed = FALSE;
 	}
+	return obj_destroyed;
 }
 
 /*
@@ -3741,7 +3747,7 @@ boolean disarm;
 		case 3:
 			if (!Free_action) {                        
 			pline("Suddenly you are frozen in place!");
-			nomul(-d(5, 6));
+			nomul(-d(5, 6), "frozen by a trap");
 			exercise(A_DEX, FALSE);
 			nomovemsg = You_can_move_again;
 			} else You("momentarily stiffen.");
@@ -3798,10 +3804,12 @@ register struct trap *trap;
 {
 	register struct trap *ttmp;
 
+	if (!trap) return;
 	if(trap == ftrap)
 		ftrap = ftrap->ntrap;
 	else {
-		for(ttmp = ftrap; ttmp->ntrap != trap; ttmp = ttmp->ntrap) ;
+		for(ttmp = ftrap; ttmp && ttmp->ntrap != trap; ttmp = ttmp->ntrap) ;
+		if (!ttmp) return;
 		ttmp->ntrap = trap->ntrap;
 	}
 	dealloc_trap(trap);
@@ -3948,6 +3956,12 @@ lava_effects()
 	for(obj = invent; obj; obj = obj2) {
 	    obj2 = obj->nobj;
 	    if(is_organic(obj) && !obj->oerodeproof) {
+	        if (obj->otyp == SPE_BOOK_OF_THE_DEAD) {
+		  if (!Blind && usurvive)
+		    pline("%s glows a strange %s, but remains intact.",
+			  The(xname(obj)), hcolor("dark red"));
+		  continue;
+		}
 		if(obj->owornmask) {
 		    if (usurvive)
 			Your("%s into flame!", aobjnam(obj, "burst"));
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/uhitm.c nethack-3.4.3-nao-osx/src/uhitm.c
--- nethack-3.4.3/src/uhitm.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/uhitm.c	2014-12-20 12:08:36.000000000 -0800
@@ -99,6 +99,9 @@ register struct monst *mtmp;
 struct obj *wep;	/* uwep for attack(), null for kick_monster() */
 {
 	char qbuf[QBUFSZ];
+#ifdef PARANOID
+	char buf[BUFSZ];
+#endif
 
 	/* if you're close enough to attack, alert any waiting monster */
 	mtmp->mstrategy &= ~STRAT_WAITMASK;
@@ -199,11 +202,26 @@ struct obj *wep;	/* uwep for attack(), n
 			return(FALSE);
 		}
 		if (canspotmon(mtmp)) {
+#ifdef PARANOID
+			Sprintf(qbuf, "Really attack %s? [no/yes]",
+				mon_nam(mtmp));
+			if (iflags.paranoid_hit) {
+				getlin (qbuf, buf);
+				(void) lcase (buf);
+				if (strcmp (buf, "yes")) {
+				  flags.move = 0;
+				  return(TRUE);
+				}
+			} else {
+#endif
 			Sprintf(qbuf, "Really attack %s?", mon_nam(mtmp));
 			if (yn(qbuf) != 'y') {
 				flags.move = 0;
 				return(TRUE);
 			}
+#ifdef PARANOID
+			}
+#endif
 		}
 	}
 
@@ -1813,7 +1831,7 @@ register struct attack *mattk;
 				 */
 				You("digest %s.", mon_nam(mdef));
 				if (Slow_digestion) tmp *= 2;
-				nomul(-tmp);
+				nomul(-tmp, "digesting something");
 				nomovemsg = msgbuf;
 			    } else pline("%s", msgbuf);
 			    if (mdef->data == &mons[PM_GREEN_SLIME]) {
@@ -2267,7 +2285,7 @@ uchar aatyp;
 			else {
 			    You("are frozen by %s gaze!",
 				  s_suffix(mon_nam(mon)));
-			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -127);
+			    nomul((ACURR(A_WIS) > 12 || rn2(4)) ? -tmp : -127, "frozen by a monster's gaze");
 			}
 		    } else {
 			pline("%s cannot defend itself.",
@@ -2279,7 +2297,7 @@ uchar aatyp;
 		} else { /* gelatinous cube */
 		    You("are frozen by %s!", mon_nam(mon));
 	    	    nomovemsg = 0;	/* default: "you can move again" */
-		    nomul(-tmp);
+		    nomul(-tmp, "frozen by a monster");
 		    exercise(A_DEX, FALSE);
 		}
 		break;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/unicode.c nethack-3.4.3-nao-osx/src/unicode.c
--- nethack-3.4.3/src/unicode.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/unicode.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,221 @@
+/*	SCCS Id: @(#)end.c	3.5	2011/01/19	*/
+/* Copyright (c) Patric Mueller.			*/
+/* NetHack may be freely redistributed.  See license for details. */
+
+#include "hack.h"
+
+/** CP437 to Unicode mapping according to the Unicode Consortium
+ * http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/PC/CP437.TXT */
+static glyph_t cp437_to_unicode[] = {
+	0x00c7, /* LATIN CAPITAL LETTER C WITH CEDILLA */
+	0x00fc, /* LATIN SMALL LETTER U WITH DIAERESIS */
+	0x00e9, /* LATIN SMALL LETTER E WITH ACUTE */
+	0x00e2, /* LATIN SMALL LETTER A WITH CIRCUMFLEX */
+	0x00e4, /* LATIN SMALL LETTER A WITH DIAERESIS */
+	0x00e0, /* LATIN SMALL LETTER A WITH GRAVE */
+	0x00e5, /* LATIN SMALL LETTER A WITH RING ABOVE */
+	0x00e7, /* LATIN SMALL LETTER C WITH CEDILLA */
+	0x00ea, /* LATIN SMALL LETTER E WITH CIRCUMFLEX */
+	0x00eb, /* LATIN SMALL LETTER E WITH DIAERESIS */
+	0x00e8, /* LATIN SMALL LETTER E WITH GRAVE */
+	0x00ef, /* LATIN SMALL LETTER I WITH DIAERESIS */
+	0x00ee, /* LATIN SMALL LETTER I WITH CIRCUMFLEX */
+	0x00ec, /* LATIN SMALL LETTER I WITH GRAVE */
+	0x00c4, /* LATIN CAPITAL LETTER A WITH DIAERESIS */
+	0x00c5, /* LATIN CAPITAL LETTER A WITH RING ABOVE */
+	0x00c9, /* LATIN CAPITAL LETTER E WITH ACUTE */
+	0x00e6, /* LATIN SMALL LIGATURE AE */
+	0x00c6, /* LATIN CAPITAL LIGATURE AE */
+	0x00f4, /* LATIN SMALL LETTER O WITH CIRCUMFLEX */
+	0x00f6, /* LATIN SMALL LETTER O WITH DIAERESIS */
+	0x00f2, /* LATIN SMALL LETTER O WITH GRAVE */
+	0x00fb, /* LATIN SMALL LETTER U WITH CIRCUMFLEX */
+	0x00f9, /* LATIN SMALL LETTER U WITH GRAVE */
+	0x00ff, /* LATIN SMALL LETTER Y WITH DIAERESIS */
+	0x00d6, /* LATIN CAPITAL LETTER O WITH DIAERESIS */
+	0x00dc, /* LATIN CAPITAL LETTER U WITH DIAERESIS */
+	0x00a2, /* CENT SIGN */
+	0x00a3, /* POUND SIGN */
+	0x00a5, /* YEN SIGN */
+	0x20a7, /* PESETA SIGN */
+	0x0192, /* LATIN SMALL LETTER F WITH HOOK */
+	0x00e1, /* LATIN SMALL LETTER A WITH ACUTE */
+	0x00ed, /* LATIN SMALL LETTER I WITH ACUTE */
+	0x00f3, /* LATIN SMALL LETTER O WITH ACUTE */
+	0x00fa, /* LATIN SMALL LETTER U WITH ACUTE */
+	0x00f1, /* LATIN SMALL LETTER N WITH TILDE */
+	0x00d1, /* LATIN CAPITAL LETTER N WITH TILDE */
+	0x00aa, /* FEMININE ORDINAL INDICATOR */
+	0x00ba, /* MASCULINE ORDINAL INDICATOR */
+	0x00bf, /* INVERTED QUESTION MARK */
+	0x2310, /* REVERSED NOT SIGN */
+	0x00ac, /* NOT SIGN */
+	0x00bd, /* VULGAR FRACTION ONE HALF */
+	0x00bc, /* VULGAR FRACTION ONE QUARTER */
+	0x00a1, /* INVERTED EXCLAMATION MARK */
+	0x00ab, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+	0x00bb, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+	0x2591, /* LIGHT SHADE */
+	0x2592, /* MEDIUM SHADE */
+	0x2593, /* DARK SHADE */
+	0x2502, /* BOX DRAWINGS LIGHT VERTICAL */
+	0x2524, /* BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+	0x2561, /* BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE */
+	0x2562, /* BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE */
+	0x2556, /* BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE */
+	0x2555, /* BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE */
+	0x2563, /* BOX DRAWINGS DOUBLE VERTICAL AND LEFT */
+	0x2551, /* BOX DRAWINGS DOUBLE VERTICAL */
+	0x2557, /* BOX DRAWINGS DOUBLE DOWN AND LEFT */
+	0x255d, /* BOX DRAWINGS DOUBLE UP AND LEFT */
+	0x255c, /* BOX DRAWINGS UP DOUBLE AND LEFT SINGLE */
+	0x255b, /* BOX DRAWINGS UP SINGLE AND LEFT DOUBLE */
+	0x2510, /* BOX DRAWINGS LIGHT DOWN AND LEFT */
+	0x2514, /* BOX DRAWINGS LIGHT UP AND RIGHT */
+	0x2534, /* BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+	0x252c, /* BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+	0x251c, /* BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+	0x2500, /* BOX DRAWINGS LIGHT HORIZONTAL */
+	0x253c, /* BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+	0x255e, /* BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE */
+	0x255f, /* BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE */
+	0x255a, /* BOX DRAWINGS DOUBLE UP AND RIGHT */
+	0x2554, /* BOX DRAWINGS DOUBLE DOWN AND RIGHT */
+	0x2569, /* BOX DRAWINGS DOUBLE UP AND HORIZONTAL */
+	0x2566, /* BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL */
+	0x2560, /* BOX DRAWINGS DOUBLE VERTICAL AND RIGHT */
+	0x2550, /* BOX DRAWINGS DOUBLE HORIZONTAL */
+	0x256c, /* BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL */
+	0x2567, /* BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE */
+	0x2568, /* BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE */
+	0x2564, /* BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE */
+	0x2565, /* BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE */
+	0x2559, /* BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE */
+	0x2558, /* BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE */
+	0x2552, /* BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE */
+	0x2553, /* BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE */
+	0x256b, /* BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE */
+	0x256a, /* BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE */
+	0x2518, /* BOX DRAWINGS LIGHT UP AND LEFT */
+	0x250c, /* BOX DRAWINGS LIGHT DOWN AND RIGHT */
+	0x2588, /* FULL BLOCK */
+	0x2584, /* LOWER HALF BLOCK */
+	0x258c, /* LEFT HALF BLOCK */
+	0x2590, /* RIGHT HALF BLOCK */
+	0x2580, /* UPPER HALF BLOCK */
+	0x03b1, /* GREEK SMALL LETTER ALPHA */
+	0x00df, /* LATIN SMALL LETTER SHARP S */
+	0x0393, /* GREEK CAPITAL LETTER GAMMA */
+	0x03c0, /* GREEK SMALL LETTER PI */
+	0x03a3, /* GREEK CAPITAL LETTER SIGMA */
+	0x03c3, /* GREEK SMALL LETTER SIGMA */
+	0x00b5, /* MICRO SIGN */
+	0x03c4, /* GREEK SMALL LETTER TAU */
+	0x03a6, /* GREEK CAPITAL LETTER PHI */
+	0x0398, /* GREEK CAPITAL LETTER THETA */
+	0x03a9, /* GREEK CAPITAL LETTER OMEGA */
+	0x03b4, /* GREEK SMALL LETTER DELTA */
+	0x221e, /* INFINITY */
+	0x03c6, /* GREEK SMALL LETTER PHI */
+	0x03b5, /* GREEK SMALL LETTER EPSILON */
+	0x2229, /* INTERSECTION */
+	0x2261, /* IDENTICAL TO */
+	0x00b1, /* PLUS-MINUS SIGN */
+	0x2265, /* GREATER-THAN OR EQUAL TO */
+	0x2264, /* LESS-THAN OR EQUAL TO */
+	0x2320, /* TOP HALF INTEGRAL */
+	0x2321, /* BOTTOM HALF INTEGRAL */
+	0x00f7, /* DIVISION SIGN */
+	0x2248, /* ALMOST EQUAL TO */
+	0x00b0, /* DEGREE SIGN */
+	0x2219, /* BULLET OPERATOR */
+	0x00b7, /* MIDDLE DOT */
+	0x221a, /* SQUARE ROOT */
+	0x207f, /* SUPERSCRIPT LATIN SMALL LETTER N */
+	0x00b2, /* SUPERSCRIPT TWO */
+	0x25a0, /* BLACK SQUARE */
+	0x00a0, /* NO-BREAK SPACE */
+};
+
+/* DEC Special Graphic Character Set aka VT 100 graphics.
+ * Only the last 32 characters are significantly different from ASCII
+ * http://support.attachmate.com/techdocs/1184.html */
+static glyph_t dec_graphics_to_unicode[] = {
+	0x25c6, /* BLACK DIAMOND */
+	0x2592, /* MEDIUM SHADE */
+	0x0009, /* CHARACTER TABULATION */
+	0x000c, /* FORM FEED */
+	0x000d, /* CARRIAGE RETURN */
+	0x000a, /* LINE FEED */
+	0x00b0, /* DEGREE SIGN */
+	0x00b1, /* PLUS-MINUS SIGN */
+	0x000a, /* NEW LINE (=LINE FEED) */
+	0x000b, /* LINE TABULATION */
+	0x2518, /* BOX DRAWINGS LIGHT UP AND LEFT */
+	0x2510, /* BOX DRAWINGS LIGHT DOWN AND LEFT */
+	0x250c, /* BOX DRAWINGS LIGHT DOWN AND RIGHT */
+	0x2514, /* BOX DRAWINGS LIGHT UP AND RIGHT */
+	0x253c, /* BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+	0x00a0, /*_NO-BREAK SPACE */
+	0x00a0, /*_NO-BREAK SPACE */
+	0x2500, /* BOX DRAWINGS LIGHT HORIZONTAL */
+	0x00a0, /*_NO-BREAK SPACE */
+	0x00a0, /*_NO-BREAK SPACE */
+	0x251c, /* BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+	0x2524, /* BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+	0x2534, /* BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+	0x252c, /* BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+	0x2502, /* BOX DRAWINGS LIGHT VERTICAL */
+	0x2264, /* LESS-THAN OR EQUAL TO */
+	0x2265, /* GREATER-THAN OR EQUAL TO */
+	0x03c0, /* GREEK SMALL LETTER PI */
+	0x2260, /* NOT EQUAL TO */
+	0x00a3, /* POUND SIGN */
+	0x00b7, /* MIDDLE DOT */
+	0x00a0, /*_NO-BREAK SPACE */
+};
+
+/** Returns unicode codepoint of character according to selected graphics mode. */
+glyph_t
+get_unicode_codepoint(int ch)
+{
+	if (ch <= 0xFF) {
+		if (ch < 0x80) {
+			return ch;
+		} else if (iflags.IBMgraphics) {
+			return cp437_to_unicode[ch-0x80];
+		} else if (iflags.DECgraphics && ch >= 0xE0) {
+			return dec_graphics_to_unicode[ch-0xE0];
+		}
+	}
+	return ch;
+}
+
+/** Prints a Unicode codepoint as UTF-8 encoded byte sequence.
+ * Originally from Ray Chason's Unicode proof of concept patch. */
+int
+pututf8char(glyph_t c)
+{
+#ifdef UTF8_GLYPHS
+  if (c < 0x80) {
+    putchar(c);
+  } else if(c < 0x800) {
+    putchar(0xC0 | (c>>6));
+    putchar(0x80 | (c & 0x3F));
+  } else if (c < 0x10000) {
+    putchar(0xE0 | (c>>12));
+    putchar(0x80 | (c>>6 & 0x3F));
+    putchar(0x80 | (c & 0x3F));
+  } else if (c < 0x200000) {
+    putchar(0xF0 | (c>>18));
+    putchar(0x80 | (c>>12 & 0x3F));
+    putchar(0x80 | (c>>6 & 0x3F));
+    putchar(0x80 | (c & 0x3F));
+  }
+#else
+  putchar(c);
+#endif
+  return 0;
+}
+
+/*unicode.c*/
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/vault.c nethack-3.4.3-nao-osx/src/vault.c
--- nethack-3.4.3/src/vault.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/vault.c	2014-12-20 12:08:36.000000000 -0800
@@ -260,7 +260,7 @@ fnd:
 	}
 
 	stop_occupation();		/* if occupied, stop it *now* */
-	if (multi > 0) { nomul(0); unmul((char *)0); }
+	if (multi > 0) { nomul(0, NULL); unmul((char *)0); }
 	trycount = 5;
 	do {
 	    getlin("\"Hello stranger, who are you?\" -", buf);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/weapon.c nethack-3.4.3-nao-osx/src/weapon.c
--- nethack-3.4.3/src/weapon.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/weapon.c	2014-12-20 12:08:36.000000000 -0800
@@ -9,6 +9,10 @@
  */
 #include "hack.h"
 
+#ifdef DUMP_LOG
+STATIC_DCL int FDECL(enhance_skill, (boolean));
+#endif
+
 /* Categories whose names don't come from OBJ_NAME(objects[type])
  */
 #define PN_BARE_HANDED			(-1)	/* includes martial arts */
@@ -851,6 +855,23 @@ const static struct skill_range {
  */
 int
 enhance_weapon_skill()
+#ifdef DUMP_LOG
+{
+	return enhance_skill(FALSE);
+}
+
+void dump_weapon_skill()
+{
+	enhance_skill(TRUE);
+}
+
+int enhance_skill(boolean want_dump)
+/* This is the original enhance_weapon_skill() function slightly modified
+ * to write the skills to the dump file. I added the wrapper functions just
+ * because it looked like the easiest way to add a parameter to the
+ * function call. - Jukka Lahtinen, August 2001
+ */
+#endif
 {
     int pass, i, n, len, longest,
 	to_advance, eventually_advance, maxxed_cnt;
@@ -860,8 +881,15 @@ enhance_weapon_skill()
     anything any;
     winid win;
     boolean speedy = FALSE;
+#ifdef DUMP_LOG
+    char buf2[BUFSZ];
+    boolean logged;
+#endif
 
 #ifdef WIZARD
+#ifdef DUMP_LOG
+	if (!want_dump)
+#endif
 	if (wizard && yn("Advance skills without practice?") == 'y')
 	    speedy = TRUE;
 #endif
@@ -878,6 +906,11 @@ enhance_weapon_skill()
 		else if (peaked_skill(i)) maxxed_cnt++;
 	    }
 
+#ifdef DUMP_LOG
+	    if (want_dump)
+		dump("","Your skills at the end");
+	    else {
+#endif
 	    win = create_nhwindow(NHW_MENU);
 	    start_menu(win);
 
@@ -905,6 +938,9 @@ enhance_weapon_skill()
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			     "", MENU_UNSELECTED);
 	    }
+#ifdef DUMP_LOG
+	    } /* want_dump or not */
+#endif
 
 	    /* List the skills, making ones that could be advanced
 	       selectable.  List the miscellaneous skills first.
@@ -916,8 +952,26 @@ enhance_weapon_skill()
 		/* Print headings for skill types */
 		any.a_void = 0;
 		if (i == skill_ranges[pass].first)
+#ifdef DUMP_LOG
+		if (want_dump) {
+		    dump("  ",(char *)skill_ranges[pass].name);
+		    logged=FALSE;
+		} else
+#endif
 		    add_menu(win, NO_GLYPH, &any, 0, 0, iflags.menu_headings,
 			     skill_ranges[pass].name, MENU_UNSELECTED);
+#ifdef DUMP_LOG
+		if (want_dump) {
+		    if (P_SKILL(i) > P_UNSKILLED) {
+		 	Sprintf(buf2,"%-*s [%s]",
+			    longest, P_NAME(i),skill_level_name(i, buf));
+			dump("    ",buf2);
+			logged=TRUE;
+		    } else if (i == skill_ranges[pass].last && !logged) {
+			dump("    ","(none)");
+		    }
+               } else {
+#endif
 
 		if (P_RESTRICTED(i)) continue;
 		/*
@@ -962,6 +1016,9 @@ enhance_weapon_skill()
 		any.a_int = can_advance(i, speedy) ? i+1 : 0;
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			 buf, MENU_UNSELECTED);
+#ifdef DUMP_LOG
+		} /* !want_dump */
+#endif
 	    }
 
 	    Strcpy(buf, (to_advance > 0) ? "Pick a skill to advance:" :
@@ -971,6 +1028,12 @@ enhance_weapon_skill()
 		Sprintf(eos(buf), "  (%d slot%s available)",
 			u.weapon_slots, plur(u.weapon_slots));
 #endif
+#ifdef DUMP_LOG
+	    if (want_dump) {
+		dump("","");
+		n=0;
+	    } else {
+#endif
 	    end_menu(win, buf);
 	    n = select_menu(win, to_advance ? PICK_ONE : PICK_NONE, &selected);
 	    destroy_nhwindow(win);
@@ -987,6 +1050,9 @@ enhance_weapon_skill()
 		    }
 		}
 	    }
+#ifdef DUMP_LOG
+	    }
+#endif
 	} while (speedy && n > 0);
 	return 0;
 }
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/wield.c nethack-3.4.3-nao-osx/src/wield.c
--- nethack-3.4.3/src/wield.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/wield.c	2014-12-20 12:08:36.000000000 -0800
@@ -721,7 +721,7 @@ register int amount;
 		return(1);
 	}
 
-	if (amount < 0 && uwep->oartifact && restrict_name(uwep, ONAME(uwep))) {
+	if (amount < 0 && uwep->oartifact && restrict_name(uwep, ONAME(uwep), TRUE)) {
 	    if (!Blind)
 		Your("%s %s.", aobjnam(uwep, "faintly glow"), color);
 	    return(1);
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/windows.c nethack-3.4.3-nao-osx/src/windows.c
--- nethack-3.4.3/src/windows.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/windows.c	2014-12-20 12:08:36.000000000 -0800
@@ -6,6 +6,9 @@
 #ifdef TTY_GRAPHICS
 #include "wintty.h"
 #endif
+#ifdef CURSES_GRAPHICS
+extern struct window_procs curses_procs;
+#endif
 #ifdef X11_GRAPHICS
 /* cannot just blindly include winX.h without including all of X11 stuff */
 /* and must get the order of include files right.  Don't bother */
@@ -53,6 +56,9 @@ struct win_choices {
 #ifdef TTY_GRAPHICS
     { &tty_procs, win_tty_init },
 #endif
+#ifdef CURSES_GRAPHICS
+    { &curses_procs, 0 },
+#endif
 #ifdef X11_GRAPHICS
     { &X11_procs, win_X11_init },
 #endif
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/worm.c nethack-3.4.3-nao-osx/src/worm.c
--- nethack-3.4.3/src/worm.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/worm.c	2014-12-20 12:08:36.000000000 -0800
@@ -291,7 +291,7 @@ wormhitu(worm)
     register int wnum = worm->wormno;
     register struct wseg *seg;
 
-/*  if (!wnum) return;  bullet proofing */
+    if (!wnum) return; /* bullet proofing */
 
 /*  This does not work right now because mattacku() thinks that the head is
  *  out of range of the player.  We might try to kludge, and bring the head
@@ -303,6 +303,24 @@ wormhitu(worm)
 	    (void) mattacku(worm);
 }
 
+/*  cutoff()
+ *
+ *  Remove the tail of a worm and adjust the hp of the worm.
+ */
+void
+cutoff(worm, tail)
+    struct monst *worm;
+    struct wseg *tail;
+{
+  if (flags.mon_moving)
+    pline("Part of the tail of %s is cut off.", mon_nam(worm));
+  else
+    You("cut part of the tail off of %s.", mon_nam(worm));
+  toss_wsegs(tail, TRUE);
+  if (worm->mhp > 1) worm->mhp /= 2;
+}
+
+
 /*  cutworm()
  *
  *  Check for mon->wormno before calling this function!
@@ -368,17 +386,15 @@ cutworm(worm, x, y, weap)
 
     /* Sometimes the tail end dies. */
     if (rn2(3) || !(new_wnum = get_wormno())) {
-	if (flags.mon_moving)
-	    pline("Part of the tail of %s is cut off.", mon_nam(worm));
-	else
-	    You("cut part of the tail off of %s.", mon_nam(worm));
-	toss_wsegs(new_tail, TRUE);
-	if (worm->mhp > 1) worm->mhp /= 2;
+	cutoff(worm, new_tail);
 	return;
     }
 
     remove_monster(x, y);		/* clone_mon puts new head here */
-    new_worm = clone_mon(worm, x, y);
+    if (!(new_worm = clone_mon(worm, x, y))) {
+      cutoff(worm, new_tail);
+      return;
+    }
     new_worm->wormno = new_wnum;	/* affix new worm number */
 
     /* Devalue the monster level of both halves of the worm. */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/src/zap.c nethack-3.4.3-nao-osx/src/zap.c
--- nethack-3.4.3/src/zap.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/src/zap.c	2014-12-20 12:08:36.000000000 -0800
@@ -444,7 +444,7 @@ int locflags;	/* non-zero means get loca
 	    *xp = u.ux;
 	    *yp = u.uy;
 	    return TRUE;
-	} else if (mon->mx > 0 && (!mon->mburied || locflags)) {
+	} else if (mon && !DEADMONSTER(mon) && mon->mx > 0 && (!mon->mburied || locflags)) {
 	    *xp = mon->mx;
 	    *yp = mon->my;
 	    return TRUE;
@@ -669,8 +669,10 @@ register struct obj *obj;
 			    mtmp = christen_monst(mtmp, ONAME(obj));
 			/* flag the quest leader as alive. */
 			if (mtmp->data->msound == MS_LEADER || mtmp->m_id ==
-				quest_status.leader_m_id)
+			    quest_status.leader_m_id) {
+			    quest_status.leader_m_id = mtmp->m_id;
 			    quest_status.leader_is_dead = FALSE;
+			}
 		    }
 		}
 		if (mtmp) {
@@ -2467,7 +2469,7 @@ register struct	obj	*obj;
 	    } else if (u.dz) {
 		disclose = zap_updown(obj);
 	    } else {
-		(void) bhit(u.dx,u.dy, rn1(8,6),ZAPPED_WAND, bhitm,bhito, obj);
+		(void) bhit(u.dx,u.dy, rn1(8,6),ZAPPED_WAND, bhitm,bhito, obj, NULL);
 	    }
 	    /* give a clue if obj_zapped */
 	    if (obj_zapped)
@@ -2615,16 +2617,18 @@ register struct monst *mtmp;
  *  one is revealed for a weapon, but if not a weapon is left up to fhitm().
  */
 struct monst *
-bhit(ddx,ddy,range,weapon,fhitm,fhito,obj)
+bhit(ddx,ddy,range,weapon,fhitm,fhito,obj,obj_destroyed)
 register int ddx,ddy,range;		/* direction and range */
 int weapon;				/* see values in hack.h */
 int FDECL((*fhitm), (MONST_P, OBJ_P)),	/* fns called when mon/obj hit */
     FDECL((*fhito), (OBJ_P, OBJ_P));
 struct obj *obj;			/* object tossed/used */
+boolean *obj_destroyed;/* has object been deallocated? Pointer to boolean, may be NULL */
 {
 	struct monst *mtmp;
 	uchar typ;
 	boolean shopdoor = FALSE, point_blank = TRUE;
+	if (obj_destroyed) { *obj_destroyed = FALSE; }
 
 	if (weapon == KICKED_WEAPON) {
 	    /* object starts one square in front of player */
@@ -2668,6 +2672,7 @@ struct obj *obj;			/* object tossed/used
 		    hits_bars(&obj, x - ddx, y - ddy,
 			      point_blank ? 0 : !rn2(5), 1)) {
 		/* caveat: obj might now be null... */
+		if (obj == NULL && obj_destroyed) { *obj_destroyed = TRUE; }
 		bhitpos.x -= ddx;
 		bhitpos.y -= ddy;
 		break;
@@ -3436,7 +3441,7 @@ register int dx,dy;
 		miss(fltxt,mon);
 	    }
 	} else if (sx == u.ux && sy == u.uy && range >= 0) {
-	    nomul(0);
+	    nomul(0, NULL);
 #ifdef STEED
 	    if (u.usteed && !rn2(3) && !mon_reflects(u.usteed, (char *)0)) {
 		    mon = u.usteed;
@@ -3466,7 +3471,7 @@ register int dx,dy;
 		if (!Blind) Your(vision_clears);
 	    }
 	    stop_occupation();
-	    nomul(0);
+	    nomul(0, NULL);
 	}
 
 	if(!ZAP_POS(lev->typ) || (closed_door(sx, sy) && (range >= 0))) {
@@ -4093,6 +4098,7 @@ void
 makewish()
 {
 	char buf[BUFSZ];
+	char bufcpy[BUFSZ];
 	struct obj *otmp, nothing;
 	int tries = 0;
 
@@ -4107,6 +4113,7 @@ retry:
 	 *  has been denied.  Wishing for "nothing" requires a separate
 	 *  value to remain distinct.
 	 */
+	strcpy(bufcpy, buf);
 	otmp = readobjnam(buf, &nothing, TRUE);
 	if (!otmp) {
 	    pline("Nothing fitting that description exists in the game.");
@@ -4124,6 +4131,13 @@ retry:
 	u.uconduct.wishes++;
 
 	if (otmp != &zeroobj) {
+
+	    if (!flags.debug) {
+		char llog[BUFSZ+20];
+		Sprintf(llog, "wished for \"%s\"", mungspaces(bufcpy));
+		livelog_write_string(llog);
+	    }
+
 	    /* The(aobjnam()) is safe since otmp is unidentified -dlc */
 	    (void) hold_another_object(otmp, u.uswallow ?
 				       "Oops!  %s out of your reach!" :
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/Makefile.doc nethack-3.4.3-nao-osx/sys/unix/Makefile.doc
--- nethack-3.4.3/sys/unix/Makefile.doc	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/Makefile.doc	2014-12-24 13:41:32.000000000 -0800
@@ -41,7 +41,7 @@ Guidebook.dvi:	Guidebook.tex
 
 
 GAME	= nethack
-MANDIR	= /usr/man/man6
+MANDIR	= /usr/share/man/man6
 MANEXT	= 6
 
 # manual installation for most BSD-style systems
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/Makefile.src nethack-3.4.3-nao-osx/sys/unix/Makefile.src
--- nethack-3.4.3/sys/unix/Makefile.src	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/Makefile.src	2014-12-20 13:00:35.000000000 -0800
@@ -44,7 +44,7 @@ LINK=$(CC)
 # for UNIX systems
 SYSSRC = ../sys/share/ioctl.c ../sys/share/unixtty.c ../sys/unix/unixmain.c \
 	../sys/unix/unixunix.c ../sys/unix/unixres.c
-SYSOBJ = ioctl.o unixmain.o unixtty.o unixunix.o unixres.o
+SYSOBJ = ioctl.o unixmain.o unixtty.o unixunix.o unixres.o recover.o
 #
 # for Systos
 # SYSSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
@@ -62,7 +62,7 @@ SYSOBJ = ioctl.o unixmain.o unixtty.o un
 #		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
 #		-traditional in CFLAGS
 # CC = gcc
-#
+CC = clang
 #	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
 #
 # CC = gcc -ansi -D_BULL_SOURCE -D_XOPEN_SOURCE -D_POSIX_SOURCE
@@ -151,14 +151,14 @@ GNOMEINC=-I/usr/lib/glib/include -I/usr/
 # flags for debugging:
 # CFLAGS = -g -I../include
 
-CFLAGS = -O -I../include
-LFLAGS = 
+CFLAGS = -g -O -I../include
+LFLAGS =
 
 # The Qt and Be window systems are written in C++, while the rest of
 # NetHack is standard C.  If using Qt, uncomment the LINK line here to get
 # the C++ libraries linked in.
 CXXFLAGS = $(CFLAGS) -I. -I$(QTDIR)/include
-CXX=g++
+CXX=clang++
 #LINK=g++
 #	For cross-compiling, eg. with gcc on Linux (see also CC further up):
 #CXX=arm-linux-g++
@@ -172,7 +172,15 @@ CXX=g++
 # files for a straight tty port using no native windowing system
 WINTTYSRC = ../win/tty/getline.c ../win/tty/termcap.c ../win/tty/topl.c \
 	../win/tty/wintty.c
-WINTTYOBJ = getline.o termcap.o topl.o wintty.o
+WINTTYOBJ = getline.o termcap.o topl.o wintty.o tile.o
+# Files for curses interface
+WINCURSESSRC = ../win/curses/cursmain.c ../win/curses/curswins.c \
+	../win/curses/cursmisc.c ../win/curses/cursdial.c \
+	../win/curses/cursstat.c ../win/curses/cursinit.c \
+	../win/curses/cursmesg.c
+WINCURSESOBJ = cursmain.o curswins.o cursmisc.o cursdial.o cursstat.o \
+	cursinit.o cursmesg.o
+#
 #
 # files for an X11 port
 # (tile.c is a generated source file)
@@ -214,8 +222,8 @@ WINBEOBJ =
 
 #
 #
-WINSRC = $(WINTTYSRC)
-WINOBJ = $(WINTTYOBJ)
+WINSRC = $(WINTTYSRC) $(WINCURSESSRC)
+WINOBJ = $(WINTTYOBJ) $(WINCURSESOBJ)
 
 # on some systems the termcap library is in -ltermcap or -lcurses
 # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
@@ -230,8 +238,8 @@ WINOBJ = $(WINTTYOBJ)
 # WINTTYLIB = -ltermcap
 # WINTTYLIB = -lcurses
 # WINTTYLIB = -lcurses16
-# WINTTYLIB = -lncurses
-WINTTYLIB = -ltermlib
+WINTTYLIB = -lncurses
+# WINTTYLIB = -ltermlib
 #
 # libraries for X11
 # If USE_XPM is defined in config.h, you will also need -lXpm here.
@@ -326,7 +334,7 @@ HACKCSRC = allmain.c alloc.c apply.c art
 	   rnd.c role.c rumors.c save.c shk.c shknam.c sit.c sounds.c sp_lev.c \
 	   spell.c steal.c steed.c teleport.c timeout.c topten.c track.c trap.c \
 	   u_init.c uhitm.c vault.c version.c vision.c weapon.c were.c wield.c \
-	   windows.c wizard.c worm.c worn.c write.c zap.c
+	   windows.c wizard.c worm.c worn.c write.c zap.c unicode.c
 
 # all operating-system-dependent .c (for dependencies and such)
 SYSCSRC = ../sys/atari/tos.c ../sys/share/pcmain.c ../sys/share/pcsys.c \
@@ -383,7 +391,7 @@ HOBJ = $(FIRSTOBJ) allmain.o alloc.o app
 	role.o rumors.o save.o shk.o shknam.o sit.o sounds.o sp_lev.o spell.o \
 	steal.o steed.o teleport.o timeout.o topten.o track.o trap.o u_init.o \
 	uhitm.o vault.o vision.o vis_tab.o weapon.o were.o wield.o windows.o \
-	wizard.o worm.o worn.o write.o zap.o \
+	wizard.o worm.o worn.o write.o zap.o unicode.o \
 	$(RANDOBJ) $(SYSOBJ) $(WINOBJ) version.o
 # the .o files from the HACKCSRC, SYSSRC, and WINSRC lists
 
@@ -605,6 +613,28 @@ topl.o: ../win/tty/topl.c $(HACK_H) ../i
 wintty.o: ../win/tty/wintty.c $(HACK_H) ../include/dlb.h \
 		../include/patchlevel.h ../include/tcap.h
 	$(CC) $(CFLAGS) -c ../win/tty/wintty.c
+recover.o: ../util/recover.c $(HACK_H)
+	$(CC) $(CFLAGS) -DNO_MAIN -c ../util/recover.c
+cursmain.o: ../win/curses/cursmain.c $(HACK_H) ../include/wincurs.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmain.c
+curswins.o: ../win/curses/curswins.c $(HACK_H) ../include/func_tab.h \
+		../include/wincurs.h ../win/curses/curswins.h
+	$(CC) $(CFLAGS) -c ../win/curses/curswins.c
+cursmisc.o: ../win/curses/cursmisc.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursmisc.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmisc.c
+cursdial.o: ../win/curses/cursdial.c $(HACK_H) ../include/func_tab.h \
+		../include/wincurs.h ../win/curses/cursdial.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursdial.c
+cursstat.o: ../win/curses/cursstat.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursstat.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursstat.c
+cursinit.o: ../win/curses/cursinit.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursinit.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursinit.c
+cursmesg.o: ../win/curses/cursmesg.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursmesg.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmesg.c
 Window.o: ../win/X11/Window.c ../include/xwindowp.h ../include/xwindow.h \
 		$(CONFIG_H)
 	$(CC) $(CFLAGS) -c ../win/X11/Window.c
@@ -797,6 +827,7 @@ track.o: track.c $(HACK_H)
 trap.o: trap.c $(HACK_H)
 u_init.o: u_init.c $(HACK_H)
 uhitm.o: uhitm.c $(HACK_H)
+unicode.o: unicode.c $(HACK_H)
 vault.o: vault.c $(HACK_H) ../include/vault.h
 version.o: version.c $(HACK_H) ../include/date.h ../include/patchlevel.h
 vision.o: vision.c $(HACK_H) ../include/vis_tab.h
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/Makefile.top nethack-3.4.3-nao-osx/sys/unix/Makefile.top
--- nethack-3.4.3/sys/unix/Makefile.top	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/Makefile.top	2014-12-24 11:21:20.000000000 -0800
@@ -14,18 +14,17 @@
 # MAKE = make
 
 # make NetHack
-PREFIX	 = /usr
+PREFIX	 = /opt
 GAME     = nethack
-# GAME     = nethack.prg
-GAMEUID  = games
-GAMEGRP  = bin
+GAMEUID  = root
+GAMEGRP  = admin
 
 # Permissions - some places use setgid instead of setuid, for instance
 # See also the option "SECURE" in include/config.h
-GAMEPERM = 04755
-FILEPERM = 0644
+GAMEPERM = 0755
+FILEPERM = 0664
 EXEPERM  = 0755
-DIRPERM  = 0755
+DIRPERM  = 0775
 
 # GAMEDIR also appears in config.h as "HACKDIR".
 # VARDIR may also appear in unixconf.h as "VAR_PLAYGROUND" else GAMEDIR
@@ -35,9 +34,9 @@ DIRPERM  = 0755
 # therefore there should not be anything in GAMEDIR that you want to keep
 # (if there is, you'll have to do the installation by hand or modify the
 # instructions)
-GAMEDIR  = $(PREFIX)/games/lib/$(GAME)dir
-VARDIR  = $(GAMEDIR)
-SHELLDIR = $(PREFIX)/games
+GAMEDIR  = $(PREFIX)/nethack
+VARDIR  = $(GAMEDIR)/var
+#SHELLDIR = $(PREFIX)/games
 
 # per discussion in Install.X11 and Install.Qt
 VARDATND = 
@@ -185,19 +184,19 @@ dofiles:
 	$(MAKE) dofiles-$${target-nodlb}
 	cp src/$(GAME) $(GAMEDIR)
 	cp util/recover $(GAMEDIR)
-	-rm -f $(SHELLDIR)/$(GAME)
-	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
-		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
-		< sys/unix/nethack.sh \
-		> $(SHELLDIR)/$(GAME)
+#	-rm -f $(SHELLDIR)/$(GAME)
+#	sed -e 's;/usr/games/lib/nethackdir;$(GAMEDIR);' \
+#		-e 's;HACKDIR/nethack;HACKDIR/$(GAME);' \
+#		< sys/unix/nethack.sh \
+#		> $(SHELLDIR)/$(GAME)
 # set up their permissions
 	-( cd $(GAMEDIR) ; $(CHOWN) $(GAMEUID) $(GAME) recover ; \
 			$(CHGRP) $(GAMEGRP) $(GAME) recover )
 	chmod $(GAMEPERM) $(GAMEDIR)/$(GAME)
 	chmod $(EXEPERM) $(GAMEDIR)/recover
-	-$(CHOWN) $(GAMEUID) $(SHELLDIR)/$(GAME)
-	$(CHGRP) $(GAMEGRP) $(SHELLDIR)/$(GAME)
-	chmod $(EXEPERM) $(SHELLDIR)/$(GAME)
+#	-$(CHOWN) $(GAMEUID) $(SHELLDIR)/$(GAME)
+#	$(CHGRP) $(GAMEGRP) $(SHELLDIR)/$(GAME)
+#	chmod $(EXEPERM) $(SHELLDIR)/$(GAME)
 
 dofiles-dlb: check-dlb
 	( cd dat ; cp nhdat $(DATNODLB) $(GAMEDIR) )
@@ -226,14 +225,14 @@ update: $(GAME) recover $(VARDAT) dungeo
 # touch time-sensitive files
 	-touch -c $(VARDIR)/bones* $(VARDIR)/?lock* $(VARDIR)/wizard*
 	-touch -c $(VARDIR)/save/*
-	touch $(VARDIR)/perm $(VARDIR)/record
+	touch $(VARDIR)/perm $(VARDIR)/record $(VARDIR)/livelog
 # and a reminder
 	@echo You may also want to install the man pages via the doc Makefile.
 
 install: $(GAME) recover $(VARDAT) dungeon spec_levs
 # set up the directories
 # not all mkdirs have -p; those that don't will create a -p directory
-	-mkdir -p $(SHELLDIR)
+#	-mkdir -p $(SHELLDIR)
 	-rm -rf $(GAMEDIR) $(VARDIR)
 	-mkdir -p $(GAMEDIR) $(VARDIR) $(VARDIR)/save
 	-rmdir ./-p
@@ -243,10 +242,10 @@ install: $(GAME) recover $(VARDAT) dunge
 # set up the game files
 	( $(MAKE) dofiles )
 # set up some additional files
-	touch $(VARDIR)/perm $(VARDIR)/record $(VARDIR)/logfile
-	-( cd $(VARDIR) ; $(CHOWN) $(GAMEUID) perm record logfile ; \
-			$(CHGRP) $(GAMEGRP) perm record logfile ; \
-			chmod $(FILEPERM) perm record logfile )
+	touch $(VARDIR)/perm $(VARDIR)/record $(VARDIR)/logfile $(VARDIR)/xlogfile $(VARDIR)/livelog
+	-( cd $(VARDIR) ; $(CHOWN) $(GAMEUID) perm record logfile xlogfile livelog ; \
+			$(CHGRP) $(GAMEGRP) perm record logfile xlogfile livelog ; \
+			chmod $(FILEPERM) perm record logfile xlogfile livelog )
 # and a reminder
 	@echo You may also want to reinstall the man pages via the doc Makefile.
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/Makefile.utl nethack-3.4.3-nao-osx/sys/unix/Makefile.utl
--- nethack-3.4.3/sys/unix/Makefile.utl	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/Makefile.utl	2014-12-20 12:08:36.000000000 -0800
@@ -101,11 +101,11 @@ OBJDIR = ../src
 
 # yacc/lex programs to use to generate *_comp.h, *_lex.c, and *_yacc.c.
 # if, instead of yacc/lex you have bison/flex, comment/uncomment the following.
-YACC     = yacc
-LEX      = lex
-# YACC     = bison -y
+# YACC     = yacc
+# LEX      = lex
+YACC     = bison -y
 # YACC     = byacc
-# LEX      = flex
+LEX      = flex
  
 # these are the names of the output files from YACC/LEX. Under MS-DOS
 # and similar systems, they may differ
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/unixmain.c nethack-3.4.3-nao-osx/sys/unix/unixmain.c
--- nethack-3.4.3/sys/unix/unixmain.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/unixmain.c	2014-12-20 12:08:36.000000000 -0800
@@ -54,7 +54,9 @@ char *argv[];
 	register char *dir;
 #endif
 	boolean exact_username;
-
+#ifdef SIMPLE_MAIL
+	char* e_simple = NULL;
+#endif
 #if defined(__APPLE__)
 	/* special hack to change working directory to a resource fork when
 	   running from finder --sam */
@@ -84,6 +86,12 @@ char *argv[];
 	}
 #endif
 
+#ifdef SIMPLE_MAIL
+	/* figure this out early */
+	e_simple = nh_getenv("SIMPLEMAIL");
+	iflags.simplemail = (e_simple ? 1 : 0);
+#endif
+
 	hname = argv[0];
 	hackpid = getpid();
 	(void) umask(0777 & ~FCMASK);
@@ -163,10 +171,6 @@ char *argv[];
 	 * It seems you really want to play.
 	 */
 	u.uhp = 1;	/* prevent RIP on early quits */
-	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
-#ifdef SIGXCPU
-	(void) signal(SIGXCPU, (SIG_RET_TYPE) hangup);
-#endif
 
 	process_options(argc, argv);	/* command line options */
 
@@ -182,8 +186,8 @@ char *argv[];
 		Strcpy(plname, "wizard");
 	else
 #endif
-	if(!*plname || !strncmp(plname, "player", 4)
-		    || !strncmp(plname, "games", 4)) {
+	if(!*plname /*|| !strncmp(plname, "player", 4)
+		      || !strncmp(plname, "games", 4)*/) {
 		askname();
 	} else if (exact_username) {
 		/* guard against user names with hyphens in them */
@@ -205,6 +209,7 @@ char *argv[];
 		 */
 		(void) signal(SIGQUIT,SIG_IGN);
 		(void) signal(SIGINT,SIG_IGN);
+		(void) signal(SIGHUP,SIG_IGN);
 		if(!locknum)
 			Sprintf(lock, "%d%s", (int)getuid(), plname);
 		getlock();
@@ -215,6 +220,11 @@ char *argv[];
 	}
 #endif /* WIZARD */
 
+	(void) signal(SIGHUP, (SIG_RET_TYPE) hangup);
+#ifdef SIGXCPU
+	(void) signal(SIGXCPU, (SIG_RET_TYPE) hangup);
+#endif
+
 	dlb_init();	/* must be before newgame() */
 
 	/*
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/sys/unix/unixunix.c nethack-3.4.3-nao-osx/sys/unix/unixunix.c
--- nethack-3.4.3/sys/unix/unixunix.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/sys/unix/unixunix.c	2014-12-20 12:08:36.000000000 -0800
@@ -8,6 +8,7 @@
 
 #include <errno.h>
 #include <sys/stat.h>
+#include <limits.h>
 #if defined(NO_FILE_LINKS) || defined(SUNOS4) || defined(POSIX_TYPES)
 #include <fcntl.h>
 #endif
@@ -26,6 +27,8 @@ extern void NDECL(linux_mapoff);
 extern int errno;
 #endif
 
+extern int FDECL(restore_savefile, (char *, const char *));
+
 static struct stat buf;
 
 /* see whether we should throw away this xlock file */
@@ -150,24 +153,42 @@ getlock()
 		(void) close(fd);
 
 		if(iflags.window_inited) {
-		    c = yn("There is already a game in progress under your name.  Destroy old game?");
+		    c = yn_function("There is already a game in progress under your name.  Destroy old game [y], Recover it [r], Cancel [n] ?", "ynr", 'n');
 		} else {
-		    (void) printf("\nThere is already a game in progress under your name.");
-		    (void) printf("  Destroy old game? [yn] ");
-		    (void) fflush(stdout);
-		    c = getchar();
-		    (void) putchar(c);
+		    (void) printf("\nThere is already a game in progress under your name. Do what?\n");
+		    (void) printf("\n  y - Destroy old game?");
+		    (void) printf("\n  r - Try to recover it?");
+		    (void) printf("\n  n - Cancel");
+		    (void) printf("\n\n  => ");
 		    (void) fflush(stdout);
-		    while (getchar() != '\n') ; /* eat rest of line and newline */
+		    do {
+			c = getchar();
+		    } while (!index("rRyYnN", c) && c != -1);
+		    (void) printf("\e[7A"); /* cursor up 7 */
+		    (void) printf("\e[J"); /* clear from cursor down */
 		}
-		if(c == 'y' || c == 'Y')
+		if (c == 'r' || c == 'R') {
+		    if (restore_savefile(lock, fqn_prefix[SAVEPREFIX]) == 0) {
+			const char *msg = "Automatical recovery of save file successful! "
+			    "Press any key to continue ...\n";
+			fflush(stdout);
+			if (iflags.window_inited) {
+			    pline("%s", msg);
+			} else {
+			    printf("\n\n%s", msg);
+			    fflush(stdout);
+			    c = getchar();
+			}
+			goto gotlock;
+		    }
+		} else if (c == 'y' || c == 'Y') {
 			if(eraseoldlocks())
 				goto gotlock;
 			else {
 				unlock_file(HLOCK);
 				error("Couldn't destroy old game.");
 			}
-		else {
+		} else {
 			unlock_file(HLOCK);
 			error("%s", "");
 		}
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/util/makedefs.c nethack-3.4.3-nao-osx/util/makedefs.c
--- nethack-3.4.3/util/makedefs.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/util/makedefs.c	2014-12-20 12:08:36.000000000 -0800
@@ -652,6 +652,9 @@ static const char *build_opts[] = {
 #ifdef WIZARD
 		"debug mode",
 #endif
+#ifdef REALTIME_ON_BOTL
+                "elapsed time on status line",
+#endif
 #ifdef ELBERETH
 		"Elbereth",
 #endif
@@ -676,9 +679,19 @@ static const char *build_opts[] = {
 #ifdef LOGFILE
 		"log file",
 #endif
+#ifdef XLOGFILE
+                "extended log file",
+#endif
 #ifdef MAIL
 		"mail daemon",
 #endif
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+		"menu colors via regular expressions",
+# else
+		"menu colors via pmatch",
+# endif
+#endif
 #ifdef GNUDOS
 		"MSDOS protected mode",
 #endif
@@ -771,9 +784,33 @@ static const char *build_opts[] = {
 #ifdef WALLIFIED_MAZE
 		"walled mazes",
 #endif
+#ifdef WIN_EDGE
+		"win_edge",
+#endif
 #ifdef ZEROCOMP
 		"zero-compressed save files",
 #endif
+#ifdef RECORD_TURNS
+                "record turns in xlogfile",
+#endif
+#ifdef RECORD_CONDUCT
+                "record conduct in xlogfile",
+#endif
+#ifdef RECORD_ACHIEVE
+                "record major achievements in xlogfile",
+#endif
+#ifdef RECORD_REALTIME
+                "record real time in xlogfile",
+#endif
+#ifdef RECORD_START_END_TIME
+                "record starting and ending time in xlogfile",
+#endif
+#ifdef RECORD_GENDER0
+                "record initial gender in xlogfile",
+#endif
+#ifdef RECORD_ALIGN0
+                "record initial alignment in xlogfile",
+#endif
 		save_bones_compat_buf,
 		"basic NetHack features"
 	};
@@ -782,6 +819,9 @@ static const char *window_opts[] = {
 #ifdef TTY_GRAPHICS
 		"traditional tty-based graphics",
 #endif
+#ifdef CURSES_GRAPHICS
+        "curses",
+#endif
 #ifdef X11_GRAPHICS
 		"X11",
 #endif
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/util/recover.c nethack-3.4.3-nao-osx/util/recover.c
--- nethack-3.4.3/util/recover.c	2003-12-07 15:39:13.000000000 -0800
+++ nethack-3.4.3-nao-osx/util/recover.c	2014-12-20 12:08:36.000000000 -0800
@@ -21,10 +21,10 @@ extern int FDECL(vms_creat, (const char 
 extern int FDECL(vms_open, (const char *,int,unsigned));
 #endif	/* VMS */
 
-int FDECL(restore_savefile, (char *));
-void FDECL(set_levelfile_name, (int));
-int FDECL(open_levelfile, (int));
-int NDECL(create_savefile);
+int FDECL(restore_savefile, (char *, const char *));
+static void FDECL(set_levelfile_name, (int));
+static int FDECL(open_levelfile, (int, const char *));
+static int FDECL(create_savefile, (const char *));
 void FDECL(copy_bytes, (int,int));
 
 #ifndef WIN_CE
@@ -59,7 +59,7 @@ extern unsigned _stklen = STKSIZ;
 #endif
 char savename[SAVESIZE]; /* holds relative path of save file from playground */
 
-
+#ifndef NO_MAIN
 int
 main(argc, argv)
 int argc;
@@ -129,7 +129,7 @@ char *argv[];
 	}
 
 	while (argc > argno) {
-		if (restore_savefile(argv[argno]) == 0)
+	    if (restore_savefile(argv[argno], dir) == 0)
 		    Fprintf(stderr, "recovered \"%s\" to %s\n",
 			    argv[argno], savename);
 		argno++;
@@ -141,10 +141,11 @@ char *argv[];
 	/*NOTREACHED*/
 	return 0;
 }
+#endif /* !NO_MAIN */
 
 static char lock[256];
 
-void
+static void
 set_levelfile_name(lev)
 int lev;
 {
@@ -158,30 +159,38 @@ int lev;
 #endif
 }
 
-int
-open_levelfile(lev)
+static int
+open_levelfile(lev, directory)
 int lev;
+const char *directory;
 {
 	int fd;
-
+	char levelfile[BUFSIZ];
 	set_levelfile_name(lev);
+	if (directory) {
+	    snprintf(levelfile, BUFSIZ, "%s%s", directory, lock);
+	} else {
+	    strcpy(levelfile, lock);
+	}
 #if defined(MICRO) || defined(WIN32) || defined(MSDOS)
-	fd = open(lock, O_RDONLY | O_BINARY);
+	fd = open(levelfile, O_RDONLY | O_BINARY);
 #else
-	fd = open(lock, O_RDONLY, 0);
+	fd = open(levelfile, O_RDONLY, 0);
 #endif
 	return fd;
 }
 
-int
-create_savefile()
+static int
+create_savefile(directory)
+const char *directory;
 {
 	int fd;
-
+	char savefile[BUFSIZ];
+	sprintf(savefile, "%s/%s", directory, savename);
 #if defined(MICRO) || defined(WIN32) || defined(MSDOS)
-	fd = open(savename, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
+	fd = open(savefile, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, FCMASK);
 #else
-	fd = creat(savename, FCMASK);
+	fd = creat(savefile, FCMASK);
 #endif
 	return fd;
 }
@@ -204,8 +213,9 @@ int ifd, ofd;
 }
 
 int
-restore_savefile(basename)
+restore_savefile(basename, directory)
 char *basename;
+const char *directory;
 {
 	int gfd, lfd, sfd;
 	int lev, savelev, hpid;
@@ -218,8 +228,9 @@ char *basename;
 	 *	name of save file nethack would have created
 	 *	and game state
 	 */
+
 	(void) strcpy(lock, basename);
-	gfd = open_levelfile(0);
+	gfd = open_levelfile(0, directory);
 	if (gfd < 0) {
 #if defined(WIN32) && !defined(WIN_CE)
  	    if(errno == EACCES) {
@@ -264,14 +275,14 @@ char *basename;
 	 *	(non-level-based) game state
 	 *	other levels
 	 */
-	sfd = create_savefile();
+	sfd = create_savefile(directory);
 	if (sfd < 0) {
 	    Fprintf(stderr, "Cannot create savefile %s.\n", savename);
 	    Close(gfd);
 	    return(-1);
 	}
 
-	lfd = open_levelfile(savelev);
+	lfd = open_levelfile(savelev, directory);
 	if (lfd < 0) {
 	    Fprintf(stderr, "Cannot open level of save for %s.\n", basename);
 	    Close(gfd);
@@ -301,7 +312,7 @@ char *basename;
 		 * maximum level number (for the endlevel) must be < 256
 		 */
 		if (lev != savelev) {
-			lfd = open_levelfile(lev);
+		    lfd = open_levelfile(lev, directory);
 			if (lfd >= 0) {
 				/* any or all of these may not exist */
 				levc = (xchar) lev;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursdial.c nethack-3.4.3-nao-osx/win/curses/cursdial.c
--- nethack-3.4.3/win/curses/cursdial.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursdial.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,1614 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursdial.h"
+#include "func_tab.h"
+#include <ctype.h>
+
+/* Dialog windows for curses interface */
+
+
+/* Private declarations */
+
+typedef struct nhmi
+{
+    winid wid;  /* NetHack window id */
+    anything identifier; /* Value returned if item selected */
+    CHAR_P accelerator;  /* Character used to select item from menu */
+    CHAR_P group_accel; /* Group accelerator for menu item, if any */
+    int attr;  /* Text attributes for item */
+    const char *str;  /* Text of menu item */
+    BOOLEAN_P presel; /* Whether menu item should be preselected */
+    boolean selected;   /* Whether item is currently selected */
+    int page_num;   /* Display page number for entry */
+    int line_num;   /* Line number on page where entry begins */
+    int num_lines;  /* Number of lines entry uses on page */
+    int count;      /* Count for selected item */
+    struct nhmi *prev_item;    /* Pointer to previous entry */
+    struct nhmi *next_item;    /* Pointer to next entry */
+} nhmenu_item;
+
+typedef struct nhm
+{
+    winid wid;  /* NetHack window id */
+    const char *prompt;  /* Menu prompt text */
+    nhmenu_item *entries;   /* Menu entries */
+    int num_entries;          /* Number of menu entries */
+    int num_pages;            /* Number of display pages for entry */
+    int height;               /* Window height of menu */
+    int width;                /* Window width of menu */
+    boolean reuse_accels;     /* Non-unique accelerators per page */
+    struct nhm *prev_menu;    /* Pointer to previous entry */
+    struct nhm *next_menu;    /* Pointer to next entry */
+} nhmenu;
+
+typedef enum menu_op_type
+{
+    SELECT,
+    DESELECT,
+    INVERT
+} menu_op;
+
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
+static nhmenu *get_menu(winid wid);
+
+static char menu_get_accel(boolean first);
+
+static void menu_determine_pages(nhmenu *menu);
+
+static boolean menu_is_multipage(nhmenu *menu, int width, int height);
+
+static void menu_win_size(nhmenu *menu);
+
+static void menu_display_page(nhmenu *menu, WINDOW *win, int page_num);
+
+static int menu_get_selections(WINDOW *win, nhmenu *menu, int how);
+
+static void menu_select_deselect(WINDOW *win, nhmenu_item *item, menu_op operation);
+
+static int menu_operation(WINDOW *win, nhmenu *menu, menu_op operation,
+ int page_num);
+
+static void menu_clear_selections(nhmenu *menu);
+
+static boolean get_menu_coloring(char *str, int *color, int *attr);
+
+static int menu_max_height(void);
+
+static nhmenu *nhmenus = NULL;  /* NetHack menu array */
+
+
+/* Get a line of text from the player, such as asking for a character name or a wish */
+
+void curses_line_input_dialog(const char *prompt, char *answer, int buffer)
+{
+    int map_height, map_width, maxwidth, remaining_buf, winx, winy, count;
+    WINDOW *askwin, *bwin;
+    char input[buffer];
+    char *tmpstr;
+    int prompt_width = strlen(prompt) + buffer + 1;
+    int prompt_height = 1;
+    int height = prompt_height;
+
+    maxwidth = term_cols - 2;
+
+    if (iflags.window_inited)
+    {
+        curses_get_window_size(MAP_WIN, &map_height, &map_width);
+        if ((prompt_width + 2) > map_width)
+            maxwidth = map_width - 2;
+    }
+    
+    if (prompt_width > maxwidth)
+    {
+        prompt_height = curses_num_lines(prompt, maxwidth);
+        height = prompt_height;
+        prompt_width = maxwidth;
+        tmpstr = curses_break_str(prompt, maxwidth, prompt_height);
+        remaining_buf = buffer - (strlen(tmpstr) - 1);
+        if (remaining_buf > 0 )
+        {
+            height += (remaining_buf / prompt_width);
+            if ((remaining_buf % prompt_width) > 0)
+            {
+                height++;
+            }
+        }
+    }
+    
+    if (iflags.window_inited)
+    {
+        bwin = curses_create_window(prompt_width, height, UP);
+        wrefresh(bwin);
+        getbegyx(bwin, winy, winx);
+        askwin = newwin(height, prompt_width, winy + 1, winx + 1);
+    }
+    else
+    {
+        bwin = curses_create_window(prompt_width, height, CENTER);
+        wrefresh(bwin);
+        getbegyx(bwin, winy, winx);
+        askwin = newwin(height, prompt_width, winy + 1, winx + 1);
+    }
+    for (count = 0; count < prompt_height; count++)
+    {
+        tmpstr = curses_break_str(prompt, maxwidth, count + 1);
+        if (count == (prompt_height - 1))    /* Last line */
+        {
+            mvwprintw(askwin, count, 0, "%s ", tmpstr);
+        }
+        else
+        {
+            mvwaddstr(askwin, count, 0, tmpstr);
+        }
+        free(tmpstr);
+    }
+    
+    echo();
+    curs_set(1);
+    wgetnstr(askwin, input, buffer-1);
+    curs_set(0);
+    strcpy(answer, input);
+    werase(bwin);
+    delwin(bwin);
+    curses_destroy_win(askwin);
+    noecho();
+}
+
+
+/* Get a single character response from the player, such as a y/n prompt */
+
+int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def)
+{
+    WINDOW *askwin = NULL;
+    int answer, count, maxwidth, map_height, map_width;
+    char *linestr;
+    char askstr[BUFSZ + QBUFSZ];
+    char choicestr[QBUFSZ];
+    int prompt_width = strlen(prompt);
+    int prompt_height = 1;
+    boolean any_choice = FALSE;
+    boolean accept_count = FALSE;
+
+    if (invent || (moves > 1))
+    {
+        curses_get_window_size(MAP_WIN, &map_height, &map_width);
+    }
+    else
+    {
+        map_height = term_rows;
+        map_width = term_cols;
+    }
+    
+    maxwidth = map_width - 2;
+    
+    if (choices != NULL)
+    {
+        for (count = 0; choices[count] != '\0'; count++)
+        {
+            if (choices[count] == '#')   /* Accept a count */
+            {
+                accept_count = TRUE;
+            }
+        }
+        choicestr[0] = ' ';
+        choicestr[1] = '[';
+        for (count = 0; choices[count] != '\0'; count++)
+        {
+            if (choices[count] == DOESCAPE)   /* Escape */
+            {
+                break;
+            }
+            choicestr[count + 2] = choices[count];
+        }
+        choicestr[count + 2] = ']';
+        if (((def >= 'A') && (def <= 'Z')) || ((def >= 'a') && (def <= 'z')))
+        {
+            choicestr[count + 3] = ' ';
+            choicestr[count + 4] = '(';
+            choicestr[count + 5] = def;
+            choicestr[count + 6] = ')';
+            choicestr[count + 7] = '\0';
+        }
+        else    /* No usable default choice */
+        {
+            choicestr[count + 3] = '\0';
+            def = '\0'; /* Mark as no default */
+        }
+        strcpy(askstr, prompt);
+        strcat(askstr, choicestr);
+    }
+    else
+    {
+        strcpy(askstr, prompt);
+        any_choice = TRUE;
+    }
+    
+    prompt_width = strlen(askstr);
+    
+    if ((prompt_width + 2) > maxwidth)
+    {
+        prompt_height = curses_num_lines(askstr, maxwidth);
+        prompt_width = map_width - 2;
+    }
+
+    if (iflags.wc_popup_dialog || curses_stupid_hack)
+    {
+        askwin = curses_create_window(prompt_width, prompt_height, UP);
+        for (count = 0; count < prompt_height; count++)
+        {
+            linestr = curses_break_str(askstr, maxwidth, count + 1);
+            mvwaddstr(askwin, count + 1, 1, linestr);
+            free(linestr);
+        }
+    
+        wrefresh(askwin);
+    }
+    else
+    {
+        linestr = curses_copy_of(askstr);
+        pline("%s", linestr);
+        free(linestr);
+        curs_set(1);
+    }
+
+    curses_stupid_hack = 0;
+
+    while (1)
+    {
+        answer = getch();
+
+	if (answer == ERR) {
+	    answer = def;
+	    break;
+	}
+
+        answer = curses_convert_keys(answer);
+
+        if (answer==KEY_ESC)
+        {
+            if (choices == NULL)
+            {
+                break;
+            }
+            answer = def;
+            for (count = 0; choices[count] != '\0'; count++)
+            {
+                if (choices[count] == 'q') /* q is preferred over n */
+                {
+                    answer = 'q';
+                }
+                else if ((choices[count] == 'n') && answer != 'q')
+                {
+                    answer = 'n';
+                }
+            }
+            break;
+        }
+        else if ((answer == '\n') || (answer == '\r') ||
+         (answer == ' '))
+        {
+            if ((choices != NULL) && (def != '\0'))
+            {
+                answer = def;
+            }
+            break;
+        }
+        
+        if (digit(answer))
+        {
+            if (accept_count)
+            {
+                if (answer != '0')
+                {
+                    yn_number = curses_get_count(answer - '0');
+                    touchwin(askwin);
+                    refresh();
+                }
+                
+                answer = '#';
+                break;
+            }
+        }
+        
+        if (any_choice)
+        {
+            break;
+        }
+        
+        if (choices != NULL)
+        {
+            for (count = 0; count < strlen(choices); count++)
+            {
+                if (choices[count] == answer)
+                {
+                    break;
+                }
+            }
+            if (choices[count] == answer)
+            {
+                break;
+            }
+        }
+    }
+
+    if (iflags.wc_popup_dialog)
+    {
+        /* Kludge to make prompt visible after window is dismissed
+        when inputting a number */
+        if (digit(answer))
+        {
+            linestr = curses_copy_of(askstr);
+            pline("%s", linestr);
+            free(linestr);
+            curs_set(1);
+        }
+
+        curses_destroy_win(askwin);
+    }
+    else
+    {
+        curses_clear_unhighlight_message_window();
+        curs_set(0);
+    }
+
+    return answer;
+}
+
+
+/* Return an extended command from the user */
+
+int curses_ext_cmd()
+{
+    int count, letter, prompt_width, startx, starty, winx, winy;
+    int messageh, messagew;
+    int ret = -1;
+    char cur_choice[BUFSZ];
+    int matches = 0;
+    WINDOW *extwin = NULL;
+
+    if (iflags.extmenu)
+    {
+        return extcmd_via_menu();
+    }
+    
+    if (iflags.wc_popup_dialog) /* Prompt in popup window */
+    {
+        startx = 1;
+        starty = 1;
+        extwin = curses_create_window(25, 1, UP);
+    }
+    else
+    {
+        curses_get_window_xy(MESSAGE_WIN, &winx, &winy);
+        curses_get_window_size(MESSAGE_WIN, &messageh, &messagew);
+        
+        if (curses_window_has_border(MESSAGE_WIN))
+        {
+            winx++;
+            winy++;
+        }
+        
+        winy += messageh - 1;
+        extwin = newwin(1, 25, winy, winx);
+        startx = 0;
+        starty = 0;
+        pline("#");
+    }
+
+    cur_choice[0] = '\0';
+
+    while (1)
+    {
+        wmove(extwin, starty, startx);
+        waddstr(extwin, "# ");
+        wmove(extwin, starty, startx + 2);
+        curses_toggle_color_attr(extwin, NONE, A_UNDERLINE, ON);
+        waddstr(extwin, cur_choice);
+        curses_toggle_color_attr(extwin, NONE, A_UNDERLINE, OFF);
+        wmove(extwin, starty, strlen(cur_choice) + startx + 2);
+        wprintw(extwin, "          ", cur_choice);
+
+        if (matches == 1)
+        {
+            wmove(extwin, starty, strlen(cur_choice) + startx + 2);
+            wprintw(extwin, "%s          ", extcmdlist[ret].ef_txt
+             + strlen(cur_choice));
+        }
+
+        wrefresh(extwin);
+        letter = getch();
+	    prompt_width = strlen(cur_choice);
+        matches = 0;
+
+        if (letter == DOESCAPE || letter == ERR)
+        {
+            ret = -1;
+            break;
+        }
+
+        if ((letter == '\r') || (letter == '\n'))
+        {
+            break;
+        }
+
+        if ((letter == '\b') || (letter == KEY_BACKSPACE))
+        {
+            if (prompt_width == 0)
+            {
+                ret = -1;
+                break;
+            }
+            else
+            {
+                cur_choice[prompt_width - 1] = '\0';
+                letter = '*';
+                prompt_width--;
+            }
+        }
+        
+        for (count = 0; extcmdlist[count].ef_txt; count++)
+        {
+	  if (!extcmdlist[count].autocomplete) continue;
+            if (strlen(extcmdlist[count].ef_txt) > prompt_width)
+            {
+                if (strncasecmp(cur_choice, extcmdlist[count].ef_txt,
+                 prompt_width) == 0)
+                {
+                    if ((extcmdlist[count].ef_txt[prompt_width] ==
+			 lowc(letter)) || letter == '*')
+                    {
+                        if ((matches == 0) && (letter != '*'))
+                        {
+                            ret = count;
+                            cur_choice[prompt_width] = letter;
+                            cur_choice[prompt_width + 1] = '\0';
+                        }
+
+                        matches++;
+                    }
+                }
+            }
+	    }
+	}    
+    
+    curses_destroy_win(extwin);
+    return ret;
+}
+
+
+/* Initialize a menu from given NetHack winid */
+
+void curses_create_nhmenu(winid wid)
+{
+    nhmenu *new_menu = NULL;
+    nhmenu *menuptr = nhmenus;
+    nhmenu_item *menu_item_ptr = NULL;
+    nhmenu_item *tmp_menu_item = NULL;
+    
+    new_menu = get_menu(wid);
+    
+    if (new_menu != NULL)
+    {
+        /* Reuse existing menu, clearing out current entries */
+        menu_item_ptr = new_menu->entries;
+        
+        if (menu_item_ptr != NULL)
+        {
+            while (menu_item_ptr->next_item != NULL)
+            {
+                tmp_menu_item = menu_item_ptr->next_item;
+                free(menu_item_ptr);
+                menu_item_ptr = tmp_menu_item;
+            }
+            free(menu_item_ptr);    /* Last entry */
+            new_menu->entries = NULL;
+        }
+        if (new_menu->prompt != NULL)   /* Reusing existing menu */
+        {
+            free((char *)new_menu->prompt);
+        }    
+        return;
+    }
+    
+    new_menu = malloc(sizeof(nhmenu));
+    new_menu->wid = wid;
+    new_menu->prompt = NULL;
+    new_menu->entries = NULL;
+    new_menu->num_pages = 0;
+    new_menu->height = 0;
+    new_menu->width = 0;
+    new_menu->reuse_accels = FALSE;
+    new_menu->next_menu = NULL;
+    
+    if (nhmenus == NULL)    /* no menus in memory yet */
+    {
+        new_menu->prev_menu = NULL;
+        nhmenus = new_menu;
+    }
+    else
+    {
+        while (menuptr->next_menu != NULL)
+        {
+            menuptr = menuptr->next_menu;
+        }
+        new_menu->prev_menu = menuptr;
+        menuptr->next_menu = new_menu;
+    }
+}
+
+
+/* Add a menu item to the given menu window */
+
+void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel)
+{
+    char *new_str;
+    nhmenu_item *new_item, *current_items, *menu_item_ptr;
+    nhmenu *current_menu = get_menu(wid);
+    
+    if (str == NULL)
+    {
+        return;
+    }
+
+    new_str = curses_copy_of(str);
+    curses_rtrim((char *) new_str);
+    new_item = malloc(sizeof(nhmenu_item));
+    new_item->wid = wid;
+    new_item->identifier = *identifier;
+    new_item->accelerator = accelerator;
+    new_item->group_accel = group_accel;
+    new_item->attr = attr;
+    new_item->str = new_str;
+    new_item->presel = presel;
+    new_item->selected = FALSE;
+    new_item->page_num = 0;
+    new_item->line_num = 0;
+    new_item->num_lines = 0;
+    new_item->count = -1;
+    new_item->next_item = NULL;
+    
+    if (current_menu == NULL)
+    {
+        panic("curses_add_nhmenu_item: attempt to add item to nonexistant menu");
+    }
+
+    current_items = current_menu->entries;
+    menu_item_ptr = current_items;
+
+    if (current_items == NULL)
+    {
+        new_item->prev_item = NULL;
+        current_menu->entries = new_item;
+    }
+    else
+    {
+        while (menu_item_ptr->next_item != NULL)
+        {
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        new_item->prev_item = menu_item_ptr;
+        menu_item_ptr->next_item = new_item;
+    }
+}
+
+
+/* No more entries are to be added to menu, so details of the menu can be
+ finalized in memory */
+
+void curses_finalize_nhmenu(winid wid, const char *prompt)
+{
+    int count = 0;
+    nhmenu *current_menu = get_menu(wid);
+    nhmenu_item *menu_item_ptr = current_menu->entries;
+
+    if (current_menu == NULL)
+    {
+        panic("curses_finalize_nhmenu: attempt to finalize nonexistant menu");
+    }
+
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr = menu_item_ptr->next_item;
+        count++;
+    }
+
+    current_menu->num_entries = count;
+
+    current_menu->prompt = curses_copy_of(prompt);
+}
+
+
+/* Display a nethack menu, and return a selection, if applicable */
+
+int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected)
+{
+    nhmenu *current_menu = get_menu(wid);
+    nhmenu_item *menu_item_ptr;
+    int num_chosen, count;
+    WINDOW *win;
+    MENU_ITEM_P *selected = NULL;
+
+	*_selected = NULL;
+    
+    if (current_menu == NULL)
+    {
+        panic("curses_display_nhmenu: attempt to display nonexistant menu");
+    }
+    
+    menu_item_ptr = current_menu->entries;
+    
+    if (menu_item_ptr == NULL)
+    {
+        panic("curses_display_nhmenu: attempt to display empty menu");
+    }
+    
+    /* Reset items to unselected to clear out selections from previous
+    invocations of this menu, and preselect appropriate items */
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr->selected = menu_item_ptr->presel;
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+
+    menu_win_size(current_menu);
+    menu_determine_pages(current_menu);
+    
+    /* Display pre and post-game menus centered */
+    if (((moves <= 1) && !invent) || program_state.gameover)
+    {
+        win = curses_create_window(current_menu->width,
+         current_menu->height, CENTER);
+    }
+    else    /* Display during-game menus on the right out of the way */
+    {
+        win = curses_create_window(current_menu->width,
+         current_menu->height, RIGHT);
+    }
+    
+    num_chosen = menu_get_selections(win, current_menu, how);
+    curses_destroy_win(win);
+    
+    if (num_chosen > 0)
+    {
+        selected = (MENU_ITEM_P*) malloc(num_chosen *
+         sizeof(MENU_ITEM_P));
+        count = 0;
+        
+        menu_item_ptr = current_menu->entries;
+
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->selected)
+            {
+                if (count == num_chosen)
+                {
+                    panic("curses_display_nhmenu: Selected items "
+                     "exceeds expected number");
+                }
+                selected[count].item = menu_item_ptr->identifier;
+                selected[count].count = menu_item_ptr->count;
+                count++; 
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        
+        if (count != num_chosen)
+        {
+            panic("curses_display_nhmenu: Selected items less than "
+             "expected number");
+        }
+    }
+
+    *_selected = selected;
+    
+    return num_chosen;
+}
+
+
+boolean curses_menu_exists(winid wid)
+{
+    if (get_menu(wid) != NULL)
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+/* Delete the menu associated with the given NetHack winid from memory */
+
+void curses_del_menu(winid wid)
+{
+    nhmenu_item *tmp_menu_item;
+    nhmenu_item *menu_item_ptr;
+    nhmenu *tmpmenu;
+    nhmenu *current_menu = get_menu(wid);
+    
+    if (current_menu == NULL)
+    {
+       return;
+    }
+    
+    menu_item_ptr = current_menu->entries;
+    
+    /* First free entries associated with this menu from memory */
+    if (menu_item_ptr != NULL)
+    {
+        while (menu_item_ptr->next_item != NULL)
+        {
+            tmp_menu_item = menu_item_ptr->next_item;
+            free(menu_item_ptr);
+            menu_item_ptr = tmp_menu_item;
+        }
+        free(menu_item_ptr);    /* Last entry */
+        current_menu->entries = NULL;
+    }
+    
+    /* Now unlink the menu from the list and free it as well */
+    if (current_menu->prev_menu != NULL)
+    {
+        tmpmenu = current_menu->prev_menu;
+        tmpmenu->next_menu = current_menu->next_menu;
+    }
+    else
+    {
+        nhmenus = current_menu->next_menu;   /* New head mode or NULL */
+    }
+    if (current_menu->next_menu != NULL)
+    {
+        tmpmenu = current_menu->next_menu;
+        tmpmenu->prev_menu = current_menu->prev_menu;
+    }
+    
+    free(current_menu);
+    
+    curses_del_wid(wid);
+}
+
+
+/* return a pointer to the menu associated with the given NetHack winid */
+
+static nhmenu *get_menu(winid wid)
+{
+    nhmenu *menuptr = nhmenus;
+
+    while (menuptr != NULL)
+    {
+        if (menuptr->wid == wid)
+        {
+            return menuptr;
+        }
+        menuptr = menuptr->next_menu;
+    }
+    
+    return NULL;    /* Not found */
+}
+
+
+static char menu_get_accel(boolean first)
+{
+    char ret;
+    static char next_letter = 'a';
+    
+    if (first)
+    {
+        next_letter = 'a';
+    }
+    
+    ret = next_letter;
+    
+    if (((next_letter < 'z') && (next_letter >= 'a')) || ((next_letter < 'Z')
+     && (next_letter >= 'A')) || ((next_letter < '9') && (next_letter >= '0')))
+    {
+        next_letter++;
+    }
+    else if (next_letter == 'z')
+    {
+        next_letter = 'A';
+    }
+    else if (next_letter == 'Z')
+    {
+        next_letter = '0';
+    }
+    
+    return ret;
+}
+
+
+/* Determine if menu will require multiple pages to display */
+
+static boolean menu_is_multipage(nhmenu *menu, int width, int height)
+{
+    int num_lines;
+    int curline = 0;
+    nhmenu_item *menu_item_ptr = menu->entries;
+
+    if (strlen(menu->prompt) > 0)
+    {
+        curline += curses_num_lines(menu->prompt, width) + 1;
+    }
+    
+    if (menu->num_entries <= (height - curline))
+    {   
+        while (menu_item_ptr != NULL)
+        {
+            menu_item_ptr->line_num = curline;
+            if (menu_item_ptr->identifier.a_void == NULL)
+            {
+                num_lines = curses_num_lines(menu_item_ptr->str, width);
+            }
+            else
+            {
+                /* Add space for accelerator */
+                num_lines = curses_num_lines(menu_item_ptr->str, width - 4);
+            }
+            menu_item_ptr->num_lines = num_lines;
+            curline += num_lines;
+            menu_item_ptr = menu_item_ptr->next_item;
+            if ((curline > height) || ((curline > height -2) &&
+             (height == menu_max_height())))
+            {
+                break;
+            }
+        }
+        if (menu_item_ptr == NULL)
+        {
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+
+/* Determine which entries go on which page, and total number of pages */
+
+static void menu_determine_pages(nhmenu *menu)
+{
+    int tmpline, num_lines;
+    int curline = 0;
+    int page_num = 1;
+    nhmenu_item *menu_item_ptr = menu->entries;
+    int width = menu->width;
+    int height = menu->height;
+    int page_end = height;
+    
+    
+    if (strlen(menu->prompt) > 0)
+    {
+        curline += curses_num_lines(menu->prompt, width) + 1;
+    }
+        
+    tmpline = curline;
+    
+    if (menu_is_multipage(menu, width, height))
+    {
+        page_end -= 2;  /* Room to display current page number */
+    }
+
+    /* Determine what entries belong on which page */
+    menu_item_ptr = menu->entries;
+    
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr->page_num = page_num;
+        menu_item_ptr->line_num = curline;
+        if (menu_item_ptr->identifier.a_void == NULL)
+        {
+            num_lines = curses_num_lines(menu_item_ptr->str, width);
+        }
+        else
+        {
+            /* Add space for accelerator */
+            num_lines = curses_num_lines(menu_item_ptr->str, width - 4);
+        }
+        menu_item_ptr->num_lines = num_lines;
+        curline += num_lines;
+        if (curline > page_end)
+        {
+            page_num++;
+            curline = tmpline;
+            /* Move ptr back so entry will be reprocessed on new page */
+            menu_item_ptr = menu_item_ptr->prev_item;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    menu->num_pages = page_num;
+}
+
+
+/* Determine dimensions of menu window based on term size and entries */
+
+static void menu_win_size(nhmenu *menu)
+{
+    int width, height, maxwidth, maxheight, curentrywidth, lastline;
+    int maxentrywidth = strlen(menu->prompt);
+    int maxheaderwidth = 0;
+    nhmenu_item *menu_item_ptr = menu->entries;
+    
+    maxwidth = 38;  /* Reasonable minimum usable width */
+    
+    if ((term_cols / 2) > maxwidth)
+    {
+        maxwidth = (term_cols / 2); /* Half the screen */
+    }
+    
+    maxheight = menu_max_height();
+    
+    /* First, determine the width of the longest menu entry */
+    while (menu_item_ptr != NULL)
+
+    {
+        if (menu_item_ptr->identifier.a_void == NULL)
+        {
+            curentrywidth=strlen(menu_item_ptr->str);
+
+            if (curentrywidth > maxheaderwidth)
+            {
+                maxheaderwidth = curentrywidth;
+            }
+        }
+        else
+        {
+            /* Add space for accelerator */
+            curentrywidth=strlen(menu_item_ptr->str) + 4;
+        }
+        if (curentrywidth > maxentrywidth)
+        {
+            maxentrywidth = curentrywidth;          
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    /* If the widest entry is smaller than maxwidth, reduce maxwidth accordingly */
+    if (maxentrywidth < maxwidth)
+    {
+        maxwidth = maxentrywidth;
+    }
+    
+    /* Try not to wrap headers/normal text lines if possible.  We can
+    go wider than half the screen for this purpose if need be */
+    
+    if ((maxheaderwidth > maxwidth) && (maxheaderwidth < (term_cols - 2)))
+    {
+        maxwidth = maxheaderwidth;
+    }
+    
+    width = maxwidth;
+    
+    /* Possibly reduce height if only 1 page */    
+    if (!menu_is_multipage(menu, maxwidth, maxheight))   
+    {
+        menu_item_ptr = menu->entries;
+        
+        while (menu_item_ptr->next_item != NULL)
+        {
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        
+        lastline = (menu_item_ptr->line_num) + menu_item_ptr->num_lines;
+    
+        if (lastline < maxheight)
+        {
+            maxheight = lastline;
+        }
+    }
+    else    /* If multipage, make sure we have enough width for page footer */
+    {
+        if (width < 20)
+        {
+            width = 20;
+        }
+    }
+
+    height = maxheight;
+    menu->width = width;
+    menu->height = height;
+}
+
+
+/* Displays menu selections in the given window */
+
+static void menu_display_page(nhmenu *menu, WINDOW *win, int page_num)
+{
+    nhmenu_item *menu_item_ptr;
+    int count, curletter, entry_cols, start_col, num_lines, footer_x;
+    boolean first_accel = TRUE;
+#ifdef MENU_COLOR
+    int color = NO_COLOR;
+    int attr = A_NORMAL;
+    boolean menu_color = FALSE;
+#endif /* MENU_COLOR */
+    
+    /* Cycle through entries until we are on the correct page */
+
+    menu_item_ptr = menu->entries;
+    
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num == page_num)
+        {
+            break;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    if (menu_item_ptr == NULL)  /* Page not found */
+    {
+        panic("menu_display_page: attempt to display nonexistant page");
+    }
+
+    werase(win);
+
+    if (strlen(menu->prompt) > 0)
+    {
+        num_lines = curses_num_lines(menu->prompt, menu->width);
+        
+        for (count = 0; count < num_lines; count++)
+        {
+            mvwprintw(win, count + 1, 1, "%s",
+             curses_break_str(menu->prompt, menu->width, count + 1));
+        }
+    }
+
+    /* Display items for current page */
+    
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num != page_num)
+        {
+            break;
+        }
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            if (menu_item_ptr->accelerator != 0)
+            {
+                curletter = menu_item_ptr->accelerator;
+            }
+            else
+            {
+                if (first_accel)
+                {
+                    curletter = menu_get_accel(TRUE);
+                    first_accel = FALSE;
+                    if (!menu->reuse_accels && (menu->num_pages > 1))
+                    {
+                        menu->reuse_accels = TRUE;
+                    }
+                }
+                else
+                {
+                    curletter = menu_get_accel(FALSE);
+                }
+                menu_item_ptr->accelerator = curletter;
+            }
+
+            if (menu_item_ptr->selected)
+            {
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, ON);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 1, '<');
+                mvwaddch(win, menu_item_ptr->line_num + 1, 2, curletter);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 3, '>');
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, OFF);
+            }
+            else
+            {
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 2, curletter);
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+                mvwprintw(win, menu_item_ptr->line_num + 1, 3, ") ");
+            }
+        }
+#ifdef MENU_COLOR
+		if (iflags.use_menu_color && (menu_color = get_menu_coloring
+		 ((char *)menu_item_ptr->str, &color, &attr)))
+		{
+		    if (color != NO_COLOR)
+		    {
+                curses_toggle_color_attr(win, color, NONE, ON);
+		    }
+    		if (attr != A_NORMAL)
+    		{
+    		    menu_item_ptr->attr = menu_item_ptr->attr|attr;
+    		}
+		}
+#endif /* MENU_COLOR */
+        curses_toggle_color_attr(win, NONE, menu_item_ptr->attr, ON);
+        entry_cols = menu->width;
+        start_col = 1;
+
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            entry_cols -= 4;
+            start_col += 4;
+        }        
+        
+        num_lines = curses_num_lines(menu_item_ptr->str, entry_cols);
+        
+        for (count = 0; count < num_lines; count++)
+        {
+            if (strlen(menu_item_ptr->str) > 0)
+            {
+                mvwprintw(win, menu_item_ptr->line_num + count + 1,
+                 start_col, "%s", curses_break_str(menu_item_ptr->str,
+                 entry_cols, count + 1));
+             }
+        }
+#ifdef MENU_COLOR
+	if (menu_color && (color != NO_COLOR))
+    {
+        curses_toggle_color_attr(win, color, NONE, OFF);
+    }
+#endif /* MENU_COLOR */
+        curses_toggle_color_attr(win, NONE, menu_item_ptr->attr, OFF);
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+
+    if (menu->num_pages > 1)
+    {
+        footer_x = menu->width - strlen("<- (Page X of Y) ->");
+        if (menu->num_pages > 9)    /* Unlikely */
+        {
+            footer_x -= 2;
+        }
+        mvwprintw(win, menu->height, footer_x + 3, "(Page %d of %d)",
+         page_num, menu->num_pages);
+        if (page_num != 1)
+        {
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+            mvwaddstr(win, menu->height, footer_x, "<=");
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        }
+        if (page_num != menu->num_pages)
+        {
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+            mvwaddstr(win, menu->height, menu->width - 2, "=>");        
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        }
+    }
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, ON);
+    box(win, 0, 0);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, OFF);
+    wrefresh(win);
+}
+
+
+static int menu_get_selections(WINDOW *win, nhmenu *menu, int how)
+{
+    int curletter;
+    int count = -1;
+    int count_letter = '\0';
+    int curpage = 1;
+    int num_selected = 0;
+    boolean dismiss = FALSE;
+    char search_key[BUFSZ];
+    nhmenu_item *menu_item_ptr = menu->entries;
+
+    menu_display_page(menu, win, 1);
+
+    while (!dismiss)
+    {
+        curletter = getch();
+
+	if (curletter == ERR) {
+	    num_selected = -1;
+	    dismiss = TRUE;
+	}
+        
+        if (curletter == DOESCAPE)
+        {
+            curletter = curses_convert_keys(curletter);
+        }
+        
+        
+        
+        switch (how)
+        {
+            case PICK_NONE:
+            {
+                if (menu->num_pages == 1)
+                {    
+                    if (curletter == KEY_ESC)
+                    {
+                        num_selected = -1;
+                    }
+                    else
+                    {
+                        num_selected = 0;
+    
+                    }
+                    dismiss = TRUE;
+                    break;
+                }
+                break;
+            }
+            case PICK_ANY:
+            {
+                switch (curletter)
+                {
+                   case MENU_SELECT_PAGE:
+                   {
+                       (void) menu_operation(win, menu, SELECT, curpage);
+                       break;
+                   }
+                   case MENU_SELECT_ALL:
+                   {
+                       curpage = menu_operation(win, menu, SELECT, 0);
+                       break;
+                   }
+                   case MENU_UNSELECT_PAGE:
+                   {
+                       (void) menu_operation(win, menu, DESELECT, curpage);
+                       break;
+                   }
+                   case MENU_UNSELECT_ALL:
+                   {
+                       curpage = menu_operation(win, menu, DESELECT, 0);
+                       break;
+                   }
+                   case MENU_INVERT_PAGE:
+                   {
+                       (void) menu_operation(win, menu, INVERT, curpage);
+                       break;
+                   }
+                   case MENU_INVERT_ALL:
+                   {
+                       curpage = menu_operation(win, menu, INVERT, 0);
+                       break;
+                   }
+               }
+            }
+            default:
+            {
+                if (isdigit(curletter))
+                {
+                    count = curses_get_count(curletter - '0');
+                    touchwin(win);
+                    refresh();
+                    curletter = getch();
+                    if (count > 0)
+                    {
+                        count_letter = curletter;
+                    }
+                }
+            }
+        }
+        
+        
+        
+        
+        switch (curletter)
+        {
+            case KEY_ESC:
+            {
+                num_selected = -1;
+                dismiss = TRUE;
+                break;
+            }
+            case '\n':
+            case '\r':
+            {
+                dismiss = TRUE;
+                break;
+            }
+            case KEY_RIGHT:
+            case KEY_NPAGE:
+            case MENU_NEXT_PAGE:
+            case ' ':
+            {
+                if (curpage < menu->num_pages)
+                {
+                    curpage++;
+                    menu_display_page(menu, win, curpage);
+                }
+                else if (curletter == ' ')
+                {
+                    dismiss = TRUE;
+                    break;
+                }
+                break;
+            }
+            case KEY_LEFT:
+            case KEY_PPAGE:
+            case MENU_PREVIOUS_PAGE:
+            {
+                if (curpage > 1)
+                {
+                    curpage--;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case KEY_END:
+            case MENU_LAST_PAGE:
+            {
+                if (curpage != menu->num_pages)
+                {
+                    curpage = menu->num_pages;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case KEY_HOME:
+            case MENU_FIRST_PAGE:
+            {
+                if (curpage != 1)
+                {
+                    curpage = 1;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case MENU_SEARCH:
+            {
+                curses_line_input_dialog("Search for:", search_key,
+                 BUFSZ);
+        		
+                refresh();
+                touchwin(win);
+                wrefresh(win);
+                
+        		if (strlen(search_key) == 0)
+        		{
+        		    break;
+        		}
+        		
+                menu_item_ptr = menu->entries;
+
+                while (menu_item_ptr != NULL)
+                {
+                    if ((menu_item_ptr->identifier.a_void != NULL) &&
+                     (strstri(menu_item_ptr->str, search_key)))
+                    {
+                        if (how == PICK_ONE)
+                        {
+                            menu_clear_selections(menu);
+                            menu_select_deselect(win, menu_item_ptr,
+                             SELECT);
+                            num_selected = 1;
+                            dismiss = TRUE;
+                            break;
+                        }
+                        else
+                        {
+                            menu_select_deselect(win, menu_item_ptr,
+                             INVERT);
+                        }
+                    }
+
+                    menu_item_ptr = menu_item_ptr->next_item;
+                }
+
+                menu_item_ptr = menu->entries;
+                break;
+            }
+            default:
+            {
+                if (how==PICK_NONE)
+                {    
+                    num_selected = 0;
+                    dismiss = TRUE;
+                    break;
+                }                
+            }
+        }
+
+        
+        menu_item_ptr = menu->entries;
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->identifier.a_void != NULL)
+            {
+                if (((curletter == menu_item_ptr->accelerator) &&
+                 ((curpage == menu_item_ptr->page_num) ||
+                 (!menu->reuse_accels))) || ((menu_item_ptr->group_accel)
+                 && (curletter == menu_item_ptr->group_accel)))
+                {
+                    if (curpage != menu_item_ptr->page_num)
+                    {
+                        curpage = menu_item_ptr->page_num;
+                        menu_display_page(menu, win, curpage);
+                    }
+
+                    if (how == PICK_ONE)
+                    {
+                        menu_clear_selections(menu);
+                        menu_select_deselect(win, menu_item_ptr, SELECT);
+                        num_selected = 1;
+                        dismiss = TRUE;
+                        break;
+                    }
+                    else if ((how == PICK_ANY) && (curletter == count_letter))
+                    {
+                        menu_select_deselect(win, menu_item_ptr, SELECT);
+                        menu_item_ptr->count = count;
+                        count = 0;
+                        count_letter = '\0';
+                    }
+                    else
+                    {
+                        menu_select_deselect(win, menu_item_ptr, INVERT);
+                    }
+                }
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+    }
+    
+    if ((how == PICK_ANY) && (num_selected != -1))
+    {
+        num_selected = 0;
+        menu_item_ptr = menu->entries;
+        
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->identifier.a_void != NULL)
+            {
+                if (menu_item_ptr->selected)
+                {
+                    num_selected++;
+                }
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+    }
+    
+    return num_selected;
+}
+
+
+/* Select, deselect, or toggle selected for the given menu entry */
+
+static void menu_select_deselect(WINDOW *win, nhmenu_item *item, menu_op operation)
+{
+    int curletter = item->accelerator;
+    
+    if ((operation == DESELECT) || (item->selected && (operation ==
+     INVERT)))
+    {
+        item->selected = FALSE;
+        mvwaddch(win, item->line_num + 1, 1, ' ');
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+        mvwaddch(win, item->line_num + 1, 2, curletter);
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        mvwaddch(win, item->line_num + 1, 3, ')');
+    }
+    else
+    {
+        item->selected = TRUE;
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, ON);
+        mvwaddch(win, item->line_num + 1, 1, '<');
+        mvwaddch(win, item->line_num + 1, 2, curletter);
+        mvwaddch(win, item->line_num + 1, 3, '>');
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, OFF);
+    }
+    
+    wrefresh(win);
+}
+
+
+/* Perform the selected operation (select, unselect, invert selection)
+on the given menu page.  If menu_page is 0, then perform opetation on
+all pages in menu.  Returns last page displayed.  */
+
+static int menu_operation(WINDOW *win, nhmenu *menu, menu_op
+ operation, int page_num)
+{
+    int first_page, last_page, current_page;
+    nhmenu_item *menu_item_ptr = menu->entries;    
+    
+    if (page_num == 0)  /* Operation to occur on all pages */
+    {
+        first_page = 1;
+        last_page = menu->num_pages;
+    }
+    else
+    {
+        first_page = page_num;
+        last_page = page_num;
+    }
+
+    /* Cycle through entries until we are on the correct page */
+
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num == first_page)
+        {
+            break;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    current_page = first_page;
+    
+    if (page_num == 0)
+    {
+        menu_display_page(menu, win, current_page);
+    }
+    
+    if (menu_item_ptr == NULL)  /* Page not found */
+    {
+        panic("menu_display_page: attempt to display nonexistant page");
+    }
+    
+    while (menu_item_ptr != NULL)
+    {        
+        if (menu_item_ptr->page_num != current_page)
+        {
+            if (menu_item_ptr->page_num > last_page)
+            {
+                break;
+            }
+
+            current_page = menu_item_ptr->page_num;
+            menu_display_page(menu, win, current_page);
+        }
+        
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            menu_select_deselect(win, menu_item_ptr, operation);
+        }
+        
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    return current_page;
+}
+
+
+/* Set all menu items to unselected in menu */
+
+static void menu_clear_selections(nhmenu *menu)
+{
+    nhmenu_item *menu_item_ptr = menu->entries;    
+
+    while (menu_item_ptr != NULL)    
+    {
+        menu_item_ptr->selected = FALSE;
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+}
+
+
+/* This is to get the color of a menu item if the menucolor patch is
+ applied */
+
+#ifdef MENU_COLOR
+static boolean get_menu_coloring(char *str, int *color, int *attr)
+{
+    struct menucoloring *tmpmc;
+    if (iflags.use_menu_color)
+	for (tmpmc = menu_colorings; tmpmc; tmpmc = tmpmc->next)
+# ifdef MENU_COLOR_REGEX
+#  ifdef MENU_COLOR_REGEX_POSIX
+	    if (regexec(&tmpmc->match, str, 0, NULL, 0) == 0) {
+#  else
+
+	    if (re_search(&tmpmc->match, str, strlen(str), 0, 9999, 0) >= 0) {
+#  endif
+# else
+	    if (pmatch(tmpmc->match, str)) {
+# endif
+		*color = tmpmc->color;
+		*attr = curses_convert_attr(tmpmc->attr);
+		return TRUE;
+	    }
+    return FALSE;
+}
+#endif /* MENU_COLOR */
+
+
+/* Get the maximum height for a menu */
+
+static int menu_max_height(void)
+{
+    return term_rows - 2;
+}
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursdial.h nethack-3.4.3-nao-osx/win/curses/cursdial.h
--- nethack-3.4.3/win/curses/cursdial.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursdial.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,35 @@
+#ifndef CURSDIAL_H
+#define CURSDIAL_H
+
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+#  include <regex.h>
+# endif
+#endif
+
+
+/* Global declarations */
+
+void curses_line_input_dialog(const char *prompt, char *answer, int buffer);
+
+int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def);
+
+int curses_ext_cmd(void);
+
+void curses_create_nhmenu(winid wid);
+
+void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel);
+
+void curses_finalize_nhmenu(winid wid, const char *prompt);
+
+int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected);
+
+boolean curses_menu_exists(winid wid);
+
+void curses_del_menu(winid wid);
+
+
+
+#endif  /* CURSDIAL_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursinit.c nethack-3.4.3-nao-osx/win/curses/cursinit.c
--- nethack-3.4.3/win/curses/cursinit.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursinit.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,1298 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursinit.h"
+#include "patchlevel.h"
+
+#include <ctype.h>
+
+/* Initialization and startup functions for curses interface */
+
+/* Private declarations */
+
+#define NETHACK_CURSES      1
+#define SLASHEM_CURSES      2
+#define UNNETHACK_CURSES    3
+#define SPORKHACK_CURSES    4
+
+/* array to save initial terminal colors for later restoration */
+
+typedef struct nhrgb_type
+{
+    short r;
+    short g;
+    short b;
+} nhrgb;
+
+nhrgb orig_yellow;
+nhrgb orig_white;
+nhrgb orig_darkgray;
+nhrgb orig_hired;
+nhrgb orig_higreen;
+nhrgb orig_hiyellow;
+nhrgb orig_hiblue;
+nhrgb orig_himagenta;
+nhrgb orig_hicyan;
+nhrgb orig_hiwhite;
+
+/* Banners used for an optional ASCII splash screen */
+
+#define NETHACK_SPLASH_A \
+" _   _        _    _    _               _    "
+
+#define NETHACK_SPLASH_B \
+"| \\ | |      | |  | |  | |             | |   "
+
+#define NETHACK_SPLASH_C \
+"|  \\| |  ___ | |_ | |__| |  __ _   ___ | | __"
+
+#define NETHACK_SPLASH_D \
+"| . ` | / _ \\| __||  __  | / _` | / __|| |/ /"
+
+#define NETHACK_SPLASH_E \
+"| |\\  ||  __/| |_ | |  | || (_| || (__ |   < "
+
+#define NETHACK_SPLASH_F \
+"|_| \\_| \\___| \\__||_|  |_| \\__,_| \\___||_|\\_\\"
+
+#define SLASHEM_SPLASH_A \
+" _____  _              _     _  ______  __  __ "
+
+#define SLASHEM_SPLASH_B \
+" / ____|| |            | |   ( )|  ____||  \\/  |"
+
+#define SLASHEM_SPLASH_C \
+"| (___  | |  __ _  ___ | |__  \\|| |__   | \\  / |"
+
+#define SLASHEM_SPLASH_D \
+" \\___ \\ | | / _` |/ __|| '_ \\   |  __|  | |\\/| |"
+
+#define SLASHEM_SPLASH_E \
+" ____) || || (_| |\\__ \\| | | |  | |____ | |  | |"
+
+#define SLASHEM_SPLASH_F \
+"|_____/ |_| \\__,_||___/|_| |_|  |______||_|  |_|"
+
+#define UNNETHACK_SPLASH_A \
+" _    _         _   _        _    _    _               _"
+
+#define UNNETHACK_SPLASH_B \
+"| |  | |       | \\ | |      | |  | |  | |             | |"
+
+#define UNNETHACK_SPLASH_C \
+"| |  | | _ __  |  \\| |  ___ | |_ | |__| |  __ _   ___ | | __"
+
+#define UNNETHACK_SPLASH_D \
+"| |  | || '_ \\ | . ` | / _ \\| __||  __  | / _` | / __|| |/ /"
+
+#define UNNETHACK_SPLASH_E \
+"| |__| || | | || |\\  ||  __/| |_ | |  | || (_| || (__ |   <"
+
+#define UNNETHACK_SPLASH_F \
+" \\____/ |_| |_||_| \\_| \\___| \\__||_|  |_| \\__,_| \\___||_|\\_\\"
+
+#define SPORKHACK_SPLASH_A \
+"  _____                      _     _    _               _    "
+#define SPORKHACK_SPLASH_B \
+" / ____|                    | |   | |  | |             | |   "
+#define SPORKHACK_SPLASH_C \
+"| (___   _ __    ___   _ __ | | __| |__| |  __ _   ___ | | __"
+#define SPORKHACK_SPLASH_D \
+" \\___ \\ | '_ \\  / _ \\ | '__|| |/ /|  __  | / _` | / __|| |/ /"
+#define SPORKHACK_SPLASH_E \
+" ____) || |_) || (_) || |   |   < | |  | || (_| || (__ |   < "
+#define SPORKHACK_SPLASH_F \
+"|_____/ | .__/  \\___/ |_|   |_|\\_\\|_|  |_| \\__,_| \\___||_|\\_\\"
+#define SPORKHACK_SPLASH_G \
+"        | |                                                  "
+#define SPORKHACK_SPLASH_H \
+"        |_|                                                  "
+
+
+/* Create the "main" nonvolitile windows used by nethack */
+
+void curses_create_main_windows()
+{
+    int message_x = 0;
+    int message_y = 0;
+    int status_x = 0;
+    int status_y = 0;
+    int map_x = 0;
+    int map_y = 0;
+    int message_height = 0;
+    int message_width = 0;
+    int status_height = 0;
+    int status_width = 0;
+    int map_height = 0;
+    int map_width = 0;
+    int min_message_height = 1;
+    int message_orientation = 0;
+    int status_orientation = 0;
+    int border_space = 0;
+    int hspace = term_cols - 80;
+    boolean borders = FALSE;
+
+    switch (iflags.wc2_windowborders)
+    {
+        case 1: /* On */
+        {
+            borders = TRUE;
+            break;
+        }
+        case 2: /* Off */
+        {
+            borders = FALSE;
+            break;
+        }
+        case 3: /* Auto */
+        {
+            if ((term_cols > 81) && (term_rows > 25))
+            {
+                borders = TRUE;
+            }
+            break;
+        }
+        default:
+        {
+            borders = FALSE;
+        }
+    }
+
+    
+    if (borders)
+    {
+        border_space = 2;
+        hspace -= border_space;
+    }
+    
+    if ((term_cols - border_space) < COLNO)
+    {
+        min_message_height++;
+    }
+    
+    /* Determine status window orientation */    
+    if (!iflags.wc_align_status || (iflags.wc_align_status == ALIGN_TOP)
+     || (iflags.wc_align_status == ALIGN_BOTTOM))
+    {
+        if (!iflags.wc_align_status)
+        {
+            iflags.wc_align_status = ALIGN_BOTTOM;
+        }
+        status_orientation = iflags.wc_align_status;
+    }
+    else    /* left or right alignment */
+    {
+        /* Max space for player name and title horizontally */
+        if ((hspace >= 26) && (term_rows >= 24))
+        {
+            status_orientation = iflags.wc_align_status;
+            hspace -= (26 + border_space);
+        }
+        else
+        {
+            status_orientation = ALIGN_BOTTOM;
+        }
+    }
+    
+    /* Determine message window orientation */    
+    if (!iflags.wc_align_message || (iflags.wc_align_message == ALIGN_TOP)
+     || (iflags.wc_align_message == ALIGN_BOTTOM))
+    {
+        if (!iflags.wc_align_message)
+        {
+            iflags.wc_align_message = ALIGN_TOP;
+        }
+        message_orientation = iflags.wc_align_message;
+    }
+    else    /* left or right alignment */
+    {
+        if ((hspace - border_space) >= 25)   /* Arbitrary */
+        {
+            message_orientation = iflags.wc_align_message;
+        }
+        else
+        {
+            message_orientation = ALIGN_TOP;
+        }
+    }
+    
+    /* Determine window placement and size - 16 possible combos
+       If anyone wants to try to generalize this, be my guest! */
+    if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_width = (term_cols - border_space);
+        status_height = 2;
+        message_x = 0;
+        message_y = status_y + (status_height + border_space);
+        message_width = (term_cols - border_space);
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = 2;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_width = term_cols - (message_width + (border_space * 2));
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        map_x = 0;
+        map_y = status_y + (status_height + border_space);
+        map_width = status_width;
+        map_height = term_rows - (status_height + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_width = (term_cols - border_space);
+        status_height = 2;
+        map_x = 0;
+        map_y = status_y + (status_height + border_space);
+        map_width = (term_cols - border_space);
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        message_x = 0;
+        message_y = map_y + (map_height + border_space);
+        message_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_x = message_x + (message_width + border_space);
+        status_y = 0;
+        status_height = 2;
+        status_width = term_cols - (message_width + (border_space * 2));
+        map_x = status_x;
+        map_y = status_y + (status_height + border_space);
+        map_height = term_rows - (status_height + (border_space * 2));
+        map_width = status_width;
+    }
+    if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_width = 26;
+        status_height = (term_rows - border_space);
+        status_x = term_cols - (status_width + border_space);
+        status_y = 0;
+        message_x = 0;
+        message_y = 0;
+        message_width = term_cols - (status_width + (border_space * 2));
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = term_cols - (status_width + (border_space * 2));
+        map_height = term_rows - (message_height + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        map_x = 0;
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (COLNO + status_width + (border_space * 3));
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        status_x = message_x + (message_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        map_x = 0;
+        map_y = 0;
+        status_width = 26;
+        map_width = term_cols - (status_width + (border_space * 2));
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (message_height + (border_space * 2));
+        message_x = 0;
+        message_y = map_y + (map_height + border_space);
+        message_width = map_width;
+        status_x = map_x + (map_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (status_width + COLNO + (border_space * 3));
+        map_x = status_x + (status_width + border_space);
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+    }
+    if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_width = (term_cols - border_space);
+        status_height = 2;
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        status_x = 0;
+        status_y = map_y + (map_height + border_space);
+        status_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        map_x = 0;
+        map_y = 0;
+        status_height = 2;
+        map_height = term_rows - (status_height + (border_space * 2));
+        message_width = term_cols - (COLNO + (border_space * 2));
+        map_width = term_cols - (message_width + (border_space * 2));
+        status_x = 0;
+        status_y = map_y + (map_height + border_space);
+        status_width = map_width;
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        map_x = 0;
+        map_y = 0;
+        message_x = 0;
+        status_x = 0;
+        message_width = (term_cols - border_space);
+        status_height = 2;
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        message_y = map_y + (map_height + border_space);
+        status_y = message_y + (message_height + border_space);
+        status_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_height = 2;
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = term_rows - (status_height + (border_space * 2));
+        map_width = term_cols - (message_width + (border_space * 2));
+        status_x = map_x;
+        status_y = map_y + (map_height + border_space);
+        status_width = term_cols - (message_width + (border_space * 2));
+    }
+    if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        message_width = term_cols - (status_width + (border_space * 2));
+        map_x = message_x;
+        map_y = message_y + (message_height + border_space);
+        map_height = term_rows - (message_height + (border_space * 2));
+        map_width = term_cols - (status_width + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (status_width + COLNO + (border_space * 3));
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        status_x = map_x + (map_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        map_x = status_x + (status_width + border_space);
+        map_y = 0;
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (message_height + (border_space * 2));
+        map_width = term_cols - (status_width + (border_space * 2));
+        message_x = status_x + (status_width + border_space);
+        message_y = map_y + (map_height + border_space);
+        message_width = map_width;
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        message_height = status_height;
+        message_width = term_cols - (COLNO + status_width + (border_space * 3));
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = message_height;
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+    }
+    
+    if (map_width > COLNO)
+    {
+        map_width = COLNO;
+    }
+    
+    if (map_height > ROWNO)
+    {
+        map_height = ROWNO;
+    }
+    
+    if (curses_window_exists(STATUS_WIN))
+    {
+        curses_del_nhwin(STATUS_WIN);
+        curses_del_nhwin(MESSAGE_WIN);
+        curses_del_nhwin(MAP_WIN);
+        clear();
+    }
+
+    curses_add_nhwin(STATUS_WIN, status_height, status_width, status_y,
+     status_x, status_orientation, borders);
+
+    curses_add_nhwin(MESSAGE_WIN, message_height, message_width, message_y,
+     message_x, message_orientation, borders);
+
+    curses_add_nhwin(MAP_WIN, map_height, map_width, map_y, map_x, 0,
+     borders);
+
+    refresh();
+    
+    curses_refresh_nethack_windows();
+
+    if (iflags.window_inited)
+    {
+        curses_update_stats(TRUE);
+    }
+    else
+    {
+        iflags.window_inited = TRUE;
+    }
+}
+
+
+/* Initialize curses colors to colors used by NetHack */
+
+void curses_init_nhcolors()
+{
+#ifdef TEXTCOLOR
+    if (has_colors())
+    {
+        use_default_colors();
+        init_pair(1, COLOR_BLACK, -1);
+        init_pair(2, COLOR_RED, -1);
+        init_pair(3, COLOR_GREEN, -1);
+        init_pair(4, COLOR_YELLOW, -1);
+        init_pair(5, COLOR_BLUE, -1);
+        init_pair(6, COLOR_MAGENTA, -1);
+        init_pair(7, COLOR_CYAN, -1);
+        init_pair(8, -1, -1);
+
+	{
+	    int i;
+	    for (i = 0; i < 16; i++) {
+		int clr_remap[16] = {
+		    COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_BLUE,
+		    COLOR_MAGENTA, COLOR_CYAN, -1, COLOR_WHITE,
+		    COLOR_RED+8, COLOR_GREEN+8, COLOR_YELLOW+8, COLOR_BLUE+8,
+		    COLOR_MAGENTA+8, COLOR_CYAN+8, COLOR_WHITE+8
+		};
+		init_pair(17 + (i*2) + 0, clr_remap[i], COLOR_RED);
+		init_pair(17 + (i*2) + 1, clr_remap[i], COLOR_BLUE);
+	    }
+	}
+
+
+        if (COLORS >= 16)
+        {
+            init_pair(9, COLOR_WHITE, -1);
+            init_pair(10, COLOR_RED + 8, -1);
+            init_pair(11, COLOR_GREEN + 8, -1);
+            init_pair(12, COLOR_YELLOW + 8, -1);
+            init_pair(13, COLOR_BLUE + 8, -1);
+            init_pair(14, COLOR_MAGENTA + 8, -1);
+            init_pair(15, COLOR_CYAN + 8, -1);
+            init_pair(16, COLOR_WHITE + 8, -1);
+        }
+
+        if (can_change_color())
+        {
+            /* Preserve initial terminal colors */
+            color_content(COLOR_YELLOW, &orig_yellow.r, &orig_yellow.g,
+             &orig_yellow.b);
+            color_content(COLOR_WHITE, &orig_white.r, &orig_white.g,
+             &orig_white.b);
+            
+            /* Set colors to appear as NetHack expects */
+            init_color(COLOR_YELLOW, 500, 300, 0);
+            init_color(COLOR_WHITE, 600, 600, 600);
+            if (COLORS >= 16)
+            {
+                /* Preserve initial terminal colors */
+                color_content(COLOR_RED + 8, &orig_hired.r,
+                 &orig_hired.g, &orig_hired.b);
+                color_content(COLOR_GREEN + 8, &orig_higreen.r,
+                 &orig_higreen.g, &orig_higreen.b);
+                color_content(COLOR_YELLOW + 8, &orig_hiyellow.r,
+                 &orig_hiyellow.g, &orig_hiyellow.b);
+                color_content(COLOR_BLUE + 8, &orig_hiblue.r,
+                 &orig_hiblue.g, &orig_hiblue.b);
+                color_content(COLOR_MAGENTA + 8, &orig_himagenta.r,
+                 &orig_himagenta.g, &orig_himagenta.b);
+                color_content(COLOR_CYAN + 8, &orig_hicyan.r,
+                 &orig_hicyan.g, &orig_hicyan.b);
+                color_content(COLOR_WHITE + 8, &orig_hiwhite.r,
+                 &orig_hiwhite.g, &orig_hiwhite.b);
+            
+                /* Set colors to appear as NetHack expects */
+                init_color(COLOR_RED + 8, 1000, 500, 0);
+                init_color(COLOR_GREEN + 8, 0, 1000, 0);
+                init_color(COLOR_YELLOW + 8, 1000, 1000, 0);
+                init_color(COLOR_BLUE + 8, 0, 0, 1000);
+                init_color(COLOR_MAGENTA + 8, 1000, 0, 1000);
+                init_color(COLOR_CYAN + 8, 0, 1000, 1000);
+                init_color(COLOR_WHITE + 8, 1000, 1000, 1000);
+#ifdef USE_DARKGRAY
+                if (COLORS > 16)
+                {
+                    init_color(CURSES_DARK_GRAY, 300, 300, 300);
+                }
+#endif
+            }
+            else
+            {
+                /* Set flag to use bold for bright colors */
+            }
+        }
+    }
+#endif
+}
+
+
+/* Allow player to pick character's role, race, gender, and alignment.
+Borrowed from the Gnome window port. */
+
+void curses_choose_character()
+{
+    int n, i, sel, count_off, pick4u;
+    int count = 0;
+    int cur_character = 0;
+    const char** choices;
+    int* pickmap;
+    char *prompt;
+    char pbuf[QBUFSZ];
+    char choice[QBUFSZ];
+    char tmpchoice[QBUFSZ];
+#ifdef TUTORIAL_MODE
+	winid win;
+	anything any;
+	menu_item *selected = 0;
+#endif
+
+	prompt = build_plselection_prompt(pbuf, QBUFSZ, flags.initrole,
+	 flags.initrace, flags.initgend, flags.initalign);
+
+    /* This part is irritating: we have to strip the choices off of
+    the string and put them in a separate string in order to use
+    curses_character_input_dialog for this prompt. */
+
+    while (cur_character != '[')
+    {
+        cur_character = prompt[count];
+        count++;
+    }
+    
+    count_off = count;
+    
+    while (cur_character != ']')
+    {
+        tmpchoice[count - count_off] = prompt[count];
+        count++;
+        cur_character = prompt[count];
+    }
+    
+    tmpchoice[count - count_off] = '\0';
+    lcase(tmpchoice);
+    
+    while (!isspace(prompt[count_off]))
+    {
+        count_off--;
+    }
+    
+    prompt[count_off] = '\0';
+    sprintf(choice, "%s%c", tmpchoice, '\033');
+    if(strchr(tmpchoice, 't'))  /* Tutorial mode */
+    {
+        mvaddstr(0, 1, "New? Press t to enter a tutorial.");
+    }
+    
+    /* Add capital letters as choices that aren't displayed */
+    
+    for (count = 0; tmpchoice[count]; count++)
+    {
+        tmpchoice[count] = toupper(tmpchoice[count]);
+    }
+    
+    sprintf(choice, "%s%s", choice, tmpchoice);
+
+    /* prevent an unnecessary prompt */
+    rigid_role_checks(); 
+    
+	if (!flags.randomall &&
+	    (flags.initrole == ROLE_NONE || flags.initrace == ROLE_NONE ||
+	     flags.initgend == ROLE_NONE || flags.initalign == ROLE_NONE))
+	{
+        pick4u = tolower(curses_character_input_dialog(prompt, choice,
+         'y'));
+    }
+    else
+    {
+        pick4u = 'y';
+    }
+    
+    if (pick4u == 'q')  /* Quit or cancelled */
+    {
+	    clearlocks();
+	    curses_bail(0);
+    }
+    
+    if (pick4u == 'y')
+    {
+        flags.randomall = TRUE;
+    }
+#ifdef TUTORIAL_MODE
+    else if (pick4u == 't') /* Tutorial mode in UnNetHack */
+    {
+	    clear();
+        mvaddstr(0, 1, "Choose a character");
+        refresh();
+	    win = curses_get_wid(NHW_MENU);
+        curses_create_nhmenu(win);
+	    any.a_int = 1;
+	    curses_add_menu(win, NO_GLYPH, &any, 'v', 0, ATR_NONE,
+		     "lawful female dwarf Valkyrie (uses melee and thrown weapons)",
+		     MENU_UNSELECTED);
+	    any.a_int = 2;
+	    curses_add_menu(win, NO_GLYPH, &any, 'w', 0, ATR_NONE,
+		     "chaotic male elf Wizard (relies mostly on spells)",
+		     MENU_UNSELECTED);
+	    any.a_int = 3;
+	    curses_add_menu(win, NO_GLYPH, &any, 'R', 0, ATR_NONE,
+		     "neutral female human Ranger (good with ranged combat)",
+		     MENU_UNSELECTED);
+	    any.a_int = 4;
+	    curses_add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE,
+		     "quit", MENU_UNSELECTED);
+	    curses_end_menu(win, "What character do you want to try?");
+	    n = curses_select_menu(win, PICK_ONE, &selected);
+	    destroy_nhwindow(win);
+	    if (n != 1 || selected[0].item.a_int == 4)
+	    {
+    	    clearlocks();
+    	    curses_bail(0);
+	    }
+	    switch (selected[0].item.a_int) {
+	    case 1:
+		flags.initrole = str2role("Valkyrie");
+		flags.initrace = str2race("dwarf");
+		flags.initgend = str2gend("female");
+		flags.initalign = str2align("lawful");
+		break;
+	    case 2:
+		flags.initrole = str2role("Wizard");
+		flags.initrace = str2race("elf");
+		flags.initgend = str2gend("male");
+		flags.initalign = str2align("chaotic");
+		break;
+	    case 3:
+		flags.initrole = str2role("Ranger");
+		flags.initrace = str2race("human");
+		flags.initgend = str2gend("female");
+		flags.initalign = str2align("neutral");
+		break;
+	    default: panic("Impossible menu selection"); break;
+	    }
+	    free((genericptr_t) selected);
+	    selected = 0;
+	    flags.tutorial = 1;
+	}
+#endif
+    
+    clear();
+    refresh();
+
+    if (!flags.randomall && flags.initrole < 0) {
+	/* select a role */
+	for (n = 0; roles[n].name.m; n++) continue;
+	choices = (const char **)alloc(sizeof(char *) * (n+1));
+	pickmap = (int*)alloc(sizeof(int) * (n+1));
+	for (;;) {
+	    for (n = 0, i = 0; roles[i].name.m; i++) {
+		if (ok_role(i, flags.initrace,
+			    flags.initgend, flags.initalign)) {
+		    if (flags.initgend >= 0 && flags.female && roles[i].name.f)
+			choices[n] = roles[i].name.f;
+		    else
+			choices[n] = roles[i].name.m;
+		    pickmap[n++] = i;
+		}
+	    }
+	    if (n > 0) break;
+	    else if (flags.initalign >= 0) flags.initalign = -1;    /* reset */
+	    else if (flags.initgend >= 0) flags.initgend = -1;
+	    else if (flags.initrace >= 0) flags.initrace = -1;
+	    else panic("no available ROLE+race+gender+alignment combinations");
+	}
+	choices[n] = (const char *) 0;
+	if (n > 1)
+        sel = curses_character_dialog(choices, "Choose one of the following roles:");
+	else sel = 0;
+	if (sel >= 0) sel = pickmap[sel];
+	else if (sel == ROLE_NONE) {		/* Quit */
+	    clearlocks();
+	    curses_bail(0);
+	}
+	free(choices);
+	free(pickmap);
+    } else if (flags.initrole < 0) sel = ROLE_RANDOM;
+    else sel = flags.initrole;
+  
+    if (sel == ROLE_RANDOM) {	/* Random role */
+	sel = pick_role(flags.initrace, flags.initgend,
+			  flags.initalign, PICK_RANDOM);
+	if (sel < 0) sel = randrole();
+    }
+
+    flags.initrole = sel;
+
+    /* Select a race, if necessary */
+    /* force compatibility with role, try for compatibility with
+     * pre-selected gender/alignment */
+    if (flags.initrace < 0 || !validrace(flags.initrole, flags.initrace)) {
+	if (flags.initrace == ROLE_RANDOM || flags.randomall) {
+	    flags.initrace = pick_race(flags.initrole, flags.initgend,
+				       flags.initalign, PICK_RANDOM);
+	    if (flags.initrace < 0) flags.initrace = randrace(flags.initrole);
+	} else {
+	    /* Count the number of valid races */
+	    n = 0;	/* number valid */
+	    for (i = 0; races[i].noun; i++) {
+		if (ok_race(flags.initrole, i, flags.initgend, flags.initalign))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; races[i].noun; i++) {
+		    if (validrace(flags.initrole, i)) n++;
+		}
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; races[i].noun; i++) {
+		if (ok_race(flags.initrole, i, flags.initgend,
+			    flags.initalign)) {
+		    choices[n] = races[i].noun;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following races:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initrace = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initrace == ROLE_RANDOM) {	/* Random role */
+	    sel = pick_race(flags.initrole, flags.initgend,
+			    flags.initalign, PICK_RANDOM);
+	    if (sel < 0) sel = randrace(flags.initrole);
+	    flags.initrace = sel;
+	}
+    }
+
+    /* Select a gender, if necessary */
+    /* force compatibility with role/race, try for compatibility with
+     * pre-selected alignment */
+    if (flags.initgend < 0 ||
+	!validgend(flags.initrole, flags.initrace, flags.initgend)) {
+	if (flags.initgend == ROLE_RANDOM || flags.randomall) {
+	    flags.initgend = pick_gend(flags.initrole, flags.initrace,
+				       flags.initalign, PICK_RANDOM);
+	    if (flags.initgend < 0)
+		flags.initgend = randgend(flags.initrole, flags.initrace);
+	} else {
+	    /* Count the number of valid genders */
+	    n = 0;	/* number valid */
+	    for (i = 0; i < ROLE_GENDERS; i++) {
+		if (ok_gend(flags.initrole, flags.initrace, i, flags.initalign))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; i < ROLE_GENDERS; i++) {
+		    if (validgend(flags.initrole, flags.initrace, i)) n++;
+		}
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; i < ROLE_GENDERS; i++) {
+		if (ok_gend(flags.initrole, flags.initrace, i,
+				flags.initalign)) {
+		    choices[n] = genders[i].adj;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following genders:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initgend = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initgend == ROLE_RANDOM) {	/* Random gender */
+	    sel = pick_gend(flags.initrole, flags.initrace,
+			    flags.initalign, PICK_RANDOM);
+	    if (sel < 0) sel = randgend(flags.initrole, flags.initrace);
+	    flags.initgend = sel;
+	}
+    }
+
+    /* Select an alignment, if necessary */
+    /* force compatibility with role/race/gender */
+    if (flags.initalign < 0 ||
+	!validalign(flags.initrole, flags.initrace, flags.initalign)) {
+	if (flags.initalign == ROLE_RANDOM || flags.randomall) {
+	    flags.initalign = pick_align(flags.initrole, flags.initrace,
+					 flags.initgend, PICK_RANDOM);
+	    if (flags.initalign < 0)
+		flags.initalign = randalign(flags.initrole, flags.initrace);
+	} else {
+	    /* Count the number of valid alignments */
+	    n = 0;	/* number valid */
+	    for (i = 0; i < ROLE_ALIGNS; i++) {
+		if (ok_align(flags.initrole, flags.initrace, flags.initgend, i))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; i < ROLE_ALIGNS; i++)
+		    if (validalign(flags.initrole, flags.initrace, i)) n++;
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; i < ROLE_ALIGNS; i++) {
+		if (ok_align(flags.initrole,
+			     flags.initrace, flags.initgend, i)) {
+		    choices[n] = aligns[i].adj;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following alignments:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initalign = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initalign == ROLE_RANDOM) {
+	    sel = pick_align(flags.initrole, flags.initrace,
+			     flags.initgend, PICK_RANDOM);
+	    if (sel < 0) sel = randalign(flags.initrole, flags.initrace);
+	    flags.initalign = sel;
+	}
+    }
+}
+
+
+/* Prompt user for character race, role, alignment, or gender */
+
+int curses_character_dialog(const char** choices, const char *prompt)
+{
+    int count, count2, ret, curletter;
+    char used_letters[52];
+    anything identifier;
+    menu_item *selected = NULL;
+    winid wid = curses_get_wid(NHW_MENU);
+
+    identifier.a_void = 0;
+    curses_start_menu(wid);
+
+    for (count=0; choices[count]; count++)
+    {
+        curletter=tolower(choices[count][0]);
+        for (count2=0; count2<count; count2++)
+        {
+            if (curletter==used_letters[count2])
+            {
+                curletter=toupper(curletter);
+            }
+        }
+
+        identifier.a_int = (count + 1); /* Must be non-zero */
+        curses_add_menu(wid, NO_GLYPH, &identifier, curletter, 0,
+         A_NORMAL, choices[count], FALSE);
+        used_letters[count] = curletter;
+    }
+
+    /* Random Selection */
+    identifier.a_int = ROLE_RANDOM;
+    curses_add_menu(wid, NO_GLYPH, &identifier, '*', 0, A_NORMAL, "Random",
+     FALSE);    
+    
+    /* Quit prompt */
+    identifier.a_int = ROLE_NONE;
+    curses_add_menu(wid, NO_GLYPH, &identifier, 'q', 0, A_NORMAL, "Quit",
+     FALSE);    
+    curses_end_menu(wid, prompt);
+    ret = curses_select_menu(wid, PICK_ONE, &selected);
+    if (ret == 1)
+    {
+        ret = (selected->item.a_int);
+    }
+    else    /* Cancelled selection */
+    {
+        ret = ROLE_NONE;
+    }
+    
+    if (ret > 0)
+    {
+        ret--;
+    }
+    
+    free(selected);
+    return ret;
+}
+
+
+/* Initialize and display options appropriately */
+
+void curses_init_options()
+{
+    set_wc_option_mod_status(WC_ALIGN_MESSAGE|WC_ALIGN_STATUS|WC_COLOR|
+     WC_HILITE_PET|WC_POPUP_DIALOG, SET_IN_GAME);
+
+    set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_GAME);
+
+    /* Remove a few options that are irrelevant to this windowport */
+    set_option_mod_status("DECgraphics", SET_IN_FILE);
+    set_option_mod_status("perm_invent", SET_IN_FILE);
+    set_option_mod_status("eight_bit_tty", SET_IN_FILE);
+
+    /* Make sure that DECgraphics is not set to true via the config
+    file, as this will cause display issues.  We can't disable it in
+    options.c in case the game is compiled with both tty and curses.*/
+    if (iflags.DECgraphics)
+    {
+        switch_graphics(CURS_GRAPHICS);
+    }
+	
+#ifdef PDCURSES
+    /* PDCurses for SDL, win32 and OS/2 has the ability to set the
+     terminal size programatically.  If the user does not specify a
+     size in the config file, we will set it to a nice big 110x32 to
+     take advantage of some of the nice features of this windowport. */
+    if (iflags.wc2_term_cols == 0)
+    {
+        iflags.wc2_term_cols = 110;
+    }
+    
+    if (iflags.wc2_term_rows == 0)
+    {
+        iflags.wc2_term_rows = 32;
+    }
+    
+    resize_term(iflags.wc2_term_rows, iflags.wc2_term_cols);
+    getmaxyx(base_term, term_rows, term_cols);
+    
+    /* This is needed for an odd bug with PDCurses-SDL */
+    switch_graphics(ASCII_GRAPHICS);
+    if (iflags.IBMgraphics)
+    {
+        switch_graphics(IBM_GRAPHICS);
+    }
+    else if (iflags.cursesgraphics)
+    {
+        switch_graphics(CURS_GRAPHICS);
+    }
+    else
+    {
+        switch_graphics(ASCII_GRAPHICS);
+    }
+#endif  /* PDCURSES */
+    if (!iflags.wc2_windowborders)
+    {
+        iflags.wc2_windowborders = 3; /* Set to auto if not specified */
+    }
+    
+    if (!iflags.wc2_petattr)
+    {
+        iflags.wc2_petattr = A_REVERSE;
+    }
+    else    /* Pet attribute specified, so hilite_pet should be true */
+    {
+        iflags.hilite_pet = TRUE;
+    }
+
+#ifdef NCURSES_MOUSE_VERSION
+    if (iflags.wc_mouse_support)
+    {
+    	mousemask(BUTTON1_CLICKED, NULL);
+    }
+#endif
+}
+
+
+/* Display an ASCII splash screen if the splash_screen option is set */
+
+void curses_display_splash_window()
+{
+    int x_start = 1;
+    int y_start = 6;
+    int which_variant = NETHACK_CURSES;  /* Default to NetHack */
+
+    if ((term_cols < 70) || (term_rows < 20))
+    {
+        iflags.wc_splash_screen = FALSE;    /* No room for s.s. */
+    }
+    
+#ifdef DEF_GAME_NAME
+    if (strcmp(DEF_GAME_NAME, "SlashEM") == 0)
+    {
+        which_variant = SLASHEM_CURSES;
+    }
+#endif
+
+#ifdef GAME_SHORT_NAME
+    if (strcmp(GAME_SHORT_NAME, "UNH") == 0)
+    {
+        which_variant = UNNETHACK_CURSES;
+    }
+#endif
+
+    if (strncmp("SporkHack", COPYRIGHT_BANNER_A, 9) == 0)
+    {
+        which_variant = SPORKHACK_CURSES;
+    }
+
+    curses_toggle_color_attr(stdscr, CLR_WHITE, A_NORMAL, ON);
+
+    if (iflags.wc_splash_screen)
+    {
+        switch (which_variant)
+        {
+            case NETHACK_CURSES:
+            {
+                mvaddstr(y_start, x_start, NETHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, NETHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, NETHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, NETHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, NETHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, NETHACK_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case SLASHEM_CURSES:
+            {
+                mvaddstr(y_start, x_start, SLASHEM_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, SLASHEM_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, SLASHEM_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, SLASHEM_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, SLASHEM_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, SLASHEM_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case UNNETHACK_CURSES:
+            {
+                mvaddstr(y_start, x_start, UNNETHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, UNNETHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, UNNETHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, UNNETHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, UNNETHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, UNNETHACK_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case SPORKHACK_CURSES:
+                mvaddstr(y_start, x_start, SPORKHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, SPORKHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, SPORKHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, SPORKHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, SPORKHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, SPORKHACK_SPLASH_F);
+                mvaddstr(y_start + 6, x_start, SPORKHACK_SPLASH_G);
+                mvaddstr(y_start + 7, x_start, SPORKHACK_SPLASH_H);
+                y_start += 9;
+                break;
+            default:
+            {
+                impossible("which_variant number %d out of range",
+                 which_variant);
+            }
+        }
+    }
+
+    curses_toggle_color_attr(stdscr, CLR_WHITE, A_NORMAL, OFF);
+
+#ifdef COPYRIGHT_BANNER_A
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_A);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_B
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_B);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_C
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_C);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_D   /* Just in case */
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_D);
+    y_start++;
+#endif
+    refresh();
+}
+
+
+/* Resore colors and cursor state before exiting */
+
+void curses_cleanup()
+{
+#ifdef TEXTCOLOR
+    if (has_colors() && can_change_color())
+    {
+        init_color(COLOR_YELLOW, orig_yellow.r, orig_yellow.g,
+         orig_yellow.b);
+        init_color(COLOR_WHITE, orig_white.r, orig_white.g,
+         orig_white.b);
+         
+        if (COLORS >= 16)
+        {
+            init_color(COLOR_RED + 8, orig_hired.r, orig_hired.g,
+             orig_hired.b);
+            init_color(COLOR_GREEN + 8, orig_higreen.r, orig_higreen.g,
+             orig_higreen.b);
+            init_color(COLOR_YELLOW + 8, orig_hiyellow.r,
+             orig_hiyellow.g, orig_hiyellow.b);
+            init_color(COLOR_BLUE + 8, orig_hiblue.r, orig_hiblue.g,
+             orig_hiblue.b);
+            init_color(COLOR_MAGENTA + 8, orig_himagenta.r,
+             orig_himagenta.g, orig_himagenta.b);
+            init_color(COLOR_CYAN + 8, orig_hicyan.r, orig_hicyan.g,
+             orig_hicyan.b);
+            init_color(COLOR_WHITE + 8, orig_hiwhite.r, orig_hiwhite.g,
+             orig_hiwhite.b);
+# ifdef USE_DARKGRAY
+            if (COLORS > 16)
+            {
+                init_color(CURSES_DARK_GRAY, orig_darkgray.r,
+             orig_darkgray.g, orig_darkgray.b);
+            }
+# endif
+        }
+    }
+#endif
+}
+
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursinit.h nethack-3.4.3-nao-osx/win/curses/cursinit.h
--- nethack-3.4.3/win/curses/cursinit.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursinit.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,21 @@
+#ifndef CURSINIT_H
+#define CURSINIT_H
+
+/* Global declarations */
+
+void curses_create_main_windows(void);
+
+void curses_init_nhcolors(void);
+
+void curses_choose_character(void);
+
+int curses_character_dialog(const char** choices, const char *prompt);
+
+void curses_init_options(void);
+
+void curses_display_splash_window(void);
+
+void curses_cleanup(void);
+
+
+#endif  /* CURSINIT_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursmain.c nethack-3.4.3-nao-osx/win/curses/cursmain.c
--- nethack-3.4.3/win/curses/cursmain.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursmain.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,733 @@
+#include "curses.h"
+#include "hack.h"
+#include "patchlevel.h"
+#include "color.h"
+#include "wincurs.h"
+
+/* Public functions for curses NetHack interface */
+
+/* Interface definition, for windows.c */
+struct window_procs curses_procs = {
+    "curses",
+    WC_ALIGN_MESSAGE|WC_ALIGN_STATUS|WC_COLOR|WC_HILITE_PET|
+    WC_POPUP_DIALOG|WC_SPLASH_SCREEN,
+    WC2_TERM_COLS|WC2_TERM_ROWS|WC2_WINDOWBORDERS|WC2_PETATTR|
+     WC2_GUICOLOR,
+    curses_init_nhwindows,
+    curses_player_selection,
+    curses_askname,
+    curses_get_nh_event,
+    curses_exit_nhwindows,
+    curses_suspend_nhwindows,
+    curses_resume_nhwindows,
+    curses_create_nhwindow,
+    curses_clear_nhwindow,
+    curses_display_nhwindow,
+    curses_destroy_nhwindow,
+    curses_curs,
+    curses_putstr,
+    curses_display_file,
+    curses_start_menu,
+    curses_add_menu,
+    curses_end_menu,
+    curses_select_menu,
+    genl_message_menu,
+    curses_update_inventory,
+    curses_mark_synch,
+    curses_wait_synch,
+#ifdef CLIPPING
+    curses_cliparound,
+#endif
+#ifdef POSITIONBAR
+    donull,
+#endif
+    curses_print_glyph,
+    curses_raw_print,
+    curses_raw_print_bold,
+    curses_nhgetch,
+    curses_nh_poskey,
+    curses_nhbell,
+    curses_doprev_message,
+    curses_yn_function,
+    curses_getlin,
+    curses_get_ext_cmd,
+    curses_number_pad,
+    curses_delay_output,
+#ifdef CHANGE_COLOR	/* only a Mac option currently */
+    donull,
+    donull,
+#endif
+    curses_start_screen,
+    curses_end_screen,
+    genl_outrip,
+    curses_preference_update,
+};
+
+/*  
+init_nhwindows(int* argcp, char** argv)
+                -- Initialize the windows used by NetHack.  This can also
+                   create the standard windows listed at the top, but does
+                   not display them.
+                -- Any commandline arguments relevant to the windowport
+                   should be interpreted, and *argcp and *argv should
+                   be changed to remove those arguments.
+                -- When the message window is created, the variable
+                   iflags.window_inited needs to be set to TRUE.  Otherwise
+                   all plines() will be done via raw_print().
+                ** Why not have init_nhwindows() create all of the "standard"
+                ** windows?  Or at least all but WIN_INFO?      -dean
+*/
+void curses_init_nhwindows(int* argcp, char** argv)
+{
+#ifdef PDCURSES
+    char window_title[BUFSZ];
+#endif
+
+#ifdef XCURSES
+    base_term = Xinitscr(*argcp, argv);
+#else
+    base_term = initscr();
+#endif
+#ifdef TEXTCOLOR
+    if (has_colors())
+    {
+        start_color();
+        curses_init_nhcolors();
+    }
+    else
+    {
+        iflags.use_color = FALSE;
+        set_option_mod_status("color", SET_IN_FILE);
+        iflags.wc2_guicolor = FALSE;
+        set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_FILE);    
+    }
+#else
+    iflags.use_color = FALSE;
+    set_option_mod_status("color", SET_IN_FILE);    
+    iflags.wc2_guicolor = FALSE;
+    set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_FILE);    
+#endif
+    noecho();
+    raw();
+    meta(stdscr, TRUE);
+    orig_cursor = curs_set(0);
+    keypad(stdscr, TRUE);
+#ifdef NCURSES_VERSION
+# ifdef __APPLE__
+ ESCDELAY = 25;
+# else
+    set_escdelay(25);
+# endif /* __APPLE__ */
+#endif  /* NCURSES_VERSION */
+#ifdef PDCURSES
+# ifdef DEF_GAME_NAME
+#  ifdef VERSION_STRING
+    sprintf(window_title, "%s %s", DEF_GAME_NAME, VERSION_STRING);
+#  else
+    sprintf(window_title, "%s", DEF_GAME_NAME);
+#  endif /* VERSION_STRING */
+# else
+#  ifdef VERSION_STRING
+    sprintf(window_title, "%s %s", "NetHack", VERSION_STRING);
+#  else
+    sprintf(window_title, "%s", "NetHack");
+#  endif /* VERSION_STRING */
+# endif /* DEF_GAME_NAME */
+    PDC_set_title(window_title);
+    PDC_set_blink(TRUE);    /* Only if the user asks for it! */
+    timeout(1);
+    (void)getch();
+    timeout(-1);
+#endif  /* PDCURSES */
+    getmaxyx(base_term, term_rows, term_cols);
+    counting = FALSE;
+    curses_init_options();
+    if ((term_rows < 15) || (term_cols < 40))
+    {
+        panic("Terminal too small.  Must be minumum 40 width and 15 height");
+    }
+
+    curses_create_main_windows();
+    curses_init_mesg_history();
+    curses_display_splash_window();
+}
+
+
+/* Do a window-port specific player type selection. If player_selection()
+   offers a Quit option, it is its responsibility to clean up and terminate
+   the process. You need to fill in pl_character[0].
+*/
+void curses_player_selection()
+{
+    curses_choose_character();
+}
+
+
+/* Ask the user for a player name. */
+void curses_askname()
+{
+    curses_line_input_dialog("Who are you?", plname, PL_NSIZ);
+}
+
+
+/* Does window event processing (e.g. exposure events).
+   A noop for the tty and X window-ports.
+*/
+void curses_get_nh_event()
+{
+#ifdef PDCURSES
+    if (is_termresized())
+    {
+        resize_term(0, 0);
+        getmaxyx(base_term, term_rows, term_cols);
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+#endif
+#ifdef NCURSES_VERSION  /* Is there a better way to detect ncurses? */
+    if (is_term_resized(term_rows, term_cols))
+    {
+        if (!isendwin())
+        {
+            endwin();
+        }
+        
+        refresh();
+        getmaxyx(base_term, term_rows, term_cols);
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+#endif
+}
+
+/* Exits the window system.  This should dismiss all windows,
+   except the "window" used for raw_print().  str is printed if possible.
+*/
+void curses_exit_nhwindows(const char *str)
+{
+    curses_cleanup();
+    curs_set(orig_cursor);
+    endwin();
+    iflags.window_inited = 0;
+    if (str != NULL)
+    {
+        raw_print(str);
+    }
+}
+
+/* Prepare the window to be suspended. */
+void curses_suspend_nhwindows(const char *str)
+{
+    endwin();
+}
+
+
+/* Restore the windows after being suspended. */
+void curses_resume_nhwindows()
+{
+    curses_refresh_nethack_windows();
+}
+
+/*  Create a window of type "type" which can be 
+        NHW_MESSAGE     (top line)
+        NHW_STATUS      (bottom lines)
+        NHW_MAP         (main dungeon)
+        NHW_MENU        (inventory or other "corner" windows)
+        NHW_TEXT        (help/text, full screen paged window)
+*/
+winid curses_create_nhwindow(int type)
+{
+    winid wid = curses_get_wid(type);
+
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_start_menu(wid);
+        curses_add_wid(wid);
+    }
+    
+    return wid;
+}
+
+
+/* Clear the given window, when asked to. */
+void curses_clear_nhwindow(winid wid)
+{
+    if (wid != NHW_MESSAGE)
+    {
+        curses_clear_nhwin(wid);
+    }
+}
+
+/* -- Display the window on the screen.  If there is data
+                   pending for output in that window, it should be sent.
+                   If blocking is TRUE, display_nhwindow() will not
+                   return until the data has been displayed on the screen,
+                   and acknowledged by the user where appropriate.
+                -- All calls are blocking in the tty window-port.
+                -- Calling display_nhwindow(WIN_MESSAGE,???) will do a
+                   --more--, if necessary, in the tty window-port.
+*/
+void curses_display_nhwindow(winid wid, BOOLEAN_P block)
+{
+    menu_item *selected = NULL;
+
+    if ((wid == MAP_WIN) && block)
+    {
+      (void) curses_more();
+    }
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_end_menu(wid, "");
+        curses_select_menu(wid, PICK_NONE, &selected);
+        return;
+    }
+    
+}
+
+
+/* Destroy will dismiss the window if the window has not 
+ * already been dismissed.
+*/
+void curses_destroy_nhwindow(winid wid)
+{
+    curses_del_nhwin(wid);
+}
+
+/* Next output to window will start at (x,y), also moves
+ displayable cursor to (x,y).  For backward compatibility,
+ 1 <= x < cols, 0 <= y < rows, where cols and rows are
+ the size of window.
+*/
+void curses_curs(winid wid, int x, int y)
+{
+    curses_move_cursor(wid, x, y);
+}
+
+/*
+putstr(window, attr, str)
+                -- Print str on the window with the given attribute.  Only
+                   printable ASCII characters (040-0126) must be supported.
+                   Multiple putstr()s are output on separate lines.
+Attributes
+                   can be one of
+                        ATR_NONE (or 0)
+                        ATR_ULINE
+                        ATR_BOLD
+                        ATR_BLINK
+                        ATR_INVERSE
+                   If a window-port does not support all of these, it may map
+                   unsupported attributes to a supported one (e.g. map them
+                   all to ATR_INVERSE).  putstr() may compress spaces out of
+                   str, break str, or truncate str, if necessary for the
+                   display.  Where putstr() breaks a line, it has to clear
+                   to end-of-line.
+                -- putstr should be implemented such that if two putstr()s
+                   are done consecutively the user will see the first and
+                   then the second.  In the tty port, pline() achieves this
+                   by calling more() or displaying both on the same line.
+*/
+void curses_putstr(winid wid, int attr, const char *text)
+{
+    int curses_attr = curses_convert_attr(attr);
+    
+    /* We need to convert NetHack attributes to curses attributes */
+    curses_puts(wid, curses_attr, text);
+}
+
+/* Display the file named str.  Complain about missing files
+                   iff complain is TRUE.
+*/
+void curses_display_file(const char *filename,BOOLEAN_P must_exist)
+{
+    curses_view_file(filename, must_exist);
+}
+
+/* Start using window as a menu.  You must call start_menu()
+   before add_menu().  After calling start_menu() you may not
+   putstr() to the window.  Only windows of type NHW_MENU may
+   be used for menus.
+*/
+void curses_start_menu(winid wid)
+{
+    curses_create_nhmenu(wid);
+}
+
+/*
+add_menu(winid wid, int glyph, const anything identifier,
+                                char accelerator, char groupacc,
+                                int attr, char *str, boolean preselected)
+                -- Add a text line str to the given menu window.  If identifier
+                   is 0, then the line cannot be selected (e.g. a title).
+                   Otherwise, identifier is the value returned if the line is
+                   selected.  Accelerator is a keyboard key that can be used
+                   to select the line.  If the accelerator of a selectable
+                   item is 0, the window system is free to select its own
+                   accelerator.  It is up to the window-port to make the
+                   accelerator visible to the user (e.g. put "a - " in front
+                   of str).  The value attr is the same as in putstr().
+                   Glyph is an optional glyph to accompany the line.  If
+                   window port cannot or does not want to display it, this
+                   is OK.  If there is no glyph applicable, then this
+                   value will be NO_GLYPH.
+                -- All accelerators should be in the range [A-Za-z].
+                -- It is expected that callers do not mix accelerator
+                   choices.  Either all selectable items have an accelerator
+                   or let the window system pick them.  Don't do both.
+                -- Groupacc is a group accelerator.  It may be any character
+                   outside of the standard accelerator (see above) or a
+                   number.  If 0, the item is unaffected by any group
+                   accelerator.  If this accelerator conflicts with
+                   the menu command (or their user defined alises), it loses.
+                   The menu commands and aliases take care not to interfere
+                   with the default object class symbols.
+                -- If you want this choice to be preselected when the
+                   menu is displayed, set preselected to TRUE.
+*/
+void curses_add_menu(winid wid, int glyph, const ANY_P * identifier,
+		CHAR_P accelerator, CHAR_P group_accel, int attr, 
+		const char *str, BOOLEAN_P presel)
+{
+    int curses_attr = curses_convert_attr(attr);
+
+    curses_add_nhmenu_item(wid, identifier, accelerator, group_accel,
+     curses_attr, str, presel);
+}
+
+/*
+end_menu(window, prompt)
+                -- Stop adding entries to the menu and flushes the window
+                   to the screen (brings to front?).  Prompt is a prompt
+                   to give the user.  If prompt is NULL, no prompt will
+                   be printed.
+                ** This probably shouldn't flush the window any more (if
+                ** it ever did).  That should be select_menu's job.  -dean
+*/
+void curses_end_menu(winid wid, const char *prompt)
+{
+    curses_finalize_nhmenu(wid, prompt);
+}
+
+/*
+int select_menu(winid window, int how, menu_item **selected)
+                -- Return the number of items selected; 0 if none were chosen,
+                   -1 when explicitly cancelled.  If items were selected, then
+                   selected is filled in with an allocated array of menu_item
+                   structures, one for each selected line.  The caller must
+                   free this array when done with it.  The "count" field
+                   of selected is a user supplied count.  If the user did
+                   not supply a count, then the count field is filled with
+                   -1 (meaning all).  A count of zero is equivalent to not
+                   being selected and should not be in the list.  If no items
+                   were selected, then selected is NULL'ed out.  How is the
+                   mode of the menu.  Three valid values are PICK_NONE,
+                   PICK_ONE, and PICK_N, meaning: nothing is selectable,
+                   only one thing is selectable, and any number valid items
+                   may selected.  If how is PICK_NONE, this function should
+                   never return anything but 0 or -1.
+                -- You may call select_menu() on a window multiple times --
+                   the menu is saved until start_menu() or destroy_nhwindow()
+                   is called on the window.
+                -- Note that NHW_MENU windows need not have select_menu()
+                   called for them. There is no way of knowing whether
+                   select_menu() will be called for the window at
+                   create_nhwindow() time.
+*/
+int curses_select_menu(winid wid, int how, MENU_ITEM_P **selected)
+{
+    return curses_display_nhmenu(wid, how, selected);
+}
+
+/*
+    -- Indicate to the window port that the inventory has been changed.
+    -- Merely calls display_inventory() for window-ports that leave the 
+	window up, otherwise empty.
+*/
+void curses_update_inventory()
+{
+}
+
+/*
+mark_synch()    -- Don't go beyond this point in I/O on any channel until
+                   all channels are caught up to here.  Can be an empty call
+                   for the moment
+*/
+void curses_mark_synch()
+{
+}
+
+/*
+wait_synch()    -- Wait until all pending output is complete (*flush*() for
+                   streams goes here).
+                -- May also deal with exposure events etc. so that the
+                   display is OK when return from wait_synch().
+*/
+void curses_wait_synch()
+{
+}
+
+/*
+cliparound(x, y)-- Make sure that the user is more-or-less centered on the
+                   screen if the playing area is larger than the screen.
+                -- This function is only defined if CLIPPING is defined.
+*/
+void curses_cliparound(int x, int y)
+{
+    int sx, sy, ex, ey;
+    boolean redraw = curses_map_borders(&sx, &sy, &ex, &ey, x, y);
+    
+    if (redraw)
+    {
+        curses_draw_map(sx, sy, ex, ey);
+    }
+}
+
+/*
+print_glyph(window, x, y, glyph)
+                -- Print the glyph at (x,y) on the given window.  Glyphs are
+                   integers at the interface, mapped to whatever the window-
+                   port wants (symbol, font, color, attributes, ...there's
+                   a 1-1 map between glyphs and distinct things on the map).
+*/
+void curses_print_glyph(winid wid, XCHAR_P x, XCHAR_P y, int glyph)
+{
+    glyph_t ch;
+    int color;
+    unsigned int special;
+    int attr = -1;
+
+    /* map glyph to character and color */
+    mapglyph(glyph, &ch, &color, &special, x, y);
+    if ((special & MG_PET) && iflags.hilite_pet)
+    {
+        attr = iflags.wc2_petattr;
+    }
+    if ((special & MG_DETECT) && iflags.use_inverse)
+	{
+	    attr = A_REVERSE;
+	}
+	if (iflags.cursesgraphics)
+	{
+	    ch = curses_convert_glyph(ch, glyph);
+	}
+
+	if (wid == NHW_MAP) {
+	    if ((special & MG_STAIRS) && iflags.hilite_hidden_stairs) {
+		color = 16 + (color*2);
+	    } else if ((special & MG_OBJPILE) && iflags.hilite_obj_piles) {
+		color = 16 + (color*2) + 1;
+	    }
+	}
+
+    curses_putch(wid, x, y, ch, color, attr);
+}
+
+/*
+raw_print(str)  -- Print directly to a screen, or otherwise guarantee that
+                   the user sees str.  raw_print() appends a newline to str.
+                   It need not recognize ASCII control characters.  This is
+                   used during startup (before windowing system initialization
+                   -- maybe this means only error startup messages are raw),
+                   for error messages, and maybe other "msg" uses.  E.g.
+                   updating status for micros (i.e, "saving").
+*/
+void curses_raw_print(const char *str)
+{
+    puts(str);
+}
+
+/*
+raw_print_bold(str)
+            -- Like raw_print(), but prints in bold/standout (if possible).
+*/
+void curses_raw_print_bold(const char *str)
+{
+    curses_raw_print(str);
+}
+
+/*
+int nhgetch()   -- Returns a single character input from the user.
+                -- In the tty window-port, nhgetch() assumes that tgetch()
+                   will be the routine the OS provides to read a character.
+                   Returned character _must_ be non-zero.
+*/
+int curses_nhgetch()
+{    
+    int ch;
+    
+    curses_prehousekeeping();
+    ch = curses_read_char();
+    curses_posthousekeeping();
+    
+    return ch;
+}
+
+/*
+int nh_poskey(int *x, int *y, int *mod)
+                -- Returns a single character input from the user or a
+                   a positioning event (perhaps from a mouse).  If the
+                   return value is non-zero, a character was typed, else,
+                   a position in the MAP window is returned in x, y and mod.
+                   mod may be one of
+
+                        CLICK_1         -- mouse click type 1 
+                        CLICK_2         -- mouse click type 2 
+
+                   The different click types can map to whatever the
+                   hardware supports.  If no mouse is supported, this
+                   routine always returns a non-zero character.
+*/
+int curses_nh_poskey(int *x, int *y, int *mod)
+{
+    int key = curses_nhgetch();
+    
+#ifdef NCURSES_MOUSE_VERSION
+    /* Mouse event if mouse_support is true */
+    if (key == KEY_MOUSE)
+    {
+        key = curses_get_mouse(x, y, mod);
+    }
+#endif
+
+    return key;
+}
+
+/*
+nhbell()        -- Beep at user.  [This will exist at least until sounds are
+                   redone, since sounds aren't attributable to windows anyway.]
+*/
+void curses_nhbell()
+{
+    beep();
+}
+
+/*
+doprev_message()
+                -- Display previous messages.  Used by the ^P command.
+                -- On the tty-port this scrolls WIN_MESSAGE back one line.
+*/
+int curses_doprev_message()
+{
+    curses_prev_mesg();
+    return 0;
+}
+
+/*
+char yn_function(const char *ques, const char *choices, char default)
+                -- Print a prompt made up of ques, choices and default.
+                   Read a single character response that is contained in
+                   choices or default.  If choices is NULL, all possible
+                   inputs are accepted and returned.  This overrides
+                   everything else.  The choices are expected to be in
+                   lower case.  Entering ESC always maps to 'q', or 'n',
+                   in that order, if present in choices, otherwise it maps
+                   to default.  Entering any other quit character (SPACE,
+                   RETURN, NEWLINE) maps to default.
+                -- If the choices string contains ESC, then anything after
+                   it is an acceptable response, but the ESC and whatever
+                   follows is not included in the prompt.
+                -- If the choices string contains a '#' then accept a count.
+                   Place this value in the global "yn_number" and return '#'.
+                -- This uses the top line in the tty window-port, other
+                   ports might use a popup.
+*/
+char curses_yn_function(const char *question, const char *choices, CHAR_P def)
+{
+    return (char)curses_character_input_dialog(question, choices, def);
+}
+
+/*
+getlin(const char *ques, char *input)
+	    -- Prints ques as a prompt and reads a single line of text,
+	       up to a newline.  The string entered is returned without the
+	       newline.  ESC is used to cancel, in which case the string
+	       "\033\000" is returned.
+	    -- getlin() must call flush_screen(1) before doing anything.
+	    -- This uses the top line in the tty window-port, other
+	       ports might use a popup.
+*/
+void curses_getlin(const char *question, char *input)
+{
+    curses_line_input_dialog(question, input, BUFSZ);
+}
+
+/*
+int get_ext_cmd(void)
+	    -- Get an extended command in a window-port specific way.
+	       An index into extcmdlist[] is returned on a successful
+	       selection, -1 otherwise.
+*/
+int curses_get_ext_cmd()
+{
+    return curses_ext_cmd();
+}
+
+
+/*
+number_pad(state)
+	    -- Initialize the number pad to the given state.
+*/
+void curses_number_pad(int state)
+{
+}
+
+/*
+delay_output()  -- Causes a visible delay of 50ms in the output.
+	       Conceptually, this is similar to wait_synch() followed
+	       by a nap(50ms), but allows asynchronous operation.
+*/
+void curses_delay_output()
+{
+    napms(50);
+}
+
+/*
+start_screen()  -- Only used on Unix tty ports, but must be declared for
+	       completeness.  Sets up the tty to work in full-screen
+	       graphics mode.  Look at win/tty/termcap.c for an
+	       example.  If your window-port does not need this function
+	       just declare an empty function.
+*/
+void curses_start_screen()
+{
+}
+
+/*
+end_screen()    -- Only used on Unix tty ports, but must be declared for
+	       completeness.  The complement of start_screen().
+*/
+void curses_end_screen()
+{
+}
+
+/*
+outrip(winid, int)
+	    -- The tombstone code.  If you want the traditional code use
+	       genl_outrip for the value and check the #if in rip.c.
+*/
+void curses_outrip(winid wid, int how)
+{
+}
+
+/*
+preference_update(preference)
+		-- The player has just changed one of the wincap preference
+		   settings, and the NetHack core is notifying your window
+		   port of that change.  If your window-port is capable of
+		   dynamically adjusting to the change then it should do so.
+		   Your window-port will only be notified of a particular
+		   change if it indicated that it wants to be by setting the 
+		   corresponding bit in the wincap mask.
+*/
+void curses_preference_update(const char *pref)
+{
+    if ((strcmp(pref, "align_status") == 0) ||
+     (strcmp(pref, "align_message") == 0))
+    {
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+}
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursmesg.c nethack-3.4.3-nao-osx/win/curses/cursmesg.c
--- nethack-3.4.3/win/curses/cursmesg.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursmesg.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,485 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursmesg.h"
+
+/* Message window routines for curses interface */
+
+/* Private declatations */
+
+typedef struct nhpm
+{
+    char *str;  /* Message text */
+    long turn;  /* Turn number for message */
+    struct nhpm *prev_mesg;    /* Pointer to previous message */
+    struct nhpm *next_mesg;    /* Pointer to next message */
+} nhprev_mesg;
+
+static void scroll_window(winid wid);
+
+static void mesg_add_line(char *mline);
+
+static nhprev_mesg *get_msg_line(boolean reverse, int mindex);
+
+static int turn_lines = 1;
+static int mx = 0;
+static int my = 0;  /* message window text location */
+static nhprev_mesg *first_mesg = NULL;
+static nhprev_mesg *last_mesg = NULL;
+static int max_messages;
+static int num_messages = 0;
+
+
+
+/* Write a string to the message window.  Attributes set by calling function. */
+
+void curses_message_win_puts(const char *message, boolean recursed)
+{
+    int height, width, linespace;
+    char *tmpstr;
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+    int message_length = strlen(message);
+    int border_space = 0;
+    static long suppress_turn = -1;
+
+    if (strncmp("Count:", message, 6) == 0)
+    {
+        curses_count_window(message);
+        return;
+    }
+    
+    if (suppress_turn == moves)
+    {
+        return;
+    }
+    
+    curses_get_window_size(MESSAGE_WIN, &height, &width);
+    if (border)
+    {
+        border_space = 1;
+        if (mx < 1)
+        {
+            mx = 1;
+        }
+        if (my < 1)
+        {
+            my = 1;
+        }
+    }
+    
+    linespace = ((width + border_space) - 3) - mx;
+    
+    if (strcmp(message, "#") == 0)  /* Extended command or Count: */
+    {
+        if ((strcmp(toplines, "#") != 0) && (my >= (height - 1 +
+         border_space)) && (height != 1)) /* Bottom of message window */
+        {
+            scroll_window(MESSAGE_WIN);
+            mx = width;
+            my--;
+            strcpy(toplines, message);
+        }
+        
+        return;
+    }
+
+    if (!recursed)
+    {
+        strcpy(toplines, message);
+        mesg_add_line((char *) message);
+    }
+    
+    if (linespace < message_length)
+    {
+        if (my >= (height - 1 + border_space)) /* bottom of message win */
+        {
+            if ((turn_lines > height) || (height == 1))
+            {
+                /* Pause until key is hit - Esc suppresses any further
+                messages that turn */
+                if (curses_more() == DOESCAPE)
+                {
+                    suppress_turn = moves;
+                    return;
+                }
+            }
+            else
+            {
+                scroll_window(MESSAGE_WIN);
+                turn_lines++;
+            }
+        }
+        else
+        {
+            if (mx != border_space)
+            {
+                my++;
+                mx = border_space;
+            }
+        }
+    }
+
+    if (height > 1)
+    {
+        curses_toggle_color_attr(win, NONE, A_BOLD, ON);
+    }
+    
+    if ((mx == border_space) && ((message_length + 2) > width))
+    {
+        tmpstr = curses_break_str(message, (width - 2), 1);
+        mvwprintw(win, my, mx, "%s", tmpstr);
+        mx += strlen(tmpstr);
+        if (strlen(tmpstr) < (width - 2))
+        {
+            mx++;
+        }
+        free(tmpstr);
+        if (height > 1)
+        {
+            curses_toggle_color_attr(win, NONE, A_BOLD, OFF);
+        }
+        wrefresh(win);
+        curses_message_win_puts(curses_str_remainder(message, (width - 2), 1),
+         TRUE);
+    }
+    else
+    {
+        mvwprintw(win, my, mx, "%s", message);
+        curses_toggle_color_attr(win, NONE, A_BOLD, OFF);
+        mx += message_length + 1;
+    }
+    wrefresh(win);
+}
+
+
+int curses_more()
+{
+    int height, width, ret;
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+    
+    curses_get_window_size(MESSAGE_WIN, &height, &width);
+    curses_toggle_color_attr(win, MORECOLOR, NONE, ON);
+    mvwprintw(win, my, mx, ">>");
+    curses_toggle_color_attr(win, MORECOLOR, NONE, OFF);
+    wrefresh(win);
+    ret = wgetch(win);
+    if (height == 1)
+    {
+        curses_clear_unhighlight_message_window();
+    }
+    else
+    {
+        mvwprintw(win, my, mx, "  ");
+        scroll_window(MESSAGE_WIN);
+        turn_lines = 1;
+    }
+    
+    return ret;
+}
+
+
+/* Clear the message window if one line; otherwise unhighlight old messages */
+
+void curses_clear_unhighlight_message_window()
+{
+    int mh, mw, count;
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+
+    turn_lines = 1;
+    
+    curses_get_window_size(MESSAGE_WIN, &mh, &mw); 
+    
+    mx = 0;
+    
+    if (border)
+    {
+        mx++;
+    }
+       
+    if (mh == 1)
+    {
+        curses_clear_nhwin(MESSAGE_WIN);
+    }
+    else
+    {
+        mx += mw;    /* Force new line on new turn */
+        
+        if (border)
+        {
+
+            for (count = 0; count < mh; count++)
+            {
+                mvwchgat(win, count+1, 1, mw, COLOR_PAIR(8), A_NORMAL, NULL);
+            }
+        }
+        else
+        {
+            for (count = 0; count < mh; count++)
+            {
+                mvwchgat(win, count, 0, mw, COLOR_PAIR(8), A_NORMAL, NULL);
+            }
+        }
+
+        wrefresh(win);
+    }
+}
+
+
+/* Reset message window cursor to starting position, and display most
+recent messages. */
+
+void curses_last_messages()
+{
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+
+    if (border)
+    {
+        mx = 1;
+        my = 1;
+    }
+    else
+    {
+        mx = 0;
+        my = 0;
+    }
+    
+    pline("%s", toplines);
+}
+
+
+/* Initialize list for message history */
+
+void curses_init_mesg_history()
+{
+    max_messages = iflags.msg_history;
+    
+    if (max_messages < 1)
+    {
+        max_messages = 1;
+    }
+
+    if (max_messages > MESG_HISTORY_MAX)
+    {
+        max_messages = MESG_HISTORY_MAX;
+    }
+}
+
+
+/* Display previous message window messages in reverse chron order */
+
+void curses_prev_mesg()
+{
+    int count;
+    winid wid;
+    long turn = 0;
+    anything *identifier;
+    nhprev_mesg *mesg;
+    menu_item *selected = NULL;
+
+    wid = curses_get_wid(NHW_MENU);
+    curses_create_nhmenu(wid);
+    identifier = malloc(sizeof(anything));
+    identifier->a_void = NULL;
+    
+    for (count = 0; count < num_messages; count++)
+    {
+        mesg = get_msg_line(TRUE, count);
+        if ((turn != mesg->turn) && (count != 0))
+        {
+            curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL,
+             "---", FALSE);
+        }
+        curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL,
+         mesg->str, FALSE);
+        turn = mesg->turn;
+    }
+    
+    curses_end_menu(wid, "");
+    curses_select_menu(wid, PICK_NONE, &selected);
+}
+
+
+/* Shows Count: in a separate window, or at the bottom of the message
+window, depending on the user's settings */
+
+void curses_count_window(const char *count_text)
+{
+    int startx, starty, winx, winy;
+    int messageh, messagew;
+    static WINDOW *countwin = NULL;
+
+    if ((count_text == NULL) && (countwin != NULL))
+    {
+        delwin(countwin);
+        countwin = NULL;
+        counting = FALSE;
+        return;
+    }
+    
+    counting = TRUE;
+
+    if (iflags.wc_popup_dialog) /* Display count in popup window */
+    {
+        startx = 1;
+        starty = 1;
+        
+        if (countwin == NULL)
+        {
+            countwin = curses_create_window(25, 1, UP);
+        }
+    
+    }
+    else /* Display count at bottom of message window */
+    {
+        curses_get_window_xy(MESSAGE_WIN, &winx, &winy);
+        curses_get_window_size(MESSAGE_WIN, &messageh, &messagew);
+        
+        if (curses_window_has_border(MESSAGE_WIN))
+        {
+            winx++;
+            winy++;
+        }
+        
+        winy += messageh - 1;
+        
+        if (countwin == NULL)
+        {
+            pline("#");
+#ifndef PDCURSES
+            countwin = newwin(1, 25, winy, winx);
+#endif  /* !PDCURSES */
+        }
+#ifdef PDCURSES
+        else
+        {
+            curses_destroy_win(countwin);
+        }
+        
+        countwin = newwin(1, 25, winy, winx);
+#endif  /* PDCURSES */
+        startx = 0;
+        starty = 0;
+    }
+    
+    mvwprintw(countwin, starty, startx, "%s", count_text);
+    wrefresh(countwin);
+}
+
+
+/* Scroll lines upward in given window, or clear window if only one line. */
+
+static void scroll_window(winid wid)
+{
+    int wh, ww, s_top, s_bottom;
+    boolean border = curses_window_has_border(wid);
+    WINDOW *win = curses_get_nhwin(wid);
+    
+    curses_get_window_size(wid, &wh, &ww);
+    if (wh == 1)
+    {
+        curses_clear_nhwin(wid);
+        return;
+    }
+    if (border)
+    {
+        s_top = 1;
+        s_bottom = wh;
+    }
+    else
+    {
+        s_top = 0;
+        s_bottom = wh - 1;
+    }
+    scrollok(win, TRUE);
+    wsetscrreg(win, s_top, s_bottom);
+    scroll(win);
+    scrollok(win, FALSE);
+    if (wid == MESSAGE_WIN)
+    {
+        if (border)
+            mx = 1;
+        else
+            mx = 0;
+    }
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+    wrefresh(win);
+}
+
+
+/* Add given line to message history */
+
+static void mesg_add_line(char *mline)
+{
+    nhprev_mesg *tmp_mesg = NULL;
+    nhprev_mesg *current_mesg = malloc(sizeof(nhprev_mesg));
+
+    current_mesg->str = curses_copy_of(mline);
+    current_mesg->turn = moves;
+    current_mesg->next_mesg = NULL;
+
+    if (num_messages == 0)
+    {
+        first_mesg = current_mesg;
+    }
+    
+    if (last_mesg != NULL)
+    {
+        last_mesg->next_mesg = current_mesg;
+    }
+    current_mesg->prev_mesg = last_mesg;
+    last_mesg = current_mesg;
+
+
+    if (num_messages < max_messages)
+    {
+        num_messages++;
+    }
+    else
+    {
+        tmp_mesg = first_mesg->next_mesg;
+        free(first_mesg);
+        first_mesg = tmp_mesg;
+    }
+}
+
+
+/* Returns specified line from message history, or NULL if out of bounds */
+
+static nhprev_mesg *get_msg_line(boolean reverse, int mindex)
+{
+    int count;
+    nhprev_mesg *current_mesg;
+
+    if (reverse)
+    {
+        current_mesg = last_mesg;
+        for (count = 0; count < mindex; count++)
+        {
+            if (current_mesg == NULL)
+            {
+                return NULL;
+            }
+            current_mesg = current_mesg->prev_mesg;
+        }
+        return current_mesg;
+    }
+    else
+    {
+        current_mesg = first_mesg;
+        for (count = 0; count < mindex; count++)
+        {
+            if (current_mesg == NULL)
+            {
+                return NULL;
+            }
+            current_mesg = current_mesg->next_mesg;
+        }
+        return current_mesg;
+    }
+}
+
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursmesg.h nethack-3.4.3-nao-osx/win/curses/cursmesg.h
--- nethack-3.4.3/win/curses/cursmesg.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursmesg.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,21 @@
+#ifndef CURSMESG_H
+#define CURSMESG_H
+
+
+/* Global declarations */
+
+void curses_message_win_puts(const char *message, boolean recursed);
+
+int curses_more(void);
+
+void curses_clear_unhighlight_message_window(void);
+
+void curses_last_messages(void);
+
+void curses_init_mesg_history(void);
+
+void curses_prev_mesg(void);
+
+void curses_count_window(const char *count_text);
+
+#endif  /* CURSMESG_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursmisc.c nethack-3.4.3-nao-osx/win/curses/cursmisc.c
--- nethack-3.4.3/win/curses/cursmisc.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursmisc.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,1006 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursmisc.h"
+#include "func_tab.h"
+#include "dlb.h"
+
+#include <ctype.h>
+
+/* Misc. curses interface functions */
+
+/* Private declarations */
+
+static int curs_x = -1;
+static int curs_y = -1;
+
+static int parse_escape_sequence(void);
+
+/* Macros for Control and Alt keys */
+
+#ifndef M
+# ifndef NHSTDC
+#  define M(c)		(0x80 | (c))
+# else
+#  define M(c)		((c) - 128)
+# endif /* NHSTDC */
+#endif
+#ifndef C
+#define C(c)		(0x1f & (c))
+#endif
+
+
+/* Read a character of input from the user */
+
+int curses_read_char()
+{
+    int ch, tmpch;
+    
+    ch = getch();
+    tmpch = ch;
+    ch = curses_convert_keys(ch);
+
+    if (ch == 0)
+    {
+        ch = DOESCAPE; /* map NUL to ESC since nethack doesn't expect NUL */
+    }
+
+#if defined(ALT_0) && defined(ALT_9)    /* PDCurses, maybe others */    
+    if ((ch >= ALT_0) && (ch <= ALT_9))
+    {
+        tmpch = (ch - ALT_0) + '0';
+        ch = M(tmpch);
+    }
+#endif
+
+#if defined(ALT_A) && defined(ALT_Z)    /* PDCurses, maybe others */    
+    if ((ch >= ALT_A) && (ch <= ALT_Z))
+    {
+        tmpch = (ch - ALT_A) + 'a';
+        ch = M(tmpch);
+    }
+#endif
+
+#ifdef KEY_RESIZE
+    /* Handle resize events via get_nh_event, not this code */
+    if (ch == KEY_RESIZE)
+    {
+        ch = DOESCAPE; /* NetHack doesn't know what to do with KEY_RESIZE */
+    }
+#endif
+
+    if (counting && !isdigit(ch)) /* Dismiss count window if necissary */
+    {
+        curses_count_window(NULL);
+        curses_refresh_nethack_windows();
+    }
+
+    return ch;
+}
+
+/* Turn on or off the specified color and / or attribute */
+
+void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff)
+{
+#ifdef TEXTCOLOR
+    int curses_color;
+
+    /* Map color disabled */
+    if ((!iflags.wc_color) && (win == mapwin))
+    {
+        return;
+    }
+    
+    /* GUI color disabled */
+    if ((!iflags.wc2_guicolor) && (win != mapwin))
+    {
+        return;
+    }
+    
+    if (color == 0) /* make black fg visible */
+    {
+#ifdef USE_DARKGRAY
+        if (can_change_color() && (COLORS > 16))
+        {
+            color = CURSES_DARK_GRAY - 1;
+        }
+        else    /* Use bold for a bright black */
+        {
+            wattron(win, A_BOLD);
+        }
+#else        
+        color = CLR_BLUE;
+#endif  /* USE_DARKGRAY */
+    }
+    curses_color = color + 1;
+    if (COLORS < 16)
+    {
+        if (curses_color > 8 && curses_color < 17)
+            curses_color -= 8;
+        else if (curses_color > (17+16))
+            curses_color -= 16;
+    }
+    if (onoff == ON)    /* Turn on color/attributes */
+    {
+        if (color != NONE)
+        {
+            if ((((color > 7) && (color < 17)) ||
+		 (color > 17+17)) && (COLORS < 16))
+            {
+                wattron(win, A_BOLD);
+            }
+            wattron(win, COLOR_PAIR(curses_color));
+        }
+        
+        if (attr != NONE)
+        {
+            wattron(win, attr);
+        }
+    }
+    else                /* Turn off color/attributes */
+    {
+        if (color != NONE)
+        {
+            if ((color > 7) && (COLORS < 16))
+            {
+                wattroff(win, A_BOLD);
+            }
+#ifdef USE_DARKGRAY
+            if ((color == 0) && (!can_change_color() ||
+             (COLORS <= 16)))
+            {
+                wattroff(win, A_BOLD);
+            }
+#else
+            if (iflags.use_inverse)
+            {
+                wattroff(win, A_REVERSE);
+            }
+#endif  /* DARKGRAY */
+            wattroff(win, COLOR_PAIR(curses_color));
+        }
+        
+        if (attr != NONE)
+        {
+            wattroff(win, attr);
+        }
+    }
+#endif  /* TEXTCOLOR */
+}
+
+
+/* clean up and quit - taken from tty port */
+
+void curses_bail(const char *mesg)
+{
+    clearlocks();
+    curses_exit_nhwindows(mesg);
+    terminate(EXIT_SUCCESS);
+}
+
+
+/* Return a winid for a new window of the given type */
+
+winid curses_get_wid(int type)
+{
+	winid ret;
+    static winid menu_wid = 20; /* Always even */
+    static winid text_wid = 21; /* Always odd */
+
+	switch (type)
+	{
+		case NHW_MESSAGE:
+		{
+			return MESSAGE_WIN;
+			break;
+		}
+		case NHW_MAP:
+		{
+			return MAP_WIN;
+			break;
+		}
+		case NHW_STATUS:
+		{
+			return STATUS_WIN;
+			break;
+		}
+		case NHW_MENU:
+		{
+			ret = menu_wid;
+			break;
+		}
+		case NHW_TEXT:
+		{
+			ret = text_wid;
+			break;
+		}
+		default:
+		{
+			panic("curses_get_wid: unsupported window type");
+			ret = -1;   /* Not reached */
+		}
+	}
+
+	while (curses_window_exists(ret))
+	{
+	    ret += 2;
+	    if ((ret + 2) > 10000)    /* Avoid "wid2k" problem */
+	    {
+	        ret -= 9900;
+	    }
+	}
+	
+	if (type == NHW_MENU)
+	{
+	    menu_wid += 2;
+	}
+	else
+	{
+	    text_wid += 2;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Allocate a copy of the given string.  If null, return a string of
+ * zero length.
+ *
+ * This is taken from copy_of() in tty/wintty.c.
+ */
+
+char *curses_copy_of(const char *s)
+{
+    if (!s) s = "";
+    return strcpy((char *) alloc((unsigned) (strlen(s) + 1)), s);
+}
+
+
+/* Determine the number of lines needed for a string for a dialog window
+of the given width */
+
+int curses_num_lines(const char *str, int width)
+{
+    int last_space, count;
+    int curline = 1;
+    char substr[BUFSZ];
+    char tmpstr[BUFSZ];
+    
+    strcpy(substr, str);
+    
+    while (strlen(substr) > width)
+    {
+        last_space = 0;
+        
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            last_space = count;
+
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+        curline++;
+    }
+    
+    return curline;
+}
+
+
+/* Break string into smaller lines to fit into a dialog window of the
+given width */
+
+char *curses_break_str(const char *str, int width, int line_num)
+{
+    int last_space, count;
+    char *retstr;
+    int curline = 0;
+    int strsize = strlen(str);
+    char substr[strsize];
+    char curstr[strsize];
+    char tmpstr[strsize];
+    
+    strcpy(substr, str);
+    
+    while (curline < line_num)
+    {
+        if (strlen(substr) == 0 )
+        {
+            break;
+        }
+        curline++;
+        last_space = 0;       
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            {
+                last_space = count;
+            }
+            else if (substr[count] == '\0')           
+            {
+                last_space = count;
+                break;
+            }
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = 0; count < last_space; count++)
+        {
+            curstr[count] = substr[count];
+        }
+        curstr[count] = '\0';
+        if (substr[count] == '\0')
+        {
+            break;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+    }
+    
+    if (curline < line_num)
+    {
+        return NULL;
+    }
+    
+    retstr = curses_copy_of(curstr);
+    
+    return retstr;
+}
+
+
+/* Return the remaining portion of a string after hacking-off line_num lines */
+
+char *curses_str_remainder(const char *str, int width, int line_num)
+{
+    int last_space, count;
+    char *retstr;
+    int curline = 0;
+    int strsize = strlen(str);
+    char substr[strsize];
+    char curstr[strsize];
+    char tmpstr[strsize];
+    
+    strcpy(substr, str);
+    
+    while (curline < line_num)
+    {
+        if (strlen(substr) == 0 )
+        {
+            break;
+        }
+        curline++;
+        last_space = 0;       
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            {
+                last_space = count;
+            }
+            else if (substr[count] == '\0')           
+            {
+                last_space = count;
+                break;
+            }
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = 0; count < last_space; count++)
+        {
+            curstr[count] = substr[count];
+        }
+        curstr[count] = '\0';
+        if (substr[count] == '\0')
+        {
+            break;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+    }
+    
+    if (curline < line_num)
+    {
+        return NULL;
+    }
+    
+    retstr = curses_copy_of(substr);
+    
+    return retstr;
+}
+
+
+/* Determine if the given NetHack winid is a menu window */
+
+boolean curses_is_menu(winid wid)
+{
+    if ((wid > 19) && !(wid % 2))   /* Even number */
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Determine if the given NetHack winid is a text window */
+
+boolean curses_is_text(winid wid)
+{
+    if ((wid > 19) && (wid % 2))   /* Odd number */
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Replace certain characters with portable drawing characters if
+cursesgraphics option is enabled */
+
+int curses_convert_glyph(int ch, int glyph)
+{
+    int symbol;
+    
+#ifdef REINCARNATION
+    if (Is_rogue_level(&u.uz))
+    {
+        return ch;
+    }
+#endif
+    
+    /* Save some processing time by returning if the glyph represents
+    an object that we don't have custom characters for */
+    if (!glyph_is_cmap(glyph))
+    {
+        return ch;
+    }
+    
+    symbol = glyph_to_cmap(glyph);
+    
+    /* If user selected a custom character for this object, don't
+    override this. */
+    if (((glyph_is_cmap(glyph)) && (ch != showsyms[symbol])))
+    {
+        return ch;
+    }
+
+    switch (symbol)
+    {
+        case S_vwall:
+            return ACS_VLINE;
+        case S_hwall:
+            return ACS_HLINE;
+        case S_tlcorn:
+            return ACS_ULCORNER;
+        case S_trcorn:
+            return ACS_URCORNER;
+        case S_blcorn:
+            return ACS_LLCORNER;
+        case S_brcorn:
+            return ACS_LRCORNER;
+        case S_crwall:
+            return ACS_PLUS;
+        case S_tuwall:
+            return ACS_BTEE;
+        case S_tdwall:
+            return ACS_TTEE;
+        case S_tlwall:
+            return ACS_RTEE;
+        case S_trwall:
+            return ACS_LTEE;
+        case S_tree:
+            return ACS_PLMINUS;
+        case S_corr:
+            return ACS_CKBOARD;
+        case S_litcorr:
+            return ACS_CKBOARD;
+    }
+
+	return ch;
+}
+
+
+/* Move text cursor to specified coordinates in the given NetHack window */
+
+void curses_move_cursor(winid wid, int x, int y)
+{
+    int sx, sy, ex, ey;
+    int xadj = 0;
+    int yadj = 0;
+
+#ifndef PDCURSES
+    WINDOW *win = curses_get_nhwin(MAP_WIN);
+#endif
+
+    if (wid != MAP_WIN)
+    {
+        return;
+    }
+
+#ifdef PDCURSES
+    /* PDCurses seems to not handle wmove correctly, so we use move and
+    physical screen coordinates instead */
+    curses_get_window_xy(wid, &xadj, &yadj);
+#endif    
+    curs_x = x + xadj;
+    curs_y = y + yadj;
+    curses_map_borders(&sx, &sy, &ex, &ey, x, y);
+    
+    if (curses_window_has_border(wid))
+    {
+        curs_x++;
+        curs_y++;
+    }
+        
+    if ((x >= sx) && (x <= ex) &&
+     (y >= sy) && (y <= ey))
+    {
+        curs_x -= sx;
+        curs_y -= sy;
+#ifdef PDCURSES
+        move(curs_y, curs_x);
+#else
+        wmove(win, curs_y, curs_x);
+#endif
+    }
+}
+
+
+/* Perform actions that should be done every turn before nhgetch() */
+
+void curses_prehousekeeping()
+{
+#ifndef PDCURSES
+    WINDOW *win = curses_get_nhwin(MAP_WIN);
+#endif  /* PDCURSES */
+
+    if ((curs_x > -1) && (curs_y > -1))
+    {
+        curs_set(1);
+#ifdef PDCURSES
+        /* PDCurses seems to not handle wmove correctly, so we use move
+        and physical screen coordinates instead */
+        move(curs_y, curs_x);
+#else
+        wmove(win, curs_y, curs_x);
+#endif  /* PDCURSES */
+        curses_refresh_nhwin(MAP_WIN);
+    }
+}
+
+
+/* Perform actions that should be done every turn after nhgetch() */
+
+void curses_posthousekeeping()
+{
+    curs_set(0);
+    curses_decrement_highlight();
+    curses_clear_unhighlight_message_window();
+}
+
+
+void curses_view_file(const char *filename, boolean must_exist)
+{
+    winid wid;
+    anything *identifier;
+    char buf[BUFSZ];
+    menu_item *selected = NULL;
+    dlb *fp = dlb_fopen(filename, "r");
+    
+    if ((fp == NULL) && (must_exist))
+    {
+        pline("Cannot open %s for reading!", filename);
+    }
+
+    if (fp == NULL)
+    {
+        return;
+    }
+    
+    wid = curses_get_wid(NHW_MENU);
+    curses_create_nhmenu(wid);
+    identifier = malloc(sizeof(anything));
+    identifier->a_void = NULL;
+    
+    while (dlb_fgets(buf, BUFSZ, fp) != NULL)
+    {
+        curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL, buf,
+         FALSE);
+    }
+    
+    dlb_fclose(fp);
+    curses_end_menu(wid, "");
+    curses_select_menu(wid, PICK_NONE, &selected);
+}
+
+
+void curses_rtrim(char *str)
+{
+    char *s;
+
+    for(s = str; *s != '\0'; ++s);
+    for(--s;isspace(*s) && s > str; --s);
+    if(s == str) *s = '\0';
+    else *(++s) = '\0';
+}
+
+
+/* Read numbers until non-digit is encountered, and return number
+in int form. */
+
+int curses_get_count(int first_digit)
+{
+    long current_count = first_digit;
+    int current_char;
+    
+    current_char = curses_read_char();
+    
+    while (isdigit(current_char))
+    {
+        current_count = (current_count * 10) + (current_char - '0');
+        if (current_count > LARGEST_INT)
+        {
+            current_count = LARGEST_INT;
+        }
+        
+        pline("Count: %ld", current_count);
+        current_char = curses_read_char();
+    }
+    
+    ungetch(current_char);
+    
+    if (current_char == DOESCAPE)    /* Cancelled with escape */
+    {
+        current_count = -1;
+    }
+    
+    return current_count;
+}
+
+
+/* Convert the given NetHack text attributes into the format curses
+understands, and return that format mask. */
+
+int curses_convert_attr(int attr)
+{
+    int curses_attr;
+    
+    switch (attr)
+    {
+        case ATR_NONE:
+        {
+            curses_attr = A_NORMAL;
+            break;
+        }
+        case ATR_ULINE:
+        {
+            curses_attr = A_UNDERLINE;
+            break;
+        }
+        case ATR_BOLD:
+        {
+            curses_attr = A_BOLD;
+            break;
+        }
+        case ATR_BLINK:
+        {
+            curses_attr = A_BLINK;
+            break;
+        }
+        case ATR_INVERSE:
+        {
+            curses_attr = A_REVERSE;
+            break;
+        }
+        default:
+        {
+            curses_attr = A_NORMAL;
+        }
+    }
+        
+    return curses_attr;
+}
+
+
+/* Map letter attributes from a string to bitmask.  Return mask on
+success, or 0 if not found */
+
+int curses_read_attrs(char *attrs)
+{
+    int retattr = 0;
+
+    if (strchr(attrs, 'b') || strchr(attrs, 'B'))
+    {
+	    retattr = retattr|A_BOLD;
+    }
+    if (strchr(attrs, 'i') || strchr(attrs, 'I'))
+    {
+	    retattr = retattr|A_REVERSE;
+    }
+    if (strchr(attrs, 'u') || strchr(attrs, 'U'))
+    {
+	    retattr = retattr|A_UNDERLINE;
+    }
+    if (strchr(attrs, 'k') || strchr(attrs, 'K'))
+    {
+	    retattr = retattr|A_BLINK;
+    }
+#ifdef A_ITALIC
+    if (strchr(attrs, 't') || strchr(attrs, 'T'))
+    {
+	    retattr = retattr|A_ITALIC;
+    }
+#endif
+#ifdef A_RIGHTLINE
+    if (strchr(attrs, 'r') || strchr(attrs, 'R'))
+    {
+	    retattr = retattr|A_RIGHTLINE;
+    }
+
+#endif
+#ifdef A_LEFTLINE
+    if (strchr(attrs, 'l') || strchr(attrs, 'L'))
+    {
+	    retattr = retattr|A_LEFTLINE;
+    }
+#endif
+
+    return retattr;
+}
+
+
+/* Convert special keys into values that NetHack can understand.
+Currently this is limited to arrow keys, but this may be expanded. */
+
+int curses_convert_keys(int key)
+{
+    int ret = key;
+    
+    if (ret == '\033')
+    {
+        ret = parse_escape_sequence();
+    }
+
+    /* Handle arrow keys */
+    switch (key)
+    {
+        case KEY_LEFT:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '4';
+            }
+            else
+            {
+                ret = 'h';
+            }
+            break;
+        }
+        case KEY_RIGHT:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '6';
+            }
+            else
+            {
+                ret = 'l';
+            }
+            break;
+        }
+        case KEY_UP:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '8';
+            }
+            else
+            {
+                ret = 'k';
+            }
+            break;
+        }
+        case KEY_DOWN:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '2';
+            }
+            else
+            {
+                ret = 'j';
+            }
+            break;
+        }
+#ifdef KEY_A1
+        case KEY_A1:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '7';
+            }
+            else
+            {
+                ret = 'y';
+            }
+            break;
+        }
+#endif  /* KEY_A1 */
+#ifdef KEY_A3
+        case KEY_A3:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '9';
+            }
+            else
+            {
+                ret = 'u';
+            }
+            break;
+        }
+#endif  /* KEY_A3 */
+#ifdef KEY_C1
+        case KEY_C1:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '1';
+            }
+            else
+            {
+                ret = 'b';
+            }
+            break;
+        }
+#endif  /* KEY_C1 */
+#ifdef KEY_C3
+        case KEY_C3:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '3';
+            }
+            else
+            {
+                ret = 'n';
+            }
+            break;
+        }
+#endif  /* KEY_C3 */
+#ifdef KEY_B2
+        case KEY_B2:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '5';
+            }
+            else
+            {
+                ret = 'g';
+            }
+            break;
+        }
+#endif  /* KEY_B2 */
+    }
+
+    return ret;
+}
+
+
+/* Process mouse events.  Mouse movement is processed until no further
+mouse movement events are available.  Returns 0 for a mouse click
+event, or the first non-mouse key event in the case of mouse
+movement. */
+
+int curses_get_mouse(int *mousex, int *mousey, int *mod)
+{
+    int key = '\033';
+#ifdef NCURSES_MOUSE_VERSION
+	MEVENT event;
+
+    if (getmouse(&event) == OK)
+    {   /* When the user clicks left mouse button */
+        if(event.bstate & BUTTON1_CLICKED)
+        {
+            /* See if coords are in map window & convert coords */
+            if (wmouse_trafo(mapwin, &event.y, &event.x, TRUE))
+            {
+                key = 0;    /* Flag mouse click */
+                *mousex = event.x;
+                *mousey = event.y;
+                
+                if (curses_window_has_border(MAP_WIN))
+                {
+                    (*mousex)--;
+                    (*mousey)--;
+                }
+                
+                *mod = CLICK_1;
+            }
+        }
+    }
+#endif  /* NCURSES_MOUSE_VERSION */
+
+    return key;
+}
+
+
+static int parse_escape_sequence(void)
+{
+#ifndef PDCURSES
+    int ret;
+
+    timeout(10);
+
+    ret = getch();
+
+    if (ret != ERR) /* Likely an escape sequence */
+    {
+        if (((ret >= 'a') && (ret <= 'z')) ||
+         ((ret >= '0') && (ret <= '9')))
+        {
+            ret |= 0x80; /* Meta key support for most terminals */
+        }
+        else if (ret == 'O') /* Numeric keypad */
+        {
+            ret = getch();
+            if ((ret != ERR) && (ret >= 112) && (ret <= 121))
+            {
+                ret = ret - 112 + '0';  /* Convert to number */
+            }
+            else
+            {
+                ret = '\033';    /* Escape */
+            }
+        }
+    }
+    else
+    {
+        ret = '\033';    /* Just an escape character */
+    }
+
+    timeout(-1);
+
+    return ret;
+#else
+    return '\033';
+#endif  /* !PDCURSES */
+}
+
+
+/* This is a kludge for the statuscolors patch which calls tty-specific
+functions, which causes a compiler error if TTY_GRAPHICS is not
+defined.  Adding stub functions to avoid this. */
+
+#if defined(STATUS_COLORS) && !defined(TTY_GRAPHICS)
+extern void term_start_color(int color) {}
+extern void term_start_attr(int attr) {}
+extern void term_end_color() {}
+extern void term_end_attr(int attr) {}
+#endif  /* STATUS_COLORS && !TTY_GRAPGICS */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursmisc.h nethack-3.4.3-nao-osx/win/curses/cursmisc.h
--- nethack-3.4.3/win/curses/cursmisc.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursmisc.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,48 @@
+#ifndef CURSMISC_H
+#define CURSMISC_H
+
+/* Global declarations */
+
+int curses_read_char(void);
+
+void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff);
+
+void curses_bail(const char *mesg);
+
+winid curses_get_wid(int type);
+
+char *curses_copy_of(const char *s);
+
+int curses_num_lines(const char *str, int width);
+
+char *curses_break_str(const char *str, int width, int line_num);
+
+char *curses_str_remainder(const char *str, int width, int line_num);
+
+boolean curses_is_menu(winid wid);
+
+boolean curses_is_text(winid wid);
+
+int curses_convert_glyph(int ch, int glyph);
+
+void curses_move_cursor(winid wid, int x, int y);
+
+void curses_prehousekeeping(void);
+
+void curses_posthousekeeping(void);
+
+void curses_view_file(const char *filename, boolean must_exist);
+
+void curses_rtrim(char *str);
+
+int curses_get_count(int first_digit);
+
+int curses_convert_attr(int attr);
+
+int curses_read_attrs(char *attrs);
+
+int curses_convert_keys(int key);
+
+int curses_get_mouse(int *mousex, int *mousey, int *mod);
+
+#endif  /* CURSMISC_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursstat.c nethack-3.4.3-nao-osx/win/curses/cursstat.c
--- nethack-3.4.3/win/curses/cursstat.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursstat.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,2727 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursstat.h"
+
+/* Status window functions for curses interface */
+
+/* Private declarations */
+
+typedef struct nhs
+{
+    long value;
+    char *txt;
+    aligntyp alignment;
+    boolean display;
+    int highlight_turns;
+    int highlight_color;
+    int stat_color;
+    int stat_attr;
+    int x;
+    int y;
+    char *label;
+    const char *id;
+} nhstat;
+
+#ifdef STATUS_COLORS
+extern const struct text_color_option *text_colors;
+extern const struct percent_color_option *hp_colors;
+extern const struct percent_color_option *pw_colors;
+
+extern struct color_option text_color_of(const char *text,
+ const struct text_color_option *color_options);
+
+struct color_option percentage_color_of(int value, int max,
+ const struct percent_color_option *color_options);
+
+static boolean stat_colored(const char *id);
+#endif
+
+static void init_stats(void);
+
+static void set_labels(int label_width);
+
+static void set_stat_color(nhstat *stat);
+
+static void color_stat(nhstat stat, int onoff);
+
+static nhstat prevname;
+static nhstat prevdepth;
+static nhstat prevstr;
+static nhstat prevint;
+static nhstat prevwis;
+static nhstat prevdex;
+static nhstat prevcon;
+static nhstat prevcha;
+static nhstat prevalign;  
+static nhstat prevau;
+static nhstat prevhp;
+static nhstat prevmhp;
+static nhstat prevlevel;
+static nhstat prevpow;
+static nhstat prevmpow;
+static nhstat prevac;
+static nhstat prevexp;
+static nhstat prevtime;
+#ifdef SCORE_ON_BOTL
+static nhstat prevscore;
+#endif
+static nhstat prevhunger;
+static nhstat prevconf;
+static nhstat prevblind;
+static nhstat prevstun;
+static nhstat prevhallu;
+static nhstat prevsick;
+static nhstat prevslime;
+static nhstat prevencumb;
+
+#define COMPACT_LABELS  1
+#define NORMAL_LABELS   2
+#define WIDE_LABELS     3
+
+extern const char *hu_stat[]; /* from eat.c */
+extern const char *enc_stat[]; /* from botl.c */
+
+/* Update the status win - this is called when NetHack would normally
+write to the status window, so we know somwthing has changed.  We
+override the write and update what needs to be updated ourselves. */
+
+void curses_update_stats(boolean redraw)
+{
+    char buf[BUFSZ];
+    int count, enc, orient, sx_start, hp, hpmax, labels, swidth,
+     sheight, sx_end, sy_end;
+    WINDOW *win = curses_get_nhwin(STATUS_WIN);
+    static int prev_labels = -1;
+    static boolean first = TRUE;
+    static boolean horiz;
+    int sx = 0;
+    int sy = 0;
+    boolean border = curses_window_has_border(STATUS_WIN);
+    
+    curses_get_window_size(STATUS_WIN, &sheight, &swidth);
+
+    if (border)
+    {
+        sx++;
+        sy++;
+        swidth--;
+        sheight--;
+    }
+    
+    sx_end = swidth - 1;
+    sy_end = sheight - 1;    
+    sx_start = sx;
+        
+    if (first)
+    {
+        init_stats();
+        first = FALSE;
+        redraw = TRUE;
+    }
+
+    if (redraw)
+    {
+        orient = curses_get_window_orientation(STATUS_WIN);
+
+        if ((orient == ALIGN_RIGHT) || (orient == ALIGN_LEFT))
+        {
+            horiz = FALSE;
+        }
+        else
+        {
+            horiz = TRUE;
+        }
+    }
+    
+    if (horiz)
+    {
+        if (term_cols >= 80)
+        {
+            labels = NORMAL_LABELS;
+        }
+        else
+        {
+            labels = COMPACT_LABELS;
+        }
+    }
+    else
+    {
+        labels = WIDE_LABELS;
+    }
+    
+    if (labels != prev_labels)
+    {
+        set_labels(labels);
+        prev_labels = labels;
+    }
+
+    curses_clear_nhwin(STATUS_WIN);
+    
+    /* Line 1 */
+    
+    /* Player name and title */
+    strcpy(buf, plname);
+    if ('a' <= buf[0] && buf[0] <= 'z') buf[0] += 'A'-'a';
+    strcat(buf, " the ");
+    if (u.mtimedone) {
+        char mname[BUFSZ];
+        int k = 0;
+        strcpy(mname, mons[u.umonnum].mname);
+        while(mname[k] != 0) {
+            if ((k == 0 || (k > 0 && mname[k-1] == ' '))
+             && 'a' <= mname[k] && mname[k] <= 'z')
+            {
+                mname[k] += 'A' - 'a';
+            }
+            k++;
+        }
+        strcat(buf, mname);
+    } else {
+        strcat(buf, rank_of(u.ulevel, pl_character[0], flags.female));
+    }
+    
+    if (strcmp(buf, prevname.txt) != 0) /* Title changed */
+    {
+        prevname.highlight_turns = 5;
+        prevname.highlight_color = HIGHLIGHT_COLOR;
+        free(prevname.txt);
+        prevname.txt = curses_copy_of(buf);
+        if ((labels == COMPACT_LABELS) && (u.ulevel > 1))
+        {
+            curses_puts(MESSAGE_WIN, A_NORMAL, "You are now known as");
+            curses_puts(MESSAGE_WIN, A_NORMAL, prevname.txt);
+        }
+    }
+    
+    if (prevname.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevname.label);
+        sx += strlen(prevname.label);
+    }
+    
+    if (labels != COMPACT_LABELS)
+    {
+        color_stat(prevname, ON);
+        mvwaddstr(win, sy, sx, prevname.txt);
+        color_stat(prevname, OFF);
+    }
+
+    if (horiz)
+    {
+        if (labels != COMPACT_LABELS)
+        {
+            sx += strlen(prevname.txt) + 1;
+        }
+        
+        
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+    
+    /* Add dungeon name and level if status window is vertical */
+    if (!horiz)
+    {
+        sprintf(buf, "%s", dungeons[u.uz.dnum].dname);
+        mvwaddstr(win, sy, sx, buf);
+        sy += 2;
+    }
+
+    /* Strength */
+    if (ACURR(A_STR) != prevstr.value)  /* Strength changed */
+    {
+        
+        if (ACURR(A_STR) > prevstr.value)
+        {
+            prevstr.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevstr.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevstr.value = ACURR(A_STR);
+        if (ACURR(A_STR) > 118)
+        {
+            sprintf(buf, "%d", ACURR(A_STR) - 100);
+        }
+        else if (ACURR(A_STR)==118)
+        {
+            sprintf(buf, "18/**");
+        }
+        else if(ACURR(A_STR) > 18)
+        {
+            sprintf(buf, "18/%02d", ACURR(A_STR) - 18);
+        }
+        else
+        {
+            sprintf(buf, "%d", ACURR(A_STR));
+        }
+        free(prevstr.txt);
+        prevstr.txt = curses_copy_of(buf);
+        prevstr.highlight_turns = 5;
+    }
+
+    if (prevstr.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevstr.label);
+        sx += strlen(prevstr.label);
+    }
+    
+    color_stat(prevstr, ON);
+    mvwaddstr(win, sy, sx, prevstr.txt);
+    color_stat(prevstr, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevstr.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Intelligence */
+    if (ACURR(A_INT) != prevint.value)  /* Intelligence changed */
+    {
+        
+        if (ACURR(A_INT) > prevint.value)
+        {
+            prevint.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevint.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevint.value = ACURR(A_INT);
+        sprintf(buf, "%d", ACURR(A_INT)); 
+        free(prevint.txt);
+        prevint.txt = curses_copy_of(buf);
+        prevint.highlight_turns = 5;
+    }
+
+    if (prevint.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevint.label);
+        sx += strlen(prevint.label);
+    }
+    
+    color_stat(prevint, ON);
+    mvwaddstr(win, sy, sx, prevint.txt);
+    color_stat(prevint, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevint.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Wisdom */
+    if (ACURR(A_WIS) != prevwis.value)  /* Wisdom changed */
+    {
+        
+        if (ACURR(A_WIS) > prevwis.value)
+        {
+            prevwis.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevwis.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevwis.value = ACURR(A_WIS);
+        sprintf(buf, "%d", ACURR(A_WIS)); 
+        free(prevwis.txt);
+        prevwis.txt = curses_copy_of(buf);
+        prevwis.highlight_turns = 5;
+    }
+
+    if (prevwis.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevwis.label);
+        sx += strlen(prevwis.label);
+    }
+    
+    color_stat(prevwis, ON);
+    mvwaddstr(win, sy, sx, prevwis.txt);
+    color_stat(prevwis, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevwis.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Dexterity */
+    if (ACURR(A_DEX) != prevdex.value)  /* Dexterity changed */
+    {
+        
+        if (ACURR(A_DEX) > prevdex.value)
+        {
+            prevdex.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevdex.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevdex.value = ACURR(A_DEX);
+        sprintf(buf, "%d", ACURR(A_DEX));
+        free(prevdex.txt);
+        prevdex.txt = curses_copy_of(buf);
+        prevdex.highlight_turns = 5;
+    }
+
+    if (prevdex.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevdex.label);
+        sx += strlen(prevdex.label);
+    }
+    
+    color_stat(prevdex, ON);
+    mvwaddstr(win, sy, sx, prevdex.txt);
+    color_stat(prevdex, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevdex.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Constitution */
+    if (ACURR(A_CON) != prevcon.value)  /* Constitution changed */
+    {
+        
+        if (ACURR(A_CON) > prevcon.value)
+        {
+            prevcon.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevcon.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevcon.value = ACURR(A_CON);
+        sprintf(buf, "%d", ACURR(A_CON));
+        free(prevcon.txt);
+        prevcon.txt = curses_copy_of(buf);
+        prevcon.highlight_turns = 5;
+    }
+
+    if (prevcon.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevcon.label);
+        sx += strlen(prevcon.label);
+    }
+    
+    color_stat(prevcon, ON);
+    mvwaddstr(win, sy, sx, prevcon.txt);
+    color_stat(prevcon, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevcon.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Charisma */
+    if (ACURR(A_CHA) != prevcha.value)  /* Charisma changed */
+    {
+        if (ACURR(A_CHA) > prevcha.value)
+        {
+            prevcha.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevcha.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevcha.value = ACURR(A_CHA);
+        sprintf(buf, "%d", ACURR(A_CHA));
+        free(prevcha.txt);
+        prevcha.txt = curses_copy_of(buf);
+        prevcha.highlight_turns = 5;
+    }
+
+    if (prevcha.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevcha.label);
+        sx += strlen(prevcha.label);
+    }
+    
+    color_stat(prevcha, ON);
+    mvwaddstr(win, sy, sx, prevcha.txt);
+    color_stat(prevcha, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevcha.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy ++;
+    }
+    
+    /* Alignment */
+    if (prevalign.alignment != u.ualign.type)   /* Alignment changed */
+    {
+        prevalign.highlight_color = HIGHLIGHT_COLOR;
+        prevalign.highlight_turns = 10; /* This is a major change! */
+        prevalign.alignment = u.ualign.type;
+        free(prevalign.txt);
+        switch (u.ualign.type)
+        {
+            case A_LAWFUL:
+            {
+                prevalign.txt = curses_copy_of("Lawful");
+                break;
+            }
+            case A_NEUTRAL:
+            {
+                prevalign.txt = curses_copy_of("Neutral");
+                break;
+            }
+            case A_CHAOTIC:
+            {
+                prevalign.txt = curses_copy_of("Chaotic");
+                break;
+            }
+        }
+    }
+
+    if (prevalign.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevalign.label);
+        sx += strlen(prevalign.label);
+    }
+    
+    color_stat(prevalign, ON);
+    mvwaddstr(win, sy, sx, prevalign.txt);
+    color_stat(prevalign, OFF);
+
+    /* Line 2 */
+    
+    sx = sx_start;
+    sy++;
+    
+    /* Dungeon Level */
+    if (depth(&u.uz) != prevdepth.value)    /* Dungeon level changed */
+    {
+        prevdepth.highlight_color = HIGHLIGHT_COLOR;
+        prevdepth.highlight_turns = 5;
+        prevdepth.value = depth(&u.uz);
+        free(prevdepth.txt);
+        if (In_endgame(&u.uz))
+        {
+            strcpy(buf, (Is_astralevel(&u.uz) ? "Astral Plane":"End Game"));
+        }
+        else
+        {
+            sprintf(buf, "%d", depth(&u.uz));
+        }
+        prevdepth.txt = curses_copy_of(buf);
+    }
+    
+    if (prevdepth.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevdepth.label);
+        sx += strlen(prevdepth.label);
+    }
+    
+    color_stat(prevdepth, ON);
+    mvwaddstr(win, sy, sx, prevdepth.txt);
+    color_stat(prevdepth, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevdepth.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+    
+    /* Gold */
+#ifndef GOLDOBJ
+    if (prevau.value != u.ugold)    /* Gold changed */
+    {
+        if (u.ugold > prevau.value)
+        {
+#else
+    if (prevau.value != money_cnt(invent))  /* Gold changed */
+    {
+        if (money_cnt(invent) > prevau.value)
+        {
+#endif
+            prevau.highlight_color = HI_GOLD;
+        }
+        else
+        {
+            prevau.highlight_color = STAT_DOWN_COLOR;
+        }
+#ifndef GOLDOBJ
+        prevau.value = u.ugold;
+        sprintf(buf,"%ld", u.ugold);
+#else
+        prevau.value = money_cnt(invent);
+        sprintf(buf,"%ld", money_cnt(invent));
+#endif
+        free(prevau.txt);
+        prevau.txt = curses_copy_of(buf);
+        prevau.highlight_turns = 5;
+    }
+    
+    if (prevau.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevau.label);
+        sx += strlen(prevau.label);
+    }
+    
+    color_stat(prevau, ON);
+    mvwaddstr(win, sy, sx, prevau.txt);
+    color_stat(prevau, OFF);
+
+    if (horiz)
+    {
+        sx += strlen(prevau.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+
+    /* Hit Points */
+	    
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+	    hp = u.mh;
+	    hpmax = u.mhmax;
+	}
+	else    /* Not polymorphed */
+	{
+	    hp = u.uhp;
+	    hpmax = u.uhpmax;
+	}
+    
+	if (hp != prevhp.value)
+	{
+	    if (hp > prevhp.value)
+	    {
+	        prevhp.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevhp.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevhp.value = hp;
+        if (prevhp.value < 0)
+        {
+            prevhp.value = 0;
+        }
+        sprintf(buf, "%ld", prevhp.value);
+        free(prevhp.txt);
+        prevhp.txt = curses_copy_of(buf);
+        prevhp.highlight_turns = 3;
+	}
+
+    if (prevhp.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhp.label);
+        sx += strlen(prevhp.label);
+    }
+
+    color_stat(prevhp, ON);
+    mvwaddstr(win, sy, sx, prevhp.txt);
+    color_stat(prevhp, OFF);
+
+    sx += strlen(prevhp.txt);
+
+    /* Max Hit Points */
+
+	if (hpmax != prevmhp.value)  /* Not polymorphed */
+	{
+	    if (hpmax > prevmhp.value)
+	    {
+	        prevmhp.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevmhp.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevmhp.value = hpmax;
+        sprintf(buf, "%d", hpmax);
+        free(prevmhp.txt);
+        prevmhp.txt = curses_copy_of(buf);
+        prevmhp.highlight_turns = 3;
+	}
+
+    if (prevmhp.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevmhp.label);
+        sx += strlen(prevmhp.label);
+    }
+
+    color_stat(prevmhp, ON);
+    mvwaddstr(win, sy, sx, prevmhp.txt);
+    color_stat(prevmhp, OFF);
+
+    if (horiz)
+    {
+        color_stat(prevmhp, ON);
+        sx += strlen(prevmhp.txt) + 1;
+        color_stat(prevmhp, OFF);
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Power */
+    if (u.uen != prevpow.value)
+	{
+	    if (u.uen > prevpow.value)
+	    {
+	        prevpow.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevpow.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevpow.value = u.uen;
+        sprintf(buf, "%d", u.uen);
+        free(prevpow.txt);
+        prevpow.txt = curses_copy_of(buf);
+        prevpow.highlight_turns = 3;
+	}
+
+    if (prevpow.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevpow.label);
+        sx += strlen(prevpow.label);
+    }
+
+    color_stat(prevpow, ON);
+    mvwaddstr(win, sy, sx, prevpow.txt);
+    color_stat(prevpow, OFF);
+    
+    sx += strlen(prevpow.txt);
+
+    /* Max Power */
+    if (u.uenmax != prevmpow.value)
+	{
+	    if (u.uenmax > prevmpow.value)
+	    {
+	        prevmpow.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevmpow.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevmpow.value = u.uenmax;
+        sprintf(buf, "%d", u.uenmax);
+        free(prevmpow.txt);
+        prevmpow.txt = curses_copy_of(buf);
+        prevmpow.highlight_turns = 3;
+	}
+
+    if (prevmpow.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevmpow.label);
+        sx += strlen(prevmpow.label);
+    }
+
+    color_stat(prevmpow, ON);
+    mvwaddstr(win, sy, sx, prevmpow.txt);
+    color_stat(prevmpow, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevmpow.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+
+    /* Armor Class */
+    if (u.uac != prevac.value)
+	{
+	    if (u.uac > prevac.value)   /* Lower is better for AC */
+	    {
+	        prevac.highlight_color = STAT_DOWN_COLOR;
+	    }
+	    else
+	    {
+            prevac.highlight_color = STAT_UP_COLOR;
+	    }
+        prevac.value = u.uac;
+        sprintf(buf, "%d", u.uac);
+        free(prevac.txt);
+        prevac.txt = curses_copy_of(buf);
+        prevac.highlight_turns = 5;
+	}
+
+    if (prevac.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevac.label);
+        sx += strlen(prevac.label);
+    }
+
+    color_stat(prevac, ON);
+    mvwaddstr(win, sy, sx, prevac.txt);
+    color_stat(prevac, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevac.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Experience */
+#ifdef EXP_ON_BOTL
+    if (prevexp.display != flags.showexp)   /* Setting has changed */
+    {
+        prevexp.display = flags.showexp;
+        free(prevlevel.label);
+        if (prevexp.display)
+        {
+            prevlevel.label = curses_copy_of("/");
+        }
+        else
+        {
+            if (horiz)
+            {
+                if (labels == COMPACT_LABELS)
+                {
+                    prevlevel.label = curses_copy_of("Lv:");
+                }
+                else
+                {
+                    prevlevel.label = curses_copy_of("Lvl:");
+                }
+            }
+            else
+            {
+                prevlevel.label = curses_copy_of("Level:         ");
+            }
+        }
+    }
+
+    if (prevexp.display && !u.mtimedone)
+    {
+        if (u.uexp != prevexp.value)
+	    {
+	        if (u.uexp > prevexp.value)
+	        {
+	            prevexp.highlight_color = STAT_UP_COLOR;
+	        }
+	        else
+	        {
+                prevexp.highlight_color = STAT_DOWN_COLOR;
+	        }
+            sprintf(buf, "%ld", u.uexp);
+            free(prevexp.txt);
+            prevexp.txt = curses_copy_of(buf);
+            prevexp.highlight_turns = 3;
+	    }
+
+        if (prevexp.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevexp.label);
+            sx += strlen(prevexp.label);
+        }
+
+        color_stat(prevexp, ON);
+        mvwaddstr(win, sy, sx, prevexp.txt);
+        color_stat(prevexp, OFF);
+
+        sx += strlen(prevexp.txt);
+    }
+    
+    prevexp.value = u.uexp; /* Track it even when it's not displayed */
+#endif  /* EXP_ON_BOTL */
+
+    /* Level */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HD */
+    {
+        if ((strncmp(prevlevel.label, "HP:", 3) != 0) ||
+         (strncmp(prevlevel.label, "Hit Points:", 11) != 0))
+        {
+            free(prevlevel.label);
+            if (horiz)
+            {
+            prevlevel.label = curses_copy_of("HD:");
+        }
+            else
+            {
+                prevlevel.label = curses_copy_of("Hit Dice:      ");
+            }
+        }
+        if (mons[u.umonnum].mlevel != prevlevel.value)
+        {
+            if (mons[u.umonnum].mlevel > prevlevel.value)
+            {
+                prevlevel.highlight_color = STAT_UP_COLOR;
+            }
+            else
+            {
+                prevlevel.highlight_color = STAT_DOWN_COLOR;
+            }
+            prevlevel.highlight_turns = 5;
+        }
+        prevlevel.value = mons[u.umonnum].mlevel;
+        sprintf(buf, "%d", mons[u.umonnum].mlevel);
+        free(prevlevel.txt);
+        prevlevel.txt = curses_copy_of(buf);
+    }
+    else    /* Not polymorphed */
+    {
+        if ((strncmp(prevlevel.label, "HD:", 3) != 0) ||
+         (strncmp(prevlevel.label, "Hit Dice:", 9) != 0))
+        {
+            free(prevlevel.label);
+            if (prevexp.display)
+            {
+                prevlevel.label = curses_copy_of("/");
+            }
+            else
+            {
+                if (horiz)
+                {
+                    if (labels == COMPACT_LABELS)
+                    {
+                        prevlevel.label = curses_copy_of("Lv:");
+                    }
+                    else
+                    {
+                        prevlevel.label = curses_copy_of("Lvl:");
+                    }
+                }
+                else
+                {
+                    prevlevel.label = curses_copy_of("Level:         ");
+                }
+            }
+        }
+        if (u.ulevel > prevlevel.value)
+        {
+            prevlevel.highlight_color = STAT_UP_COLOR;
+            prevlevel.highlight_turns = 5;
+        }
+        else if (u.ulevel < prevlevel.value)
+        {
+            prevlevel.highlight_color = STAT_DOWN_COLOR;
+            prevlevel.highlight_turns = 5;
+        }
+        prevlevel.value = u.ulevel;
+        sprintf(buf, "%d", u.ulevel);
+        free(prevlevel.txt);
+        prevlevel.txt = curses_copy_of(buf);
+    }
+
+    if (prevlevel.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevlevel.label);
+        sx += strlen(prevlevel.label);
+    }
+
+    color_stat(prevlevel, ON);
+    mvwaddstr(win, sy, sx, prevlevel.txt);
+    color_stat(prevlevel, OFF);
+
+    if (horiz)
+    {
+        sx += strlen(prevlevel.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Time */
+    if (prevtime.display != flags.time)   /* Setting has changed */
+    {
+        prevtime.display = flags.time;
+    }
+    if (prevtime.display)
+    {
+        if (moves != prevtime.value)
+	    {
+            sprintf(buf, "%ld", moves);
+            free(prevtime.txt);
+            prevtime.txt = curses_copy_of(buf);
+	    }
+
+        if (prevtime.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevtime.label);
+            sx += strlen(prevtime.label);
+        }
+
+        color_stat(prevtime, ON);
+        mvwaddstr(win, sy, sx, prevtime.txt);
+        color_stat(prevtime, OFF);
+
+        if (horiz)
+        {
+            sx += strlen(prevtime.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+    
+    /* Score */
+#ifdef SCORE_ON_BOTL
+    if (prevscore.display != flags.showscore)   /* Setting has changed */
+    {
+        prevscore.display = flags.showscore;
+    }
+    if (prevscore.display)
+    {
+        if (botl_score() != prevscore.value)
+	    {
+	        if (botl_score() > prevscore.value)
+	        {
+	            prevscore.highlight_color = STAT_UP_COLOR;
+	        }
+	        else    /* Not sure this is possible */
+	        {
+                prevscore.highlight_color = STAT_DOWN_COLOR;
+	        }
+            sprintf(buf, "%ld", botl_score());
+            free(prevscore.txt);
+            prevscore.txt = curses_copy_of(buf);
+            prevscore.highlight_turns = 3;
+	    }
+
+        if (prevscore.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevscore.label);
+            sx += strlen(prevscore.label);
+        }
+
+        color_stat(prevscore, ON);
+        mvwaddstr(win, sy, sx, prevscore.txt);
+        color_stat(prevscore, OFF);
+
+        if (horiz)
+        {
+            sx += strlen(prevscore.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+    
+    prevscore.value = botl_score(); /* Track it even when it's not displayed */
+#endif  /* SCORE_ON_BOTL */
+
+    /* Hunger */
+    if (u.uhs != prevhunger.value)
+	{
+	    if ((u.uhs > prevhunger.value) || (u.uhs > 3))
+	    {
+	        prevhunger.highlight_color = STAT_DOWN_COLOR;
+	    }
+	    else
+	    {
+            prevhunger.highlight_color = STAT_UP_COLOR;
+	    }
+        prevhunger.value = u.uhs;
+        for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+        {
+            if ((hu_stat[u.uhs][count]) == ' ')
+            {
+                break;
+            }
+            buf[count] = hu_stat[u.uhs][count];
+        }
+
+        buf[count] = '\0';
+        free(prevhunger.txt);
+        prevhunger.txt = curses_copy_of(buf);
+        prevhunger.highlight_turns = 5;
+	}
+
+    if (prevhunger.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhunger.label);
+        sx += strlen(prevhunger.label);
+    }
+
+    color_stat(prevhunger, ON);
+    mvwaddstr(win, sy, sx, prevhunger.txt);
+    color_stat(prevhunger, OFF);
+    
+    if (strlen(prevhunger.txt) > 0)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevhunger.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Confusion */
+    if (Confusion != prevconf.value)
+	{
+	    prevconf.highlight_color = STAT_DOWN_COLOR;
+        if (prevconf.txt != NULL)
+        {
+            free(prevconf.txt);
+        }
+        if (Confusion)
+        {
+            prevconf.txt = curses_copy_of("Conf");
+        }
+        else
+        {
+            prevconf.txt = NULL;
+        }
+        if (prevconf.value == 0)
+        {
+            prevconf.highlight_turns = 5;
+	    }
+        prevconf.value = Confusion;
+	}
+
+    if (prevconf.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevconf.label);
+        sx += strlen(prevconf.label);
+    }
+
+    if (prevconf.txt != NULL)
+    {
+        color_stat(prevconf, ON);
+        mvwaddstr(win, sy, sx, prevconf.txt);
+        color_stat(prevconf, OFF);
+    }
+
+    if (prevconf.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevconf.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Blindness */
+    if (Blind != prevblind.value)
+	{
+	    prevblind.highlight_color = STAT_DOWN_COLOR;
+        if (prevblind.txt != NULL)
+        {
+            free(prevblind.txt);
+        }
+        if (Blind)
+        {
+            prevblind.txt = curses_copy_of("Blind");
+        }
+        else
+        {
+            prevblind.txt = NULL;
+        }
+        if (prevblind.value == 0)
+        {
+            prevblind.highlight_turns = 5;
+	    }
+        prevblind.value = Blind;
+	}
+
+    if (prevblind.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevblind.label);
+        sx += strlen(prevblind.label);
+    }
+
+    if (prevblind.txt != NULL)
+    {
+        color_stat(prevblind, ON);
+        mvwaddstr(win, sy, sx, prevblind.txt);
+        color_stat(prevblind, OFF);
+    }
+
+    if (prevblind.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevblind.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Stun */
+    if (Stunned != prevstun.value)
+	{
+	    prevstun.highlight_color = STAT_DOWN_COLOR;
+        if (prevstun.txt != NULL)
+        {
+            free(prevstun.txt);
+        }
+        if (Stunned)
+        {
+            prevstun.txt = curses_copy_of("Stun");
+        }
+        else
+        {
+            prevstun.txt = NULL;
+        }
+        if (prevstun.value == 0)
+        {
+            prevstun.highlight_turns = 5;
+	    }
+        prevstun.value = Stunned;
+	}
+
+    if (prevstun.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevstun.label);
+        sx += strlen(prevstun.label);
+    }
+
+    if (prevstun.txt != NULL)
+    {
+        color_stat(prevstun, ON);
+        mvwaddstr(win, sy, sx, prevstun.txt);
+        color_stat(prevstun, OFF);
+    }
+
+    if (prevstun.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevstun.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Hallucination */
+    if (Hallucination != prevhallu.value)
+	{
+	    prevhallu.highlight_color = STAT_DOWN_COLOR;
+        if (prevhallu.txt != NULL)
+        {
+            free(prevhallu.txt);
+        }
+        if (Hallucination)
+        {
+            prevhallu.txt = curses_copy_of("Hallu");
+        }
+        else
+        {
+            prevhallu.txt = NULL;
+        }
+        if (prevhallu.value == 0)
+        {
+            prevhallu.highlight_turns = 5;
+	    }
+        prevhallu.value = Hallucination;
+	}
+
+    if (prevhallu.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhallu.label);
+        sx += strlen(prevhallu.label);
+    }
+
+    if (prevhallu.txt != NULL)
+    {
+        color_stat(prevhallu, ON);
+        mvwaddstr(win, sy, sx, prevhallu.txt);
+        color_stat(prevhallu, OFF);
+    }
+
+    if (prevhallu.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevhallu.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Sick */
+    if (Sick != prevsick.value)
+	{
+	    prevsick.highlight_color = STAT_DOWN_COLOR;
+        if (prevsick.txt != NULL)
+        {
+            free(prevsick.txt);
+        }
+        if (Sick)
+        {
+            if (u.usick_type & SICK_VOMITABLE)
+            {
+                prevsick.txt = curses_copy_of("FoodPois");
+            }
+            else      
+            {
+                prevsick.txt = curses_copy_of("Ill");
+            }
+        }
+        else
+        {
+            prevsick.txt = NULL;
+        }
+        if (prevsick.value == 0)
+        {
+            prevsick.highlight_turns = 5;
+	    }
+        prevsick.value = Sick;
+	}
+
+    if (prevsick.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevsick.label);
+        sx += strlen(prevsick.label);
+    }
+
+    if (prevsick.txt != NULL)
+    {
+        color_stat(prevsick, ON);
+        mvwaddstr(win, sy, sx, prevsick.txt);
+        color_stat(prevsick, OFF);
+    }
+
+    if (prevsick.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevsick.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Slime */
+    if (Slimed != prevslime.value)
+	{
+	    prevslime.highlight_color = STAT_DOWN_COLOR;
+        if (prevslime.txt != NULL)
+        {
+            free(prevslime.txt);
+        }
+        if (Slimed)
+        {
+            prevslime.txt = curses_copy_of("Slime");
+        }
+        else
+        {
+            prevslime.txt = NULL;
+        }
+        if (prevslime.value == 0)
+        {
+            prevslime.highlight_turns = 5;
+	    }
+        prevslime.value = Slimed;
+	}
+
+    if (prevslime.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevslime.label);
+        sx += strlen(prevslime.label);
+    }
+
+    if (prevslime.txt != NULL)
+    {
+        color_stat(prevslime, ON);
+        mvwaddstr(win, sy, sx, prevslime.txt);
+        color_stat(prevslime, OFF);
+    }
+
+    if (prevslime.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevslime.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Encumberance */
+    enc = near_capacity();
+    
+    if (enc != prevencumb.value)
+	{
+	    if (enc < prevencumb.value)
+	    {
+	        prevencumb.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+	        prevencumb.highlight_color = STAT_DOWN_COLOR;
+        }
+        if (prevencumb.txt != NULL)
+        {
+            free(prevencumb.txt);
+        }
+        if (enc > UNENCUMBERED)
+        {
+            sprintf(buf, "%s", enc_stat[enc]);
+            prevencumb.txt = curses_copy_of(buf);
+            prevencumb.highlight_turns = 5;
+        }
+        else
+        {
+            prevencumb.txt = NULL;
+        }
+        prevencumb.value = enc;
+	}
+
+    if (prevencumb.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevencumb.label);
+        sx += strlen(prevencumb.label);
+    }
+
+    if (prevencumb.txt != NULL)
+    {
+        color_stat(prevencumb, ON);
+        mvwaddstr(win, sy, sx, prevencumb.txt);
+        color_stat(prevencumb, OFF);
+    }
+
+    if (prevencumb.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevencumb.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    wrefresh(win);
+}
+
+
+/* Decrement the highlight_turns for all stats.  Call curses_update_stats
+if needed to unhighlight a stat */
+
+void curses_decrement_highlight()
+{
+    boolean unhighlight = FALSE;
+    
+    if (prevname.highlight_turns > 0)
+    {
+        prevname.highlight_turns--;
+        if (prevname.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevdepth.highlight_turns > 0)
+    {
+        prevdepth.highlight_turns--;
+        if (prevdepth.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevstr.highlight_turns > 0)
+    {
+        prevstr.highlight_turns--;
+        if (prevstr.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevint.highlight_turns > 0)
+    {
+        prevint.highlight_turns--;
+        if (prevint.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevwis.highlight_turns > 0)
+    {
+        prevwis.highlight_turns--;
+        if (prevwis.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevdex.highlight_turns > 0)
+    {
+        prevdex.highlight_turns--;
+        if (prevdex.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevcon.highlight_turns > 0)
+    {
+        prevcon.highlight_turns--;
+        if (prevcon.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevcha.highlight_turns > 0)
+    {
+        prevcha.highlight_turns--;
+        if (prevcha.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevalign.highlight_turns > 0)
+    {
+        prevalign.highlight_turns--;
+        if (prevalign.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevau.highlight_turns > 0)
+    {
+        prevau.highlight_turns--;
+        if (prevau.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevhp.highlight_turns > 0)
+    {
+        prevhp.highlight_turns--;
+        if (prevhp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevmhp.highlight_turns > 0)
+    {
+        prevmhp.highlight_turns--;
+        if (prevmhp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevlevel.highlight_turns > 0)
+    {
+        prevlevel.highlight_turns--;
+        if (prevlevel.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevpow.highlight_turns > 0)
+    {
+        prevpow.highlight_turns--;
+        if (prevpow.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevmpow.highlight_turns > 0)
+    {
+        prevmpow.highlight_turns--;
+        if (prevmpow.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevac.highlight_turns > 0)
+    {
+        prevac.highlight_turns--;
+        if (prevac.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#ifdef EXP_ON_BOTL
+    if (prevexp.highlight_turns > 0)
+    {
+        prevexp.highlight_turns--;
+        if (prevexp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#endif
+    if (prevtime.highlight_turns > 0)
+    {
+        prevtime.highlight_turns--;
+        if (prevtime.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#ifdef SCORE_ON_BOTL
+    if (prevscore.highlight_turns > 0)
+    {
+        prevscore.highlight_turns--;
+        if (prevscore.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#endif
+    if (prevhunger.highlight_turns > 0)
+    {
+        prevhunger.highlight_turns--;
+        if (prevhunger.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevconf.highlight_turns > 0)
+    {
+        prevconf.highlight_turns--;
+        if (prevconf.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevblind.highlight_turns > 0)
+    {
+        prevblind.highlight_turns--;
+        if (prevblind.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevstun.highlight_turns > 0)
+    {
+        prevstun.highlight_turns--;
+        if (prevstun.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevhallu.highlight_turns > 0)
+    {
+        prevhallu.highlight_turns--;
+        if (prevhallu.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevsick.highlight_turns > 0)
+    {
+        prevsick.highlight_turns--;
+        if (prevsick.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevslime.highlight_turns > 0)
+    {
+        prevslime.highlight_turns--;
+        if (prevslime.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevencumb.highlight_turns > 0)
+    {
+        prevencumb.highlight_turns--;
+        if (prevencumb.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    
+    if (unhighlight)
+    {
+        curses_update_stats(FALSE);
+    }
+}
+
+
+/* Initialize the stats with beginning values. */
+
+static void init_stats()
+{
+    char buf[BUFSZ];
+    int count;
+
+    /* Player name and title */
+    strcpy(buf, plname);
+    if ('a' <= buf[0] && buf[0] <= 'z') buf[0] += 'A'-'a';
+    strcat(buf, " the ");
+    if (u.mtimedone) {
+        char mname[BUFSZ];
+        int k = 0;
+
+        strcpy(mname, mons[u.umonnum].mname);
+        while(mname[k] != 0) {
+            if ((k == 0 || (k > 0 && mname[k-1] == ' '))
+             && 'a' <= mname[k] && mname[k] <= 'z')
+            {
+                mname[k] += 'A' - 'a';
+            }
+            k++;
+        }
+        strcat(buf, mname);
+    } else {
+        strcat(buf, rank_of(u.ulevel, pl_character[0], flags.female));
+    }
+
+    prevname.txt = curses_copy_of(buf);
+    prevname.display = TRUE;
+    prevname.highlight_turns = 0;
+    prevname.label = NULL;
+    prevname.id = "name";
+    set_stat_color(&prevname);
+    
+    /* Strength */
+    if (ACURR(A_STR) > 118)
+    {
+        sprintf(buf, "%d", ACURR(A_STR) - 100);
+    }
+    else if (ACURR(A_STR)==118)
+    {
+        sprintf(buf, "18/**");
+    }
+    else if(ACURR(A_STR) > 18)
+    {
+        sprintf(buf, "18/%02d", ACURR(A_STR) - 18);
+    }
+    else
+    {
+        sprintf(buf, "%d", ACURR(A_STR));
+    }
+
+    prevstr.value = ACURR(A_STR);
+    prevstr.txt = curses_copy_of(buf);
+    prevstr.display = TRUE;
+    prevstr.highlight_turns = 0;
+    prevstr.label = NULL;
+    prevstr.id = "str";
+    set_stat_color(&prevstr);
+
+    /* Intelligence */
+    sprintf(buf, "%d", ACURR(A_INT));
+    prevint.value = ACURR(A_INT);
+    prevint.txt = curses_copy_of(buf);
+    prevint.display = TRUE;
+    prevint.highlight_turns = 0;
+    prevint.label = NULL;
+    prevint.id = "int";
+    set_stat_color(&prevint);
+
+    /* Wisdom */
+    sprintf(buf, "%d", ACURR(A_WIS));
+    prevwis.value = ACURR(A_WIS);
+    prevwis.txt = curses_copy_of(buf);
+    prevwis.display = TRUE;
+    prevwis.highlight_turns = 0;
+    prevwis.label = NULL;
+    prevwis.id = "wis";
+    set_stat_color(&prevwis);
+
+    /* Dexterity */
+    sprintf(buf, "%d", ACURR(A_DEX));
+    prevdex.value = ACURR(A_DEX);
+    prevdex.txt = curses_copy_of(buf);
+    prevdex.display = TRUE;
+    prevdex.highlight_turns = 0;
+    prevdex.label = NULL;
+    prevdex.id = "dex";
+    set_stat_color(&prevdex);
+
+    /* Constitution */
+    sprintf(buf, "%d", ACURR(A_CON));
+    prevcon.value = ACURR(A_CON);
+    prevcon.txt = curses_copy_of(buf);
+    prevcon.display = TRUE;
+    prevcon.highlight_turns = 0;
+    prevcon.label = NULL;
+    prevcon.id = "con";
+    set_stat_color(&prevcon);
+
+    /* Charisma */
+    sprintf(buf, "%d", ACURR(A_CHA));
+    prevcha.value = ACURR(A_CHA);
+    prevcha.txt = curses_copy_of(buf);
+    prevcha.display = TRUE;
+    prevcha.highlight_turns = 0;
+    prevcha.label = NULL;
+    prevcha.id = "cha";
+    set_stat_color(&prevcha);
+
+    /* Alignment */
+    switch (u.ualign.type)
+    {
+        case A_LAWFUL:
+        {
+            prevalign.txt = curses_copy_of("Lawful");
+            break;
+        }
+        case A_NEUTRAL:
+        {
+            prevalign.txt = curses_copy_of("Neutral");
+            break;
+        }
+        case A_CHAOTIC:
+        {
+            prevalign.txt = curses_copy_of("Chaotic");
+            break;
+        }
+    }
+    
+    prevalign.alignment = u.ualign.type;
+    prevalign.display = TRUE;
+    prevalign.highlight_turns = 0;
+    prevalign.label = NULL;
+    prevalign.id = "align";
+    set_stat_color(&prevalign);
+    
+    /* Dungeon level */
+    if (In_endgame(&u.uz))
+    {
+        strcpy(buf, (Is_astralevel(&u.uz) ? "Astral Plane":"End Game"));
+    }
+    else
+    {
+        sprintf(buf, "%d", depth(&u.uz));
+    }
+
+    prevdepth.value = depth(&u.uz);
+    prevdepth.txt = curses_copy_of(buf);
+    prevdepth.display = TRUE;
+    prevdepth.highlight_turns = 0;
+    prevdepth.label = NULL;
+    prevdepth.id = "dlvl";
+    set_stat_color(&prevdepth);
+    
+    /* Gold */
+#ifndef GOLDOBJ
+    sprintf(buf,"%ld", u.ugold);
+    prevau.value = u.ugold;
+#else
+    sprintf(buf,"%ld", money_cnt(invent));
+    prevau.value = money_cnt(invent);
+#endif
+    prevau.txt = curses_copy_of(buf);
+    prevau.display = TRUE;
+    prevau.highlight_turns = 0;
+    prevau.label = NULL;
+    prevau.id = "gold";
+    set_stat_color(&prevau);
+
+    /* Hit Points */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevhp.value = u.mh;
+        sprintf(buf, "%d", u.mh);
+        prevhp.txt = curses_copy_of(buf);
+	}
+	else if (u.uhp != prevhp.value)  /* Not polymorphed */
+	{
+	    prevhp.value = u.uhp;
+        sprintf(buf, "%d", u.uhp);
+        prevhp.txt = curses_copy_of(buf);
+	}
+	prevhp.display = TRUE;
+	prevhp.highlight_turns = 0;
+    prevhp.label = NULL;
+    prevhp.id = "hp";
+    set_stat_color(&prevhp);
+
+    /* Max Hit Points */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevmhp.value = u.mhmax;
+        sprintf(buf, "%d", u.mhmax);
+        prevmhp.txt = curses_copy_of(buf);
+	}
+	else    /* Not polymorphed */
+	{
+	    prevmhp.value = u.uhpmax;
+        sprintf(buf, "%d", u.uhpmax);
+        prevmhp.txt = curses_copy_of(buf);
+	}
+	prevmhp.display = TRUE;
+	prevmhp.highlight_turns = 0;
+    prevmhp.label = curses_copy_of("/");
+    prevmhp.id = "mhp";
+    set_stat_color(&prevmhp);
+
+    /* Power */
+    prevpow.value = u.uen;
+    sprintf(buf, "%d", u.uen);
+    prevpow.txt = curses_copy_of(buf);
+	prevpow.display = TRUE;
+	prevpow.highlight_turns = 0;
+    prevpow.label = NULL;
+    prevpow.id = "pw";
+    set_stat_color(&prevpow);
+
+    /* Max Power */
+    prevmpow.value = u.uenmax;
+    sprintf(buf, "%d", u.uenmax);
+    prevmpow.txt = curses_copy_of(buf);
+	prevmpow.display = TRUE;
+	prevmpow.highlight_turns = 0;
+    prevmpow.label = curses_copy_of("/");
+    prevmpow.id = "mpw";
+    set_stat_color(&prevmpow);
+
+    /* Armor Class */
+    prevac.value = u.uac;
+    sprintf(buf, "%d", u.uac);
+    prevac.txt = curses_copy_of(buf);
+	prevac.display = TRUE;
+	prevac.highlight_turns = 0;
+    prevac.label = NULL;
+    prevac.id = "ac";
+    set_stat_color(&prevac);
+
+    /* Experience */
+#ifdef EXP_ON_BOTL
+    prevexp.value = u.uexp;
+    sprintf(buf, "%ld", u.uexp);
+    prevexp.txt = curses_copy_of(buf);
+	prevexp.display = flags.showexp;
+	prevexp.highlight_turns = 0;
+    prevexp.label = NULL;
+    prevexp.id = "xp";
+    set_stat_color(&prevexp);
+#endif
+
+    /* Level */
+    prevlevel.label = NULL;
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevlevel.value = mons[u.umonnum].mlevel;
+        sprintf(buf, "%d", mons[u.umonnum].mlevel);
+        prevlevel.txt = curses_copy_of(buf);
+	}
+	else if (u.ulevel != prevlevel.value)  /* Not polymorphed */
+	{
+	    prevlevel.value = u.ulevel;
+        sprintf(buf, "%d", u.ulevel);
+        prevlevel.txt = curses_copy_of(buf);
+	}
+	prevlevel.display = TRUE;
+	prevlevel.highlight_turns = 0;
+    prevlevel.id = "lvl";
+    set_stat_color(&prevlevel);
+
+    /* Time */
+    prevtime.value = moves;
+    sprintf(buf, "%ld", moves);
+    prevtime.txt = curses_copy_of(buf);
+	prevtime.display = flags.time;
+	prevtime.highlight_turns = 0;
+    prevtime.label = NULL;
+    prevtime.id = "time";
+    set_stat_color(&prevtime);
+
+    /* Score */
+#ifdef SCORE_ON_BOTL
+    prevscore.value = botl_score();
+    sprintf(buf, "%ld", botl_score());
+    prevscore.txt = curses_copy_of(buf);
+	prevscore.display = flags.showscore;
+	prevscore.highlight_turns = 0;
+    prevscore.label = NULL;
+    prevscore.id = "score";
+    set_stat_color(&prevscore);
+#endif
+
+    /* Hunger */
+    prevhunger.value = u.uhs;
+    for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+    {
+        if ((hu_stat[u.uhs][count]) == ' ')
+        {
+            break;
+        }
+        buf[count] = hu_stat[u.uhs][count];
+    }
+
+    buf[count] = '\0';
+    prevhunger.txt = curses_copy_of(buf);
+    prevhunger.display = TRUE;
+    prevhunger.highlight_turns = 0;
+    prevhunger.label = NULL;
+    prevhunger.id = "hunger";
+    set_stat_color(&prevhunger);
+
+    /* Confusion */
+    prevconf.value = Confusion;
+    if (Confusion)
+    {
+        prevconf.txt = curses_copy_of("Conf");
+    }
+    else
+    {
+        prevconf.txt = NULL;
+    }
+    prevconf.display = TRUE;
+    prevconf.highlight_turns = 0;
+    prevconf.label = NULL;
+    prevconf.id = "conf";
+    set_stat_color(&prevconf);
+
+    /* Blindness */
+    prevblind.value = Blind;
+    if (Blind)
+    {
+        prevblind.txt = curses_copy_of("Blind");
+    }
+    else
+    {
+        prevblind.txt = NULL;
+    }
+    prevblind.display = TRUE;
+    prevblind.highlight_turns = 0;
+    prevblind.label = NULL;
+    prevblind.id = "blind";
+    set_stat_color(&prevblind);
+
+    /* Stun */
+    prevstun.value = Stunned;
+    if (Stunned)
+    {
+        prevstun.txt = curses_copy_of("Stun");
+    }
+    else
+    {
+        prevstun.txt = NULL;
+    }
+    prevstun.display = TRUE;
+    prevstun.highlight_turns = 0;
+    prevstun.label = NULL;
+    prevstun.id = "stun";
+    set_stat_color(&prevstun);
+
+    /* Hallucination */
+    prevhallu.value = Hallucination;
+    if (Hallucination)
+    {
+        prevhallu.txt = curses_copy_of("Hallu");
+    }
+    else
+    {
+        prevhallu.txt = NULL;
+    }
+    prevhallu.display = TRUE;
+    prevhallu.highlight_turns = 0;
+    prevhallu.label = NULL;
+    prevhallu.id = "hallu";
+    set_stat_color(&prevhallu);
+
+    /* Sick */
+    prevsick.value = Sick;
+    if (Sick)
+    {
+        if (u.usick_type & SICK_VOMITABLE)
+        {
+            prevsick.txt = curses_copy_of("FoodPois");
+        }
+        else     
+        {
+            prevsick.txt = curses_copy_of("Ill");
+        }
+    }
+    else
+    {
+        prevsick.txt = NULL;
+    }
+    prevsick.display = TRUE;
+    prevsick.highlight_turns = 0;
+    prevsick.label = NULL;
+    prevsick.id = "sick";
+    set_stat_color(&prevsick);
+
+    /* Slimed */
+    prevslime.value = Slimed;
+    if (Slimed)
+    {
+        prevslime.txt = curses_copy_of("Slime");
+    }
+    else
+    {
+        prevslime.txt = NULL;
+    }
+    prevslime.display = TRUE;
+    prevslime.highlight_turns = 0;
+    prevslime.label = NULL;
+    prevslime.id = "slime";
+    set_stat_color(&prevslime);
+
+    /* Encumberance */
+    prevencumb.value = near_capacity();
+    if (prevencumb.value > UNENCUMBERED)
+    {
+        sprintf(buf, "%s", enc_stat[prevencumb.value]);
+        prevencumb.txt = curses_copy_of(buf);
+    }
+    else
+    {
+        prevencumb.txt = NULL;
+    }
+    prevencumb.display = TRUE;
+    prevencumb.highlight_turns = 0;
+    prevencumb.label = NULL;
+    prevencumb.id = "encumberance";
+    set_stat_color(&prevencumb);
+}
+
+/* Set labels based on orientation of status window.  If horizontal,
+we want to compress this info; otherwise we know we have a width of at
+least 26 characters. */
+
+static void set_labels(int label_width)
+{
+    char buf[BUFSZ];
+
+    switch (label_width)
+    {
+        case COMPACT_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("S:");
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("I:");
+
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("W:");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("D:");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("C:");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Ch:");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = NULL;
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dl:");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            sprintf(buf, "%c:", GOLD_SYM);
+            prevau.label = curses_copy_of(buf);
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("HP:");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Pw:");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("AC:");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("XP:");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+                prevlevel.label = NULL;
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("HD:");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of("/");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Lv:");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("T:");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("S:");
+#endif
+            break;
+        }
+        case NORMAL_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("Str:");
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("Int:");
+
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("Wis:");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("Dex:");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("Con:");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Cha:");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = NULL;
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dlvl:");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            sprintf(buf, "%c:", GOLD_SYM);
+            prevau.label = curses_copy_of(buf);
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("HP:");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Pw:");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("AC:");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("XP:");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+                prevlevel.label = NULL;
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("HD:");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of("/");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Lvl:");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("T:");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("S:");
+#endif
+            break;
+        }
+        case WIDE_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("Strength:      ");
+            
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("Intelligence:  ");
+            
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("Wisdom:        ");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("Dexterity:     ");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("Constitution:  ");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Charisma:      ");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = curses_copy_of("Alignment:     ");
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dungeon Level: ");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            prevau.label = curses_copy_of("Gold:          ");
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("Hit Points:    ");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Magic Power:   ");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("Armor Class:   ");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("Experience:    ");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("Hit Dice:      ");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of(" / ");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Level:         ");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("Time:          ");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("Score:         ");
+#endif
+            break;
+        }
+        default:
+        {
+            panic( "set_labels(): Invalid label_width %d\n",
+             label_width );
+            break;
+        }
+    }
+}
+
+
+/* Get the default (non-highlighted) color for a stat.  For now, this
+is NO_COLOR unless the statuscolors patch is in use. */
+
+static void set_stat_color(nhstat *stat)
+{
+#ifdef STATUS_COLORS
+    struct color_option stat_color;
+    int count;
+    int attr = A_NORMAL;
+
+    if (iflags.use_status_colors && stat_colored(stat->id))
+    {
+        stat_color = text_color_of(stat->id, text_colors);
+
+        for (count = 0; (1 << count) <= stat_color.attr_bits; ++count)
+    	{
+    	    if (count != ATR_NONE && stat_color.attr_bits & (1 << count))
+    	    {
+    		    attr += curses_convert_attr(count);
+    		}
+        }
+
+        stat->stat_color = stat_color.color;
+        stat->stat_attr = attr;
+    }
+    else
+    {
+        stat->stat_color = NO_COLOR;
+        stat->stat_attr = A_NORMAL;
+    }
+#else
+    stat->stat_color = NO_COLOR;
+    stat->stat_attr = A_NORMAL;
+#endif  /* STATUS_COLORS */
+}
+
+
+/* Set the color to the base color for the given stat, or highlight a
+ changed stat. */
+
+static void color_stat(nhstat stat, int onoff)
+{
+    WINDOW *win = curses_get_nhwin(STATUS_WIN);
+#ifdef STATUS_COLORS
+    struct color_option stat_color;
+    int color, attr, hp, hpmax, count;
+    char buf[BUFSIZ];
+
+    stat_color.color = NO_COLOR;
+    stat_color.attr_bits = ATR_NONE;
+    
+    if (strcmp(stat.id, "hp") == 0)
+    {
+     	hp = Upolyd ? u.mh : u.uhp;
+     	hpmax = Upolyd ? u.mhmax : u.uhpmax;
+        stat_color = percentage_color_of(hp, hpmax, hp_colors);
+    }
+    
+    if (strcmp(stat.id, "pw") == 0)
+    {
+        stat_color = percentage_color_of(u.uen, u.uenmax, pw_colors);
+    }
+        
+    if (strcmp(stat.id, "hunger") == 0)
+    {
+        for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+        {
+            if ((hu_stat[u.uhs][count]) == ' ')
+            {
+                break;
+            }
+            buf[count] = hu_stat[u.uhs][count];
+        }
+
+        buf[count] = '\0';
+        stat_color = text_color_of(buf, text_colors);
+    }
+    
+    if (strcmp(stat.id, "encumberance") == 0)
+    {
+        stat_color = text_color_of(enc_stat[prevencumb.value],
+         text_colors);
+    }
+    
+    if (strcmp(stat.id, "sick") == 0)
+    {
+        if (u.usick_type & SICK_VOMITABLE)
+        {
+            stat_color = text_color_of("foodpois", text_colors);
+        }
+        else     
+        {
+            stat_color = text_color_of("ill", text_colors);
+        }
+    }
+
+    if (strcmp(stat.id, "align") == 0)
+    {
+        switch (u.ualign.type)
+        {
+            case A_LAWFUL:
+            {
+                stat_color = text_color_of("lawful", text_colors);
+                break;
+            }
+            case A_NEUTRAL:
+            {
+                stat_color = text_color_of("neutral", text_colors);
+                break;
+            }
+            case A_CHAOTIC:
+            {
+                stat_color = text_color_of("chaotic", text_colors);
+                break;
+            }
+        }
+    }
+
+    color = stat_color.color;
+    attr = A_NORMAL;
+
+    for (count = 0; (1 << count) <= stat_color.attr_bits; ++count)
+	{
+	    if (count != ATR_NONE && stat_color.attr_bits & (1 << count))
+	    {
+		    attr += curses_convert_attr(count);
+		}
+    }
+
+    stat.stat_color = color;
+    stat.stat_attr = attr;
+#endif  /* STATUS_COLORS */
+    
+    if ((stat.stat_color == NO_COLOR) && (stat.stat_attr == A_NORMAL))
+    {
+        if (stat.highlight_turns > 0)
+        {
+#ifdef STATUS_COLORS
+            if (iflags.use_status_colors)
+#endif
+            curses_toggle_color_attr(win, stat.highlight_color,
+             A_NORMAL, onoff);
+        }
+
+        return;
+    }
+
+#ifdef STATUS_COLORS
+    if (iflags.use_status_colors)
+#endif
+    curses_toggle_color_attr(win, stat.stat_color, stat.stat_attr,
+        onoff);
+}
+
+
+/* Determine if a stat is configured via statuscolors. */
+
+#ifdef STATUS_COLORS
+static boolean stat_colored(const char *id)
+{
+    struct text_color_option *cur_option = 
+     (struct text_color_option *)text_colors;
+    
+    while(cur_option != NULL)
+    {
+        if (strcmpi(cur_option->text, id) == 0)
+        {
+            return TRUE;
+        }
+        
+        cur_option = (struct text_color_option *)cur_option->next;
+    }
+    
+    return FALSE;
+}
+#endif  /* STATUS_COLORS */
+
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/cursstat.h nethack-3.4.3-nao-osx/win/curses/cursstat.h
--- nethack-3.4.3/win/curses/cursstat.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/cursstat.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,12 @@
+#ifndef CURSSTAT_H
+#define CURSSTAT_H
+
+
+/* Global declarations */
+
+void curses_update_stats(boolean redraw);
+
+void curses_decrement_highlight(void);
+
+
+#endif  /* CURSSTAT_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/curswins.c nethack-3.4.3-nao-osx/win/curses/curswins.c
--- nethack-3.4.3/win/curses/curswins.c	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/curswins.c	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,820 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "curswins.h"
+
+/* Window handling for curses interface */
+
+/* Private declarations */
+
+typedef struct nhw
+{
+    winid nhwin;  /* NetHack window id */
+    WINDOW *curwin; /* Curses window pointer */
+    int width;  /* Usable width not counting border */
+    int height; /* Usable height not counting border */
+    int x;  /* start of window on terminal (left) */
+    int y;  /* start of window on termial (top) */
+    int orientation;    /* Placement of window relative to map */
+    boolean border; /* Whether window has a visible border */
+} nethack_window;
+
+typedef struct nhwd
+{
+    winid nhwid;  /* NetHack window id */
+    struct nhwd *prev_wid;    /* Pointer to previous entry */
+    struct nhwd *next_wid;    /* Pointer to next entry */
+} nethack_wid;
+
+typedef struct nhchar
+{
+    int ch;     /* character */
+    int color;  /* color info for character */
+    int attr;   /* attributes of character */
+} nethack_char;
+
+static boolean map_clipped; /* Map window smaller than 80x21 */
+
+static nethack_window nhwins[NHWIN_MAX];    /* NetHack window array */
+
+static nethack_char map[ROWNO][COLNO];  /* Map window contents */
+
+static nethack_wid *nhwids = NULL;  /* NetHack wid array */
+
+static boolean is_main_window(winid wid);
+
+static void write_char(WINDOW *win, int x, int y, nethack_char ch);
+
+static void clear_map(void);
+
+/* Create a window with the specified size and orientation */
+
+WINDOW *curses_create_window(int width, int height, orient orientation)
+{
+    int mapx, mapy, maph, mapw = 0;
+    int startx = 0;
+    int starty = 0;
+    WINDOW *win;
+    boolean map_border = FALSE;
+    int mapb_offset = 0;
+        
+    if ((orientation == UP) || (orientation == DOWN) ||
+     (orientation == LEFT) || (orientation == RIGHT))
+    {
+        if (invent || (moves > 1))
+        {
+            map_border = curses_window_has_border(MAP_WIN);
+            curses_get_window_xy(MAP_WIN, &mapx, &mapy);
+            curses_get_window_size(MAP_WIN, &maph, &mapw);
+        }
+        else
+        {
+            map_border = TRUE;
+            mapx = 0;
+            mapy = 0;
+            maph = term_rows;
+            mapw = term_cols;
+        }
+    }
+    
+    if (map_border)
+    {
+        mapb_offset = 1;
+    }
+    
+    width += 2;    /* leave room for bounding box */
+    height += 2;
+    
+    if ((width > term_cols) || (height > term_rows))
+        panic("curses_create_window: Terminal too small for dialog window");
+    switch (orientation)
+    {
+        case CENTER:
+        {
+            startx = (term_cols / 2) - (width / 2);
+            starty = (term_rows / 2) - (height / 2);
+            break;
+        }
+        case UP:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw / 2) - (width / 2) + mapx + mapb_offset;
+            }
+            else
+            {
+                startx = 0;
+            }
+            
+            starty = mapy + mapb_offset;
+            break;
+        }
+        case DOWN:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw / 2) - (width / 2) + mapx + mapb_offset;
+            }
+            else
+            {
+                startx = 0;
+            }
+            
+            starty = height - mapy - 1 - mapb_offset;
+            break;
+        }
+        case LEFT:
+        {
+            if (map_border && (width < term_cols))
+                startx = 1;
+            else
+                startx = 0;
+            starty = term_rows - height;
+            break;
+        }
+        case RIGHT:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw + mapx + (mapb_offset * 2)) - width;
+            }
+            else
+            {
+                startx = term_cols - width;
+            }
+            
+            starty = 0;
+            break;
+        }
+        default:
+        {
+            panic("curses_create_window: Bad orientation");
+        }
+    }
+    
+    if (startx < 0)
+    {
+        startx = 0;
+    }
+    
+    if (starty < 0)
+    {
+        starty = 0;
+    }
+  
+    win = newwin(height, width, starty, startx);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, ON);
+    box(win, 0, 0);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, OFF);
+    return win;
+}
+
+
+/* Erase and delete curses window, and refresh standard windows */
+
+void curses_destroy_win(WINDOW *win)
+{
+    werase(win);
+    wrefresh(win);
+    delwin(win);
+    curses_refresh_nethack_windows();
+}
+
+
+/* Refresh nethack windows if they exist, or base window if not */
+
+void curses_refresh_nethack_windows()
+{
+    WINDOW *status_window, *message_window, *map_window;
+    
+    status_window = curses_get_nhwin(STATUS_WIN);
+    message_window = curses_get_nhwin(MESSAGE_WIN);
+    map_window = curses_get_nhwin(MAP_WIN);
+    
+    if ((moves <= 1) && !invent)
+    {
+        /* Main windows not yet displayed; refresh base window instead */
+        touchwin(stdscr);
+        refresh();
+    }
+    else
+    {
+        touchwin(status_window);
+        wnoutrefresh(status_window);
+        touchwin(map_window);
+        wnoutrefresh(map_window);
+        touchwin(message_window);
+        wnoutrefresh(message_window);
+        doupdate();
+    }
+}
+
+
+/* Return curses window pointer for given NetHack winid */
+
+WINDOW *curses_get_nhwin(winid wid)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_nhwin: wid out of range. Not a main window.");
+    }
+    
+    return nhwins[wid].curwin;
+}
+
+
+/* Add curses window pointer and window info to list for given NetHack winid */
+
+void curses_add_nhwin(winid wid, int height, int width, int y, int x,
+  orient orientation, boolean border)
+{
+    WINDOW *win;
+    int real_width = width;
+    int real_height = height;
+    
+    if (!is_main_window(wid))
+    {
+        panic("curses_add_nhwin: wid out of range. Not a main window.");
+    }
+    
+    nhwins[wid].nhwin = wid;
+    nhwins[wid].border = border;
+    nhwins[wid].width = width;
+    nhwins[wid].height = height;
+    nhwins[wid].x = x;
+    nhwins[wid].y = y;
+    nhwins[wid].orientation = orientation;
+    
+    if (border)
+    {
+        real_width += 2;    /* leave room for bounding box */
+        real_height += 2;
+    }
+    
+    win = newwin(real_height, real_width, y, x);
+    
+    switch (wid)
+    {
+        case MESSAGE_WIN:
+        {
+            messagewin = win;
+            break;
+        }
+        case STATUS_WIN:
+        {
+            statuswin = win;
+            break;
+        }
+        case MAP_WIN:
+        {
+            mapwin = win;
+            
+            if ((width < COLNO) || (height < ROWNO))
+            {
+                map_clipped = TRUE;
+            }
+            else
+            {
+                map_clipped = FALSE;
+            }
+            
+            break;
+        }
+    }
+    
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+    
+    nhwins[wid].curwin = win;
+}
+
+
+/* Add wid to list of known window IDs */
+
+void curses_add_wid(winid wid)
+{
+    nethack_wid *new_wid;
+    nethack_wid *widptr = nhwids;
+    
+    new_wid = malloc(sizeof(nethack_wid));
+    new_wid->nhwid = wid;
+    
+    new_wid->next_wid = NULL;
+    
+    if (widptr == NULL)
+    {
+        new_wid->prev_wid = NULL;
+        nhwids = new_wid;
+    }
+    else
+    {
+        while (widptr->next_wid != NULL)
+        {
+            widptr = widptr->next_wid;
+        }
+        new_wid->prev_wid = widptr;
+        widptr->next_wid = new_wid;
+    }
+}
+
+
+/* refresh a curses window via given nethack winid */
+
+void curses_refresh_nhwin(winid wid)
+{
+    wrefresh(curses_get_nhwin(wid));
+}
+
+
+/* Delete curses window via given NetHack winid and remove entry from list */
+
+void curses_del_nhwin(winid wid)
+{
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_del_menu(wid);
+        return;
+    }
+    
+    if (!is_main_window(wid))
+    {
+        panic("curses_del_nhwin: wid out of range. Not a main window.");
+    }
+
+    nhwins[wid].nhwin = -1;
+}
+
+
+/* Delete wid from list of known window IDs */
+
+void curses_del_wid(winid wid)
+{
+    nethack_wid *tmpwid;
+    nethack_wid *widptr = nhwids;
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_del_menu(wid);
+    }
+    
+    while (widptr != NULL)
+    {
+        if (widptr->nhwid == wid)
+        {
+            if (widptr->prev_wid != NULL)
+            {
+                tmpwid = widptr->prev_wid;
+                tmpwid->next_wid = widptr->next_wid;
+            }
+            else
+            {
+                nhwids = widptr->next_wid;   /* New head mode, or NULL */
+            }
+            if (widptr->next_wid != NULL)
+            {
+                tmpwid = widptr->next_wid;
+                tmpwid->prev_wid = widptr->prev_wid;
+            }
+            free(widptr);
+            break;
+        }
+        widptr = widptr->next_wid;
+    }
+}
+
+
+/* Print a single character in the given window at the given coordinates */
+
+void curses_putch(winid wid, int x, int y, int ch, int color, int attr)
+{
+    int sx, sy, ex, ey;
+    boolean border = curses_window_has_border(wid);
+    nethack_char nch;
+    static boolean map_initted = FALSE;
+
+    if (wid == STATUS_WIN)
+    {
+        curses_update_stats(FALSE);
+    }
+
+    if (wid != MAP_WIN)
+    {
+        return;
+    }
+
+    if (!map_initted)
+    {
+        clear_map();
+        map_initted = TRUE;
+    }
+
+    map[y][x].ch = ch;
+    map[y][x].color = color;
+    map[y][x].attr = attr;
+    nch = map[y][x];
+    
+    (void)curses_map_borders(&sx, &sy, &ex, &ey, -1, -1);
+    
+    if ((x >= sx) && (x <= ex) && (y >= sy) && (y <= ey))
+    {
+        if (border)
+        {
+            x++;
+            y++;
+        }
+
+        write_char(mapwin, x - sx, y - sy, nch);
+    }
+
+    wrefresh(mapwin);
+}
+
+
+/* Get x, y coordinates of curses window on the physical terminal window */
+
+void curses_get_window_xy(winid wid, int *x, int *y)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_window_xy: wid out of range. Not a main window.");
+    }
+
+    *x = nhwins[wid].x;
+    *y = nhwins[wid].y;
+}
+
+
+/* Get usable width and height curses window on the physical terminal window */
+
+void curses_get_window_size(winid wid, int *height, int *width)
+{
+    *height = nhwins[wid].height;
+    *width = nhwins[wid].width;
+}
+
+
+/* Determine if given window has a visible border */
+
+boolean curses_window_has_border(winid wid)
+{
+    return nhwins[wid].border;
+}
+
+
+/* Determine if window for given winid exists */
+
+boolean curses_window_exists(winid wid)
+{
+    nethack_wid *widptr = nhwids;
+    
+    while (widptr != NULL)
+    {
+        if (widptr->nhwid == wid)
+        {
+            return TRUE;
+	}
+
+	widptr = widptr->next_wid;
+    }
+
+    return FALSE;
+}
+
+
+/* Return the orientation of the specified window */
+
+int curses_get_window_orientation(winid wid)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_window_orientation: wid out of range. Not a main window.");
+    }
+
+    return nhwins[wid].orientation;    
+}
+
+
+/* Output a line of text to specified NetHack window with given coordinates
+and text attributes */
+
+void curses_puts(winid wid, int attr, const char *text)
+{
+    anything *identifier;
+    WINDOW *win = NULL;
+    
+    if (is_main_window(wid))
+    {
+        win = curses_get_nhwin(wid);
+    }
+        
+    if (wid == MESSAGE_WIN)
+    {
+        curses_message_win_puts(text, FALSE);
+        return;
+    }
+    
+    if (wid == STATUS_WIN)
+    {
+        curses_update_stats(FALSE);  /* We will do the write ourselves */
+        return;
+    }
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        if (!curses_menu_exists(wid))
+        {
+            panic("curses_puts: Attempted write to nonexistant window!"); 
+        }
+        identifier = malloc(sizeof(anything));
+        identifier->a_void = NULL;
+        curses_add_nhmenu_item(wid, identifier, 0, 0, attr, text,
+         FALSE);
+    }
+    else
+    {
+        waddstr(win, text);
+        wrefresh(win);
+    }
+}
+
+
+/* Clear the contents of a window via the given NetHack winid */
+
+void curses_clear_nhwin(winid wid)
+{
+    WINDOW *win = curses_get_nhwin(wid);
+    boolean border = curses_window_has_border(wid);
+    
+    if (wid == MAP_WIN)
+    {
+        clearok(win, TRUE); /* Redraw entire screen when refreshed */
+        clear_map();
+    }
+        
+    werase(win);
+
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+}
+
+
+/* Return true if given wid is a main NetHack window */
+
+static boolean is_main_window(winid wid)
+{
+    if ((wid == MESSAGE_WIN) || (wid == MAP_WIN) ||
+     (wid == STATUS_WIN))
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Unconditionally write a single character to a window at the given
+coordinates without a refresh.  Currently only used for the map. */
+
+static void write_char(WINDOW *win, int x, int y, nethack_char nch)
+{
+    curses_toggle_color_attr(win, nch.color, nch.attr, ON);
+#ifdef PDCURSES
+    mvwaddrawch(win, y, x, nch.ch);
+#else
+    mvwaddch(win, y, x, nch.ch);
+#endif
+    curses_toggle_color_attr(win, nch.color, nch.attr, OFF);
+}
+
+
+/* Draw the entire visible map onto the screen given the visible map
+boundaries */
+
+void curses_draw_map(int sx, int sy, int ex, int ey)
+{
+    int curx, cury;
+    int bspace = 0;
+#ifdef MAP_SCROLLBARS
+    int sbsx, sbsy, sbex, sbey, count;
+    nethack_char hsb_back, hsb_bar, vsb_back, vsb_bar;
+#endif
+    
+    if (curses_window_has_border(MAP_WIN))
+    {
+        bspace++;
+    }
+    
+#ifdef MAP_SCROLLBARS
+    hsb_back.ch = '-';
+    hsb_back.color = SCROLLBAR_BACK_COLOR;
+    hsb_back.attr = A_NORMAL;
+    hsb_bar.ch = '*';
+    hsb_bar.color = SCROLLBAR_COLOR;
+    hsb_bar.attr = A_NORMAL;
+    vsb_back.ch = '|';
+    vsb_back.color = SCROLLBAR_BACK_COLOR;
+    vsb_back.attr = A_NORMAL;
+    vsb_bar.ch = '*';
+    vsb_bar.color = SCROLLBAR_COLOR;
+    vsb_bar.attr = A_NORMAL;
+
+    /* Horizontal scrollbar */
+    if ((sx > 0) || (ex < (COLNO - 1)))
+    {
+        sbsx = (sx * ((float)(ex - sx + 1) / COLNO));
+        sbex = (ex * ((float)(ex - sx + 1) / COLNO));
+        
+        for (count = 0; count < sbsx; count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_back);
+        }
+        
+        for (count = sbsx; count <= sbex; count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_bar);
+        }
+        
+        for (count = sbex + 1; count <= (ex - sx); count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_back);
+        }
+    }
+    
+    /* Vertical scrollbar */
+    if ((sy > 0) || (ey < (ROWNO - 1)))
+    {
+        sbsy = (sy * ((float)(ey - sy + 1) / ROWNO));
+        sbey = (ey * ((float)(ey - sy + 1) / ROWNO));
+
+        for (count = 0; count < sbsy; count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_back);
+        }
+        
+        for (count = sbsy; count <= sbey; count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_bar);
+        }
+        
+        for (count = sbey + 1; count <= (ey - sy); count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_back);
+        }
+    }    
+#endif  /* MAP_SCROLLBARS */
+
+    for (curx = sx; curx <= ex; curx++)
+    {
+        for (cury = sy; cury <= ey; cury++)
+        {
+            write_char(mapwin, curx - sx + bspace, cury - sy + bspace,
+             map[cury][curx]);
+        }
+    }
+}
+
+
+/* Init map array to blanks */
+
+static void clear_map()
+{
+    int x, y;
+    
+    for (x = 0; x < COLNO; x++)
+    {
+        for (y = 0; y < ROWNO; y++)
+        {
+            map[y][x].ch = ' ';
+            map[y][x].color = NO_COLOR;
+            map[y][x].attr = A_NORMAL;
+        }
+    }
+}
+
+
+/* Determine visible boundaries of map, and determine if it needs to be
+based on the location of the player. */
+
+boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey, int ux,
+ int uy)
+{
+    static int width = 0;
+    static int height = 0;
+    static int osx = 0;
+    static int osy = 0;
+    static int oex = 0;
+    static int oey = 0;
+    static int oux = -1;
+    static int ouy = -1;
+    
+    if ((oux == -1) || (ouy == -1))
+    {
+        oux = u.ux;
+        ouy = u.uy;
+    }
+    
+    if (ux == -1)
+    {
+        ux = oux;
+    }
+    else
+    {
+        oux = ux;
+    }
+
+    if (uy == -1)
+    {
+        uy = ouy;
+    }
+    else
+    {
+        ouy = uy;
+    }
+
+    curses_get_window_size(MAP_WIN, &height, &width);
+    
+#ifdef MAP_SCROLLBARS
+    if (width < COLNO)
+    {
+        height--;  /* room for horizontal scrollbar */
+    }
+
+    if (height < ROWNO)
+    {
+        width--;  /* room for vertical scrollbar */
+
+        if (width == COLNO)
+        {
+            height--;
+        }
+    }
+#endif  /* MAP_SCROLLBARS */
+
+    if (width >= COLNO)
+    {
+        *sx = 0;
+        *ex = COLNO - 1;
+    }
+    else
+    {
+        *ex = (width / 2) + ux;
+        *sx = *ex - (width - 1);
+        
+        if (*ex >= COLNO)
+        {
+            *sx = COLNO - width;
+            *ex = COLNO - 1;
+        }
+        else if (*sx < 0)
+        {
+            *sx = 0;
+            *ex = width - 1;
+        }
+    }
+    
+    if (height >= ROWNO)
+    {
+        *sy = 0;
+        *ey = ROWNO - 1;
+    }
+    else
+    {
+        *ey = (height / 2) + uy;
+        *sy = *ey - (height - 1);
+        
+        if (*ey >= ROWNO)
+        {
+            *sy = ROWNO - height;
+            *ey = ROWNO - 1;
+        }
+        else if (*sy < 0)
+        {
+            *sy = 0;
+            *ey = height - 1;
+        }
+    }
+
+    if ((*sx != osx) || (*sy != osy) || (*ex != oex) || (*ey != oey) ||
+     map_clipped)
+    {
+        osx = *sx;
+        osy = *sy;
+        oex = *ex;
+        oey = *ey;
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/curses/curswins.h nethack-3.4.3-nao-osx/win/curses/curswins.h
--- nethack-3.4.3/win/curses/curswins.h	1969-12-31 16:00:00.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/curses/curswins.h	2014-12-20 12:08:36.000000000 -0800
@@ -0,0 +1,46 @@
+#ifndef CURSWIN_H
+#define CURSWIN_H
+
+
+/* Global declarations */
+
+WINDOW *curses_create_window(int width, int height, orient orientation);
+
+void curses_destroy_win(WINDOW *win);
+
+void curses_refresh_nethack_windows(void);
+
+WINDOW *curses_get_nhwin(winid wid);
+
+void curses_add_nhwin(winid wid, int height, int width, int y, int x,
+ orient orientation, boolean border);
+
+void curses_add_wid(winid wid);
+
+void curses_refresh_nhwin(winid wid);
+
+void curses_del_nhwin(winid wid);
+
+void curses_del_wid(winid wid);
+
+void curses_putch(winid wid, int x, int y, int ch, int color, int attrs);
+
+void curses_get_window_xy(winid wid, int *x, int *y);
+
+boolean curses_window_has_border(winid wid);
+
+boolean curses_window_exists(winid wid);
+
+int curses_get_window_orientation(winid wid);
+
+void curses_puts(winid wid, int attr, const char *text);
+
+void curses_clear_nhwin(winid wid);
+
+void curses_draw_map(int sx, int sy, int ex, int ey);
+
+boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey, int ux,
+ int uy);
+
+
+#endif  /* CURSWIN_H */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/gnome/gnbind.c nethack-3.4.3-nao-osx/win/gnome/gnbind.c
--- nethack-3.4.3/win/gnome/gnbind.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/gnome/gnbind.c	2014-12-20 12:08:36.000000000 -0800
@@ -1052,7 +1052,7 @@ char gnome_yn_function(const char *quest
     /* Only here if main window is not present */
     while (result<0) {
 	ch=gnome_nhgetch();
-	if (ch=='\033') {
+	if (ch==DOESCAPE) {
 	    result=yn_esc_map;
 	} else if (choices && !index(choices,ch)) {
 	    /* FYI: ch==-115 is for KP_ENTER */
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/tty/getline.c nethack-3.4.3-nao-osx/win/tty/getline.c
--- nethack-3.4.3/win/tty/getline.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/tty/getline.c	2014-12-20 12:08:36.000000000 -0800
@@ -68,10 +68,20 @@ getlin_hook_proc hook;
 #endif /* not NEWAUTOCOMP */
 			break;
 		}
-		if(c == '\033') {
-			*obufp = c;
-			obufp[1] = 0;
-			break;
+		if(c == DOESCAPE) {
+		  if (obufp[0] != '\0') {
+		    obufp[0] = 0;
+		    bufp = obufp;
+		    tty_clear_nhwindow(WIN_MESSAGE);
+		    cw->maxcol = cw->maxrow;
+		    addtopl(query);
+		    addtopl(" ");
+		    addtopl(obufp);
+		  } else {
+		    *obufp = c;
+		    obufp[1] = 0;
+		    break;
+		  }
 		}
 		if (ttyDisplay->intr) {
 		    ttyDisplay->intr--;
@@ -193,6 +203,7 @@ register const char *s;	/* chars allowed
 	    }
 	    tty_nhbell();
 	}
+	if (c == -1) break; /* lost terminal or other error */
     }
 
 }
@@ -220,6 +231,7 @@ ext_cmd_getlin_hook(base)
 
 	com_index = -1;
 	for (oindex = 0; extcmdlist[oindex].ef_txt != (char *)0; oindex++) {
+		if (!extcmdlist[oindex].autocomplete) continue;
 		if (!strncmpi(base, extcmdlist[oindex].ef_txt, strlen(base))) {
 			if (com_index == -1)	/* no matches yet */
 			    com_index = oindex;
@@ -255,7 +267,7 @@ tty_get_ext_cmd()
 	hooked_tty_getlin("#", buf, ext_cmd_getlin_hook);
 #endif
 	(void) mungspaces(buf);
-	if (buf[0] == 0 || buf[0] == '\033') return -1;
+	if (buf[0] == 0 || buf[0] == DOESCAPE) return -1;
 
 	for (i = 0; extcmdlist[i].ef_txt != (char *)0; i++)
 		if (!strcmpi(buf, extcmdlist[i].ef_txt)) break;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/tty/termcap.c nethack-3.4.3-nao-osx/win/tty/termcap.c
--- nethack-3.4.3/win/tty/termcap.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/tty/termcap.c	2014-12-20 12:53:39.000000000 -0800
@@ -40,6 +40,8 @@ static void NDECL(kill_hilite);
 struct tc_lcl_data tc_lcl_data = { 0, 0, 0, 0,0, 0,0, FALSE };
 #endif /* OVLB */
 
+int allow_bgcolor = 0;
+
 STATIC_VAR char *HO, *CL, *CE, *UP, *XD, *BC, *SO, *SE, *TI, *TE;
 STATIC_VAR char *VS, *VE;
 STATIC_VAR char *ME;
@@ -130,6 +132,7 @@ int *wid, *hgt;
 	/* HI and HE will be updated in init_hilite if we're using color */
 		nh_HI = "\033p";
 		nh_HE = "\033q";
+		allow_bgcolor = 0;
 		*wid = CO;
 		*hgt = LI;
 		CL = "\033E";		/* last thing set */
@@ -161,6 +164,7 @@ int *wid, *hgt;
 		BC = "\033[D";
 #  endif
 		nh_HI = SO = "\033[1m";
+		allow_bgcolor = 1;
 		nh_US = "\033[4m";
 		MR = "\033[7m";
 		TI = nh_HE = ME = SE = nh_UE = "\033[0m";
@@ -316,6 +320,7 @@ int *wid, *hgt;
 	AS = Tgetstr("as");
 	AE = Tgetstr("ae");
 	nh_CD = Tgetstr("cd");
+	allow_bgcolor = 1;
 # ifdef TEXTCOLOR
 	MD = Tgetstr("md");
 # endif
@@ -331,8 +336,9 @@ int *wid, *hgt;
 # endif
 	*wid = CO;
 	*hgt = LI;
-	if (!(CL = Tgetstr("cl")))	/* last thing set */
-		error("NetHack needs CL.");
+	CL = "\033[2J";		/* last thing set */
+	/*if (!(CL = Tgetstr("cl")))
+	  error("NetHack needs CL.");*/
 	if ((int)(tbufptr - tbuf) > (int)(sizeof tbuf))
 		error("TERMCAP entry too big...\n");
 	free((genericptr_t)tptr);
@@ -835,14 +841,13 @@ cl_eos()			/* free after Robert Viduya *
 
 #include <curses.h>
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(__APPLE__)
 extern char *tparm();
 #endif
 
-#  ifdef COLOR_BLACK	/* trust include file */
-#undef COLOR_BLACK
-#  else
+#  ifndef COLOR_BLACK	/* trust include file */
 #   ifndef _M_UNIX	/* guess BGR */
+#define COLOR_BLACK   0
 #define COLOR_BLUE    1
 #define COLOR_GREEN   2
 #define COLOR_CYAN    3
@@ -851,6 +856,7 @@ extern char *tparm();
 #define COLOR_YELLOW  6
 #define COLOR_WHITE   7
 #   else		/* guess RGB */
+#define COLOR_BLACK   0
 #define COLOR_RED     1
 #define COLOR_GREEN   2
 #define COLOR_YELLOW  3
@@ -860,40 +866,126 @@ extern char *tparm();
 #define COLOR_WHITE   7
 #   endif
 #  endif
-#define COLOR_BLACK COLOR_BLUE
 
-const int ti_map[8] = {
-	COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_YELLOW,
-	COLOR_BLUE, COLOR_MAGENTA, COLOR_CYAN, COLOR_WHITE };
+/* Mapping data for the six terminfo colors that resolve to pairs of nethack
+ * colors.  Black and white are handled specially.
+ */
+const struct {int ti_color, nh_color, nh_bright_color;} ti_map[6] =
+{
+	{COLOR_RED,CLR_RED,CLR_ORANGE},
+	{COLOR_GREEN,CLR_GREEN,CLR_BRIGHT_GREEN},
+	{COLOR_YELLOW,CLR_BROWN,CLR_YELLOW},
+	{COLOR_BLUE,CLR_BLUE,CLR_BRIGHT_BLUE},
+	{COLOR_MAGENTA,CLR_MAGENTA,CLR_BRIGHT_MAGENTA},
+	{COLOR_CYAN,CLR_CYAN,CLR_BRIGHT_CYAN}
+};
 
 static void
 init_hilite()
 {
 	register int c;
 	char *setf, *scratch;
-
-	for (c = 0; c < SIZE(hilites); c++)
-		hilites[c] = nh_HI;
-	hilites[CLR_GRAY] = hilites[NO_COLOR] = (char *)0;
+	int length_md;
 
 	if (tgetnum("Co") < 8
+	    || (MD == NULL) || (strlen(MD) == 0)
 	    || ((setf = tgetstr("AF", (char **)0)) == (char *)0
 		 && (setf = tgetstr("Sf", (char **)0)) == (char *)0))
+	{
+		/* Fallback when colors not available
+		 * It's arbitrary to collapse all colors except gray
+		 * together, but that's what the previous code did.
+		 */
+		hilites[CLR_BLACK] = nh_HI;
+		hilites[CLR_RED] = nh_HI;
+		hilites[CLR_GREEN] = nh_HI;
+		hilites[CLR_BROWN] = nh_HI;
+		hilites[CLR_BLUE] = nh_HI;
+		hilites[CLR_MAGENTA] = nh_HI;
+		hilites[CLR_CYAN] = nh_HI;
+		hilites[CLR_GRAY] = "";
+		hilites[NO_COLOR] = "";
+		hilites[CLR_ORANGE] = nh_HI;
+		hilites[CLR_BRIGHT_GREEN] = nh_HI;
+		hilites[CLR_YELLOW] = nh_HI;
+		hilites[CLR_BRIGHT_BLUE] = nh_HI;
+		hilites[CLR_BRIGHT_MAGENTA] = nh_HI;
+		hilites[CLR_BRIGHT_CYAN] = nh_HI;
+		hilites[CLR_WHITE] = nh_HI;
 		return;
+	}
 
-	for (c = 0; c < CLR_MAX / 2; c++) {
-	    scratch = tparm(setf, ti_map[c]);
-	    if (c != CLR_GRAY) {
-		hilites[c] = (char *) alloc(strlen(scratch) + 1);
-		Strcpy(hilites[c], scratch);
-	    }
-	    if (c != CLR_BLACK) {
-		hilites[c|BRIGHT] = (char*) alloc(strlen(scratch)+strlen(MD)+1);
-		Strcpy(hilites[c|BRIGHT], MD);
-		Strcat(hilites[c|BRIGHT], scratch);
-	    }
+	length_md = strlen(MD);
+
+	c = 6;
+	while (c--)
+	{
+	    char *work;
+
+	    scratch = tparm(setf,ti_map[c].ti_color);
+	    work = (char *) alloc(strlen(scratch) + length_md + 1);
+	    Strcpy(work,MD);
+	    hilites[ti_map[c].nh_bright_color] = work;
+	    work += length_md;
+	    Strcpy(work,scratch);
+	    hilites[ti_map[c].nh_color] = work;
+	}
+
+	scratch = tparm(setf,COLOR_WHITE);
+	hilites[CLR_WHITE] = (char *) alloc(strlen(scratch) + length_md + 1);
+	Strcpy(hilites[CLR_WHITE],MD);
+	Strcat(hilites[CLR_WHITE],scratch);
+
+	hilites[CLR_GRAY] = "";
+	hilites[NO_COLOR] = "";
 
+	if (iflags.wc2_darkgray)
+	{
+	    /* On many terminals, esp. those using classic PC CGA/EGA/VGA
+	     * textmode, specifying "hilight" and "black" simultaneously
+	     * produces a dark shade of gray that is visible against a
+	     * black background.  We can use it to represent black objects.
+	     */
+	    scratch = tparm(setf,COLOR_BLACK);
+	    hilites[CLR_BLACK] = (char *) alloc(strlen(scratch) + length_md + 1);
+	    Strcpy(hilites[CLR_BLACK],MD);
+	    Strcat(hilites[CLR_BLACK],scratch);
 	}
+	else
+	{
+	    /* But it's concievable that hilighted black-on-black could
+	     * still be invisible on many others.  We substitute blue for
+	     * black.
+	     */
+	    hilites[CLR_BLACK] = hilites[CLR_BLUE];
+	}
+}
+
+static void
+kill_hilite()
+{
+	/* if colors weren't usable, no freeing needed */
+	if (hilites[CLR_BLACK] == nh_HI)
+		return;
+
+	if (hilites[CLR_BLACK] != hilites[CLR_BLUE])
+		free(hilites[CLR_BLACK]);
+
+	/* CLR_BLUE overlaps CLR_BRIGHT_BLUE, do not free */
+	/* CLR_GREEN overlaps CLR_BRIGHT_GREEN, do not free */
+	/* CLR_CYAN overlaps CLR_BRIGHT_CYAN, do not free */
+	/* CLR_RED overlaps CLR_ORANGE, do not free */
+	/* CLR_MAGENTA overlaps CLR_BRIGHT_MAGENTA, do not free */
+	/* CLR_BROWN overlaps CLR_YELLOW, do not free */
+	/* CLR_GRAY is a constant "", do not free */
+	/* NO_COLOR is a constant "", do not free */
+	free(hilites[CLR_BRIGHT_BLUE]);
+	free(hilites[CLR_BRIGHT_GREEN]);
+	free(hilites[CLR_BRIGHT_CYAN]);
+	free(hilites[CLR_YELLOW]);
+	free(hilites[CLR_ORANGE]);
+	free(hilites[CLR_BRIGHT_MAGENTA]);
+	free(hilites[CLR_WHITE]);
 }
 
 # else /* UNIX && TERMINFO */
@@ -1040,7 +1132,6 @@ init_hilite()
 #   endif
 #  endif /* TOS */
 }
-# endif /* UNIX */
 
 static void
 kill_hilite()
@@ -1058,6 +1149,7 @@ kill_hilite()
 # endif
 	return;
 }
+# endif /* UNIX */
 #endif /* TEXTCOLOR */
 
 
@@ -1136,6 +1228,19 @@ term_end_raw_bold()
 #ifdef TEXTCOLOR
 
 void
+term_start_bgcolor(color)
+int color;
+{
+    if (allow_bgcolor) {
+	char tmp[8];
+	Sprintf(tmp, "\033[%dm", ((color % 8) + 40));
+	xputs(tmp);
+    } else {
+	xputs(e_atr2str(ATR_INVERSE));
+    }
+}
+
+void
 term_end_color()
 {
 	xputs(nh_HE);
@@ -1173,6 +1278,13 @@ int color;
 	/* hilites[] not used */
 	return iflags.use_color;
 #endif
+#ifdef CURSES_GRAPHICS
+    /* XXX has_color() should be added to windowprocs */
+    /* iflags.wc_color is set to false and the option disabled if the
+     terminal cannot display color */
+    if (windowprocs.name != NULL &&
+     !strcmpi(windowprocs.name, "curses")) return iflags.wc_color;
+#endif
 	return hilites[color] != (char *)0;
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/tty/topl.c nethack-3.4.3-nao-osx/win/tty/topl.c
--- nethack-3.4.3/win/tty/topl.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/tty/topl.c	2014-12-20 12:08:36.000000000 -0800
@@ -15,7 +15,7 @@
 #endif
 
 STATIC_DCL void FDECL(redotoplin, (const char*));
-STATIC_DCL void FDECL(topl_putsym, (CHAR_P));
+STATIC_DCL void FDECL(topl_putsym, (glyph_t));
 STATIC_DCL void NDECL(remember_topl);
 STATIC_DCL void FDECL(removetopl, (int));
 
@@ -261,7 +261,7 @@ update_topl(bp)
 STATIC_OVL
 void
 topl_putsym(c)
-    char c;
+    glyph_t c;
 {
     register struct WinDesc *cw = wins[WIN_MESSAGE];
 
@@ -295,7 +295,7 @@ topl_putsym(c)
     cw->curx = ttyDisplay->curx;
     if(cw->curx == 0) cl_end();
 #ifndef WIN32CON
-    (void) putchar(c);
+    (void) pututf8char((unsigned char) c);
 #endif
 }
 
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/tty/wintty.c nethack-3.4.3-nao-osx/win/tty/wintty.c
--- nethack-3.4.3/win/tty/wintty.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/tty/wintty.c	2014-12-20 12:08:36.000000000 -0800
@@ -16,6 +16,10 @@
 #include "patchlevel.h"
 #endif
 
+#ifdef USE_TILES
+extern short glyph2tile[];
+#endif
+
 #ifdef TTY_GRAPHICS
 
 #ifdef MAC
@@ -50,7 +54,11 @@ struct window_procs tty_procs = {
     WC_MOUSE_SUPPORT|
 #endif
     WC_COLOR|WC_HILITE_PET|WC_INVERSE|WC_EIGHT_BIT_IN,
+#ifdef TERMINFO
+    WC2_DARKGRAY,
+#else
     0L,
+#endif
     tty_init_nhwindows,
     tty_player_selection,
     tty_askname,
@@ -125,6 +133,14 @@ static char obuf[BUFSIZ];	/* BUFSIZ is d
 static char winpanicstr[] = "Bad window id %d";
 char defmorestr[] = "--More--";
 
+/** Track if the player is still selecting his character. */
+boolean in_character_selection = FALSE;
+
+
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
 #ifdef CLIPPING
 # if defined(USE_TILES) && defined(MSDOS)
 boolean clipping = FALSE;	/* clipping on? */
@@ -162,7 +178,7 @@ STATIC_DCL void FDECL(invert_all, (winid
 STATIC_DCL void FDECL(process_menu_window, (winid,struct WinDesc *));
 STATIC_DCL void FDECL(process_text_window, (winid,struct WinDesc *));
 STATIC_DCL tty_menu_item *FDECL(reverse, (tty_menu_item *));
-STATIC_DCL const char * FDECL(compress_str, (const char *));
+const char * FDECL(compress_str, (const char *));
 STATIC_DCL void FDECL(tty_putsym, (winid, int, int, CHAR_P));
 static char *FDECL(copy_of, (const char *));
 STATIC_DCL void FDECL(bail, (const char *));	/* __attribute__((noreturn)) */
@@ -182,10 +198,45 @@ static const char default_menu_cmds[] = 
 	MENU_SELECT_PAGE,
 	MENU_UNSELECT_PAGE,
 	MENU_INVERT_PAGE,
+	MENU_SEARCH,
 	0	/* null terminator */
 };
 
 
+#define TILE_ANSI_COMMAND 'z'
+
+#define AVTC_GLYPH_START 0
+#define AVTC_GLYPH_END 1
+#define AVTC_SELECT_WINDOW 2
+#define AVTC_INLINE_SYNC 3
+
+#ifdef USE_TILES
+
+int vt_tile_current_window = -2;
+
+void
+print_vt_code(i, c)
+int i, c;
+{
+    if (iflags.vt_nethack) {
+	if (c >= 0) {
+	    if (i == AVTC_SELECT_WINDOW) {
+		if (c == vt_tile_current_window) return;
+		vt_tile_current_window = c;
+	    }
+	    printf("\033[%d;%d%c", i, c, TILE_ANSI_COMMAND);
+	} else {
+	    printf("\033[%d%c", i, TILE_ANSI_COMMAND);
+	}
+    }
+}
+#else
+# define print_vt_code(i, c) ;
+# error no USE_TILES defined!
+#endif /* USE_TILES */
+
+
+
 /* clean up and quit */
 STATIC_OVL void
 bail(mesg)
@@ -324,6 +375,8 @@ tty_player_selection()
 	anything any;
 	menu_item *selected = 0;
 
+	in_character_selection = TRUE;
+
 	/* prevent an unnecessary prompt */
 	rigid_role_checks();
 
@@ -648,6 +701,7 @@ give_up:	/* Quit */
 	    }
 	}
 	/* Success! */
+	in_character_selection = FALSE;
 	tty_display_nhwindow(BASE_WINDOW, FALSE);
 }
 
@@ -678,7 +732,7 @@ tty_askname()
 	ct = 0;
 	while((c = tty_nhgetch()) != '\n') {
 		if(c == EOF) error("End of input\n");
-		if (c == '\033') { ct = 0; break; }  /* continue outer loop */
+		if (c == DOESCAPE) { ct = 0; break; }  /* continue outer loop */
 #if defined(WIN32CON)
 		if (c == '\003') bail("^C abort.\n");
 #endif
@@ -828,7 +882,7 @@ tty_create_nhwindow(type)
 	newwin->offx = newwin->offy = 0;
 	/* sanity check */
 	if(iflags.msg_history < 20) iflags.msg_history = 20;
-	else if(iflags.msg_history > 60) iflags.msg_history = 60;
+	else if(iflags.msg_history > 400) iflags.msg_history = 400;
 	newwin->maxrow = newwin->rows = iflags.msg_history;
 	newwin->maxcol = newwin->cols = 0;
 	break;
@@ -842,7 +896,7 @@ tty_create_nhwindow(type)
 #endif
 	newwin->offy = min((int)ttyDisplay->rows-2, ROWNO+1);
 	newwin->rows = newwin->maxrow = 2;
-	newwin->cols = newwin->maxcol = min(ttyDisplay->cols, COLNO);
+	newwin->cols = newwin->maxcol = min(ttyDisplay->cols, MAXCO);
 	break;
     case NHW_MAP:
 	/* map window, ROWNO lines long, full width, below message window */
@@ -976,6 +1030,8 @@ tty_clear_nhwindow(window)
 	panic(winpanicstr,  window);
     ttyDisplay->lastwin = window;
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     switch(cw->type) {
     case NHW_MESSAGE:
 	if(ttyDisplay->toplin) {
@@ -1128,6 +1184,68 @@ invert_all(window, page_start, page_end,
     }
 }
 
+#ifdef MENU_COLOR
+STATIC_OVL boolean
+get_menu_coloring(str, color, attr)
+char *str;
+int *color, *attr;
+{
+    struct menucoloring *tmpmc;
+    if (iflags.use_menu_color)
+	for (tmpmc = menu_colorings; tmpmc; tmpmc = tmpmc->next)
+# ifdef MENU_COLOR_REGEX
+#  ifdef MENU_COLOR_REGEX_POSIX
+	    if (regexec(&tmpmc->match, str, 0, NULL, 0) == 0) {
+#  else
+	    if (re_search(&tmpmc->match, str, strlen(str), 0, 9999, 0) >= 0) {
+#  endif
+# else
+	    if (pmatch(tmpmc->match, str)) {
+# endif
+		*color = tmpmc->color;
+		*attr = tmpmc->attr;
+		return TRUE;
+	    }
+    return FALSE;
+}
+#endif /* MENU_COLOR */
+
+
+boolean
+toggle_menu_curr(window, curr, lineno, in_view, counting, count)
+winid window;
+tty_menu_item *curr;
+int lineno;
+boolean in_view, counting;
+long count;
+{
+    if (curr->selected) {
+	if (counting && count > 0) {
+	    curr->count = count;
+	    if (in_view) set_item_state(window, lineno, curr);
+	    return TRUE;
+	} else { /* change state */
+	    curr->selected = FALSE;
+	    curr->count = -1L;
+	    if (in_view) set_item_state(window, lineno, curr);
+	    return TRUE;
+	}
+    } else {	/* !selected */
+	if (counting && count > 0) {
+	    curr->count = count;
+	    curr->selected = TRUE;
+	    if (in_view) set_item_state(window, lineno, curr);
+	    return TRUE;
+	} else if (!counting) {
+	    curr->selected = TRUE;
+	    if (in_view) set_item_state(window, lineno, curr);
+	    return TRUE;
+	}
+	/* do nothing counting&&count==0 */
+    }
+    return FALSE;
+}
+
 STATIC_OVL void
 process_menu_window(window, cw)
 winid window;
@@ -1204,6 +1322,10 @@ struct WinDesc *cw;
 		for (page_lines = 0, curr = page_start;
 			curr != page_end;
 			page_lines++, curr = curr->next) {
+#ifdef MENU_COLOR
+		    int color = NO_COLOR, attr = ATR_NONE;
+		    boolean menucolr = FALSE;
+#endif
 		    if (curr->selector)
 			*rp++ = curr->selector;
 
@@ -1219,6 +1341,50 @@ struct WinDesc *cw;
 		     * actually output the character.  We're faster doing
 		     * this.
 		     */
+		    /* add selector for display */
+		    if (curr->selector) {
+			/* because WIN32CON this must be done in
+			 * a brain-dead way */
+			putchar(curr->selector); ttyDisplay->curx++;
+			putchar(' '); ttyDisplay->curx++;
+			/* set item state */
+			if (curr->identifier.a_void != 0 && curr->selected) {
+			    if (curr->count == -1L)
+				(void) putchar('+'); /* all selected */
+			    else
+				(void) putchar('#'); /* count selected */
+			} else {
+			    putchar('-');
+			}
+			ttyDisplay->curx++;
+			putchar(' '); ttyDisplay->curx++;
+		    }
+#ifndef WIN32CON
+		    if (curr->glyph != NO_GLYPH && iflags.use_menu_glyphs) {
+			int glyph_color = NO_COLOR;
+			glyph_t character;
+			unsigned special; /* unused */
+			/* map glyph to character and color */
+			mapglyph(curr->glyph, &character, &glyph_color, &special, 0, 0);
+
+			print_vt_code(AVTC_GLYPH_START, glyph2tile[curr->glyph]);
+			if (glyph_color != NO_COLOR) term_start_color(glyph_color);
+			pututf8char(character);
+			if (glyph_color != NO_COLOR) term_end_color();
+			print_vt_code(AVTC_GLYPH_END, -1);
+			putchar(' ');
+			ttyDisplay->curx +=2;
+		    }
+#endif
+
+
+#ifdef MENU_COLOR
+		   if (iflags.use_menu_color &&
+		       (menucolr = get_menu_coloring(curr->str, &color,&attr))) {
+		       term_start_attr(attr);
+		       if (color != NO_COLOR) term_start_color(color);
+		   } else
+#endif
 		    term_start_attr(curr->attr);
 		    for (n = 0, cp = curr->str;
 #ifndef WIN32CON
@@ -1228,14 +1394,13 @@ struct WinDesc *cw;
 			  *cp && (int) ttyDisplay->curx < (int) ttyDisplay->cols;
 			  cp++, n++, ttyDisplay->curx++)
 #endif
-			if (n == 2 && curr->identifier.a_void != 0 &&
-							curr->selected) {
-			    if (curr->count == -1L)
-				(void) putchar('+'); /* all selected */
-			    else
-				(void) putchar('#'); /* count selected */
-			} else
-			    (void) putchar(*cp);
+		    (void) pututf8char((unsigned char) *cp);
+#ifdef MENU_COLOR
+		   if (iflags.use_menu_color && menucolr) {
+		       if (color != NO_COLOR) term_end_color();
+		       term_end_attr(attr);
+		   } else
+#endif
 		    term_end_attr(curr->attr);
 		}
 	    } else {
@@ -1380,6 +1545,33 @@ struct WinDesc *cw;
 		if (cw->how == PICK_ANY)
 		    invert_all(window, page_start, page_end, 0);
 		break;
+	    case MENU_SEARCH:
+		if (cw->how == PICK_NONE) {
+		    tty_nhbell();
+		    break;
+		} else {
+		    char searchbuf[BUFSZ], tmpbuf[BUFSZ];
+		    boolean on_curr_page = FALSE;
+		    int lineno = 0;
+		    tty_getlin("Search for:", tmpbuf);
+		    if (!tmpbuf || tmpbuf[0] == '\033') break;
+		    Sprintf(searchbuf, "*%s*", tmpbuf);
+		    for (curr = cw->mlist; curr; curr = curr->next) {
+			if (on_curr_page) lineno++;
+			if (curr == page_start)
+			    on_curr_page = TRUE;
+			else if (curr == page_end)
+			    on_curr_page = FALSE;
+			if (curr->identifier.a_void && pmatch(searchbuf, curr->str)) {
+			    toggle_menu_curr(window, curr, lineno, on_curr_page, counting, count);
+			    if (cw->how == PICK_ONE) {
+				finished = TRUE;
+				break;
+			    }
+			}
+		    }
+		}
+		break;
 	    default:
 		if (cw->how == PICK_NONE || !index(resp, morc)) {
 		    /* unacceptable input received */
@@ -1398,27 +1590,7 @@ struct WinDesc *cw;
 			curr != page_end;
 			n++, curr = curr->next)
 		    if (morc == curr->selector) {
-			if (curr->selected) {
-			    if (counting && count > 0) {
-				curr->count = count;
-				set_item_state(window, n, curr);
-			    } else { /* change state */
-				curr->selected = FALSE;
-				curr->count = -1L;
-				set_item_state(window, n, curr);
-			    }
-			} else {	/* !selected */
-			    if (counting && count > 0) {
-				curr->count = count;
-				curr->selected = TRUE;
-				set_item_state(window, n, curr);
-			    } else if (!counting) {
-				curr->selected = TRUE;
-				set_item_state(window, n, curr);
-			    }
-			    /* do nothing counting&&count==0 */
-			}
-
+			toggle_menu_curr(window, curr, n, TRUE, counting, count);
 			if (cw->how == PICK_ONE) finished = TRUE;
 			break;	/* from `for' loop */
 		    }
@@ -1443,7 +1615,7 @@ struct WinDesc *cw;
 	    tty_curs(window, 1, n);
 	    cl_end();
 	    dmore(cw, quitchars);
-	    if (morc == '\033') {
+	    if (morc == DOESCAPE) {
 		cw->flags |= WIN_CANCELLED;
 		break;
 	    }
@@ -1470,7 +1642,7 @@ struct WinDesc *cw;
 		    *cp && (int) ttyDisplay->curx < (int) ttyDisplay->cols;
 		    cp++, ttyDisplay->curx++)
 #endif
-		(void) putchar(*cp);
+	    (void) pututf8char(*cp);
 	    term_end_attr(attr);
 	}
     }
@@ -1479,7 +1651,7 @@ struct WinDesc *cw;
 		 (cw->type == NHW_TEXT) ? (int) ttyDisplay->rows - 1 : n);
 	cl_end();
 	dmore(cw, quitchars);
-	if (morc == '\033')
+	if (morc == DOESCAPE)
 	    cw->flags |= WIN_CANCELLED;
     }
 }
@@ -1499,6 +1671,8 @@ tty_display_nhwindow(window, blocking)
     ttyDisplay->lastwin = window;
     ttyDisplay->rawprint = 0;
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     switch(cw->type) {
     case NHW_MESSAGE:
 	if(ttyDisplay->toplin == 1) {
@@ -1529,11 +1703,19 @@ tty_display_nhwindow(window, blocking)
 	/* avoid converting to uchar before calculations are finished */
 	cw->offx = (uchar) (int)
 	    max((int) 10, (int) (ttyDisplay->cols - cw->maxcol - 1));
-	if(cw->type == NHW_MENU)
+	if(cw->type == NHW_MENU
+#ifdef WIN_EDGE
+	    || iflags.win_edge
+#endif
+	)
 	    cw->offy = 0;
 	if(ttyDisplay->toplin == 1)
 	    tty_display_nhwindow(WIN_MESSAGE, TRUE);
-	if(cw->offx == 10 || cw->maxrow >= (int) ttyDisplay->rows) {
+	if(cw->offx == 10 || cw->maxrow >= (int) ttyDisplay->rows
+#ifdef WIN_EDGE
+	    || iflags.win_edge
+#endif
+	) {
 	    cw->offx = 0;
 	    if(cw->offy) {
 		tty_curs(window, 1, 0);
@@ -1562,6 +1744,8 @@ tty_dismiss_nhwindow(window)
     if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
 	panic(winpanicstr,  window);
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     switch(cw->type) {
     case NHW_MESSAGE:
 	if (ttyDisplay->toplin)
@@ -1631,6 +1815,8 @@ register int x, y;	/* not xchar: perhaps
 	panic(winpanicstr,  window);
     ttyDisplay->lastwin = window;
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
 #if defined(USE_TILES) && defined(MSDOS)
     adjust_cursor_flags(cw);
 #endif
@@ -1704,12 +1890,22 @@ tty_putsym(window, x, y, ch)
     if(window == WIN_ERR || (cw = wins[window]) == (struct WinDesc *) 0)
 	panic(winpanicstr,  window);
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     switch(cw->type) {
     case NHW_STATUS:
     case NHW_MAP:
     case NHW_BASE:
 	tty_curs(window, x, y);
+#ifdef UTF8_GLYPHS
+	if (iflags.UTF8graphics) {
+		pututf8char((unsigned char)ch);
+	} else {
+		(void) putchar(ch);
+	}
+#else
 	(void) putchar(ch);
+#endif
 	ttyDisplay->curx++;
 	cw->curx++;
 	break;
@@ -1722,7 +1918,7 @@ tty_putsym(window, x, y, ch)
 }
 
 
-STATIC_OVL const char*
+const char*
 compress_str(str)
 const char *str;
 {
@@ -1754,7 +1950,7 @@ tty_putstr(window, attr, str)
     register struct WinDesc *cw = 0;
     register char *ob;
     register const char *nb;
-    register int i, j, n0;
+    register long i, j, n0;
 
     /* Assume there's a real problem if the window is missing --
      * probably a panic message
@@ -1772,6 +1968,8 @@ tty_putstr(window, attr, str)
 
     ttyDisplay->lastwin = window;
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     switch(cw->type) {
     case NHW_MESSAGE:
 	/* really do this later */
@@ -1831,7 +2029,11 @@ tty_putstr(window, attr, str)
 		cw->cury++;
 		tty_curs(window, cw->curx+1, cw->cury);
 	    }
-	    (void) putchar(*str);
+	    if (iflags.UTF8graphics) {
+		    pututf8char(*str);
+	    } else {
+		    (void) putchar(*str);
+	    }
 	    str++;
 	    ttyDisplay->curx++;
 	}
@@ -1986,7 +2188,7 @@ tty_start_menu(window)
 void
 tty_add_menu(window, glyph, identifier, ch, gch, attr, str, preselected)
     winid window;	/* window to use, must be of type NHW_MENU */
-    int glyph;		/* glyph to display with item (unused) */
+    int glyph;		/* glyph to display with item */
     const anything *identifier;	/* what to return if selected */
     char ch;		/* keyboard accelerator (0 = pick our own) */
     char gch;		/* group accelerator (0 = no group) */
@@ -1996,8 +2198,6 @@ tty_add_menu(window, glyph, identifier, 
 {
     register struct WinDesc *cw = 0;
     tty_menu_item *item;
-    const char *newstr;
-    char buf[4+BUFSZ];
 
     if (str == (const char*) 0)
 	return;
@@ -2007,19 +2207,6 @@ tty_add_menu(window, glyph, identifier, 
 	panic(winpanicstr,  window);
 
     cw->nitems++;
-    if (identifier->a_void) {
-	int len = strlen(str);
-	if (len >= BUFSZ) {
-	    /* We *think* everything's coming in off at most BUFSZ bufs... */
-	    impossible("Menu item too long (%d).", len);
-	    len = BUFSZ - 1;
-	}
-	Sprintf(buf, "%c - ", ch ? ch : '?');
-	(void) strncpy(buf+4, str, len);
-	buf[4+len] = '\0';
-	newstr = buf;
-    } else
-	newstr = str;
 
     item = (tty_menu_item *) alloc(sizeof(tty_menu_item));
     item->identifier = *identifier;
@@ -2028,7 +2215,8 @@ tty_add_menu(window, glyph, identifier, 
     item->selector = ch;
     item->gselector = gch;
     item->attr = attr;
-    item->str = copy_of(newstr);
+    item->str = copy_of(str);
+    item->glyph = glyph;
 
     item->next = cw->mlist;
     cw->mlist = item;
@@ -2103,12 +2291,22 @@ tty_end_menu(window, prompt)
 	    cw->plist[n/lmax] = curr;
 	}
 	if (curr->identifier.a_void && !curr->selector) {
-	    curr->str[0] = curr->selector = menu_ch;
+	    curr->selector = menu_ch;
 	    if (menu_ch++ == 'z') menu_ch = 'A';
 	}
 
 	/* cut off any lines that are too long */
-	len = strlen(curr->str) + 2;	/* extra space at beg & end */
+	len = strlen((curr->str ? curr->str : "")) + 2;	/* extra space at beg & end */
+
+	if (curr->selector) {
+	    /* extra space for keyboard accelerator */
+	    len += 4;
+	    if (curr->glyph != NO_GLYPH && iflags.use_menu_glyphs) {
+		/* extra space for glyph */
+		len += 2;
+	    }
+	}
+
 	if (len > (int)ttyDisplay->cols) {
 	    curr->str[ttyDisplay->cols-2] = 0;
 	    len = ttyDisplay->cols;
@@ -2123,7 +2321,7 @@ tty_end_menu(window, prompt)
     if (cw->npages > 1) {
 	char buf[QBUFSZ];
 	/* produce the largest demo string */
-	Sprintf(buf, "(%d of %d) ", cw->npages, cw->npages);
+	Sprintf(buf, "(%ld of %ld) ", cw->npages, cw->npages);
 	len = strlen(buf);
 	cw->morestr = copy_of("");
     } else {
@@ -2223,7 +2421,7 @@ const char *mesg;
     wins[WIN_MESSAGE]->flags &= ~WIN_CANCELLED;
     ttyDisplay->dismiss_more = 0;
 
-    return ((how == PICK_ONE && morc == let) || morc == '\033') ? morc : '\0';
+    return ((how == PICK_ONE && morc == let) || morc == DOESCAPE) ? morc : '\0';
 }
 
 void
@@ -2296,7 +2494,8 @@ docorner(xmin, ymax)
     }
 
     end_glyphout();
-    if (ymax >= (int) wins[WIN_STATUS]->offy) {
+    if (!in_character_selection && /* check for status lines to update */
+	(ymax >= (int) wins[WIN_STATUS]->offy)) {
 					/* we have wrecked the bottom line */
 	flags.botlx = 1;
 	bot();
@@ -2411,7 +2610,7 @@ tty_print_glyph(window, x, y, glyph)
     xchar x, y;
     int glyph;
 {
-    int ch;
+    glyph_t ch;
     boolean reverse_on = FALSE;
     int	    color;
     unsigned special;
@@ -2425,9 +2624,13 @@ tty_print_glyph(window, x, y, glyph)
     /* map glyph to character and color */
     mapglyph(glyph, &ch, &color, &special, x, y);
 
+    print_vt_code(AVTC_SELECT_WINDOW, window);
+
     /* Move the cursor. */
     tty_curs(window, x,y);
 
+    print_vt_code(AVTC_GLYPH_START, glyph2tile[glyph]);
+
 #ifndef NO_TERMS
     if (ul_hack && ch == '_') {		/* non-destructive underscore */
 	(void) putchar((char) ' ');
@@ -2452,12 +2655,29 @@ tty_print_glyph(window, x, y, glyph)
 	reverse_on = TRUE;
     }
 
+#ifdef TEXTCOLOR
+    if ((window == NHW_MAP) && !reverse_on && (special & (MG_STAIRS|MG_OBJPILE))) {
+	if ((special & MG_STAIRS) && iflags.hilite_hidden_stairs)
+	    term_start_bgcolor(CLR_RED);
+	else if ((special & MG_OBJPILE) && iflags.hilite_obj_piles)
+	    term_start_bgcolor(CLR_BLUE);
+    }
+#endif
+
 #if defined(USE_TILES) && defined(MSDOS)
     if (iflags.grmode && iflags.tile_view)
       xputg(glyph,ch,special);
     else
 #endif
+#ifdef UTF8_GLYPHS
+	if (iflags.UTF8graphics) {
+		pututf8char(get_unicode_codepoint(ch));
+	} else {
+		g_putch(ch);	/* print the character */
+	}
+#else
 	g_putch(ch);		/* print the character */
+#endif
 
     if (reverse_on) {
     	term_end_attr(ATR_INVERSE);
@@ -2470,6 +2690,15 @@ tty_print_glyph(window, x, y, glyph)
 #endif
     }
 
+    print_vt_code(AVTC_GLYPH_END, -1);
+
+#ifdef TEXTCOLOR
+    if (!reverse_on && (special & (MG_STAIRS|MG_OBJPILE))) {
+	term_end_color();
+	ttyDisplay->color = NO_COLOR;
+    }
+#endif
+
     wins[window]->curx++;	/* one character over */
     ttyDisplay->curx++;		/* the real cursor moved too */
 }
@@ -2510,6 +2739,7 @@ int
 tty_nhgetch()
 {
     int i;
+    int tmp;
 #ifdef UNIX
     /* kludge alert: Some Unix variants return funny values if getc()
      * is called, interrupted, and then called again.  There
@@ -2520,6 +2750,7 @@ tty_nhgetch()
     char nestbuf;
 #endif
 
+    print_vt_code(AVTC_INLINE_SYNC, -1);
     (void) fflush(stdout);
     /* Note: if raw_print() and wait_synch() get called to report terminal
      * initialization problems, then wins[] and ttyDisplay might not be
@@ -2536,9 +2767,14 @@ tty_nhgetch()
 #else
     i = tgetch();
 #endif
-    if (!i) i = '\033'; /* map NUL to ESC since nethack doesn't expect NUL */
+    if (!i) i = DOESCAPE; /* map NUL to ESC since nethack doesn't expect NUL */
     if (ttyDisplay && ttyDisplay->toplin == 1)
 	ttyDisplay->toplin = 2;
+#ifdef USE_TILES
+    tmp = vt_tile_current_window;
+    vt_tile_current_window++;
+    print_vt_code(AVTC_SELECT_WINDOW, tmp);
+#endif
     return i;
 }
 
@@ -2564,7 +2800,7 @@ tty_nh_poskey(x, y, mod)
 	    wins[WIN_MESSAGE]->flags &= ~WIN_STOP;
     i = ntposkey(x, y, mod);
     if (!i && mod && *mod == 0)
-    	i = '\033'; /* map NUL to ESC since nethack doesn't expect NUL */
+    	i = DOESCAPE; /* map NUL to ESC since nethack doesn't expect NUL */
     if (ttyDisplay && ttyDisplay->toplin == 1)
 		ttyDisplay->toplin = 2;
     return i;
diff --exclude='.git*' --exclude='*.diff' --exclude='*.patch' --exclude=Makefile -rupN nethack-3.4.3/win/win32/mhmenu.c nethack-3.4.3-nao-osx/win/win32/mhmenu.c
--- nethack-3.4.3/win/win32/mhmenu.c	2003-12-07 15:39:14.000000000 -0800
+++ nethack-3.4.3-nao-osx/win/win32/mhmenu.c	2014-12-20 12:08:36.000000000 -0800
@@ -63,6 +63,10 @@ typedef struct mswin_nethack_menu_window
 
 extern short glyph2tile[];
 
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
 static WNDPROC wndProcListViewOrig = NULL;
 static WNDPROC editControlWndProc = NULL;
 
@@ -83,6 +87,58 @@ static void SelectMenuItem(HWND hwndList
 static void reset_menu_count(HWND hwndList, PNHMenuWindow data);
 static BOOL onListChar(HWND hWnd, HWND hwndList, WORD ch);
 
+#ifdef MENU_COLOR
+/* FIXME: nhcolor_to_RGB copied from mhmap.c */
+/* map nethack color to RGB */
+COLORREF nhcolor_to_RGB(int c)
+{
+	switch(c) {
+	case CLR_BLACK:			return RGB(0x55, 0x55, 0x55);
+	case CLR_RED:			return RGB(0xFF, 0x00, 0x00);
+	case CLR_GREEN:			return RGB(0x00, 0x80, 0x00);
+	case CLR_BROWN:			return RGB(0xA5, 0x2A, 0x2A);
+	case CLR_BLUE:			return RGB(0x00, 0x00, 0xFF);
+	case CLR_MAGENTA:		return RGB(0xFF, 0x00, 0xFF);
+	case CLR_CYAN:			return RGB(0x00, 0xFF, 0xFF);
+	case CLR_GRAY:			return RGB(0xC0, 0xC0, 0xC0);
+	case NO_COLOR:			return RGB(0xFF, 0xFF, 0xFF);
+	case CLR_ORANGE:		return RGB(0xFF, 0xA5, 0x00);
+	case CLR_BRIGHT_GREEN:		return RGB(0x00, 0xFF, 0x00);
+	case CLR_YELLOW:		return RGB(0xFF, 0xFF, 0x00);
+	case CLR_BRIGHT_BLUE:		return RGB(0x00, 0xC0, 0xFF);
+	case CLR_BRIGHT_MAGENTA: 	return RGB(0xFF, 0x80, 0xFF);
+	case CLR_BRIGHT_CYAN:		return RGB(0x80, 0xFF, 0xFF);	/* something close to aquamarine */
+	case CLR_WHITE:			return RGB(0xFF, 0xFF, 0xFF);
+	default:			return RGB(0x00, 0x00, 0x00);	/* black */
+	}
+}
+
+
+STATIC_OVL boolean
+get_menu_coloring(str, color, attr)
+char *str;
+int *color, *attr;
+{
+    struct menucoloring *tmpmc;
+    if (iflags.use_menu_color)
+	for (tmpmc = menu_colorings; tmpmc; tmpmc = tmpmc->next)
+# ifdef MENU_COLOR_REGEX
+#  ifdef MENU_COLOR_REGEX_POSIX
+	    if (regexec(&tmpmc->match, str, 0, NULL, 0) == 0) {
+#  else
+	    if (re_search(&tmpmc->match, str, strlen(str), 0, 9999, 0) >= 0) {
+#  endif
+# else
+	    if (pmatch(tmpmc->match, str)) {
+# endif
+		*color = tmpmc->color;
+		*attr = tmpmc->attr;
+		return TRUE;
+	    }
+    return FALSE;
+}
+#endif /* MENU_COLOR */
+
 /*-----------------------------------------------------------------------------*/
 HWND mswin_init_menu_window (int type) {
 	HWND ret;
@@ -767,6 +823,11 @@ BOOL onDrawItem(HWND hWnd, WPARAM wParam
 	char *p, *p1;
 	int column;
 
+#ifdef MENU_COLOR
+	int color = NO_COLOR, attr;
+	boolean menucolr = FALSE;
+#endif
+
 	lpdis = (LPDRAWITEMSTRUCT) lParam; 
 
     /* If there are no list box items, skip this message. */
@@ -813,6 +874,15 @@ BOOL onDrawItem(HWND hWnd, WPARAM wParam
 			buf[0] = item->accelerator;
 			buf[1] = '\x0';
 
+#ifdef MENU_COLOR
+			if (iflags.use_menu_color &&
+			    (menucolr = get_menu_coloring(item->str, &color,&attr))) {
+			    /* TODO: use attr too */
+			    if (color != NO_COLOR)
+				SetTextColor(lpdis->hDC, nhcolor_to_RGB(color));
+			}
+#endif
+
 			SetRect( &drawRect, x, lpdis->rcItem.top, lpdis->rcItem.right, lpdis->rcItem.bottom );
 			DrawText(lpdis->hDC, NH_A2W(buf, wbuf, 2), 1, &drawRect, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
 		}
